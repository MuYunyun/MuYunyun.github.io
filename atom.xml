<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Time Flying</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://muyunyun.cn/"/>
  <updated>2020-03-10T02:48:19.065Z</updated>
  <id>http://muyunyun.cn/</id>
  
  <author>
    <name>牧云云</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>The Annual Summary Of 2019</title>
    <link href="http://muyunyun.cn/posts/7837c1ae/"/>
    <id>http://muyunyun.cn/posts/7837c1ae/</id>
    <published>2020-01-01T08:15:13.000Z</published>
    <updated>2020-03-10T02:48:19.065Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 18:57:14 GMT+0800 (China Standard Time) --><p>Time is flying, it arrives at the end of year again. This is my first year working in PinDuoDuo inc and it seems I arrive in the company yesterday. This point is a good chance to talk with(recognize) myself again. I try to conclude from <code>work</code>, <code>output</code>, <code>life</code> and <code>destination</code>.</p><a id="more"></a><h3 id="Learn-from-work"><a href="#Learn-from-work" class="headerlink" title="Learn from work"></a>Learn from work</h3><p>The first course I learn from my team is about <code>starting with the end</code>. It means everything we do today is prepared for the tomorrow. In the other word, we should realize which period the thing we’re doing is in, and our team write summary every week to make sure the established goals become closer and closer.</p><p>The second course I learn from the work is to try to <code>use English more</code>. There are so much rich resource in Medium, MDN, Frontend Masters and even in twitter. It’s the first time I met with so many foreigners engineer in the JSConf but I can’t talk with them fluently. It’s obviously using English skillfully will open your eyes and improve efficiency looking for some information.</p><p>The last but most important is <code>how to communicate</code>. It’s artistic to describe something easily to make others understand. When arriving at our team at first, one of my leader’s advice is the best way to join in the team is to share —— sharing ideas, knowledge and feeling. My colleagues are so excellent I learn a lot from them in these technical sharing parties every week. At the meanwhile I also share some ideas in it.</p><h3 id="Output-of-the-article"><a href="#Output-of-the-article" class="headerlink" title="Output of the article"></a>Output of the article</h3><p>There are ten new articles added to <a href="https://github.com/MuYunyun/blog" target="_blank" rel="noopener">my blog</a>, the direction is to talk about React, JavaScript, CSS and so on. If there are mistakes in it, welcome <a href="https://github.com/MuYunyun/blog/issues/new" target="_blank" rel="noopener">point out</a>.</p><ul><li><a href="http://muyunyun.cn/posts/8b09c168/">Introduction To Functional Programming</a></li><li><a href="http://muyunyun.cn/posts/9f41fc98/">Do Search In Data Structure Of React Fiber</a></li><li><a href="http://muyunyun.cn/posts/44b01006/">Understand React Suspense deeply</a></li><li><a href="http://muyunyun.cn/posts/ba7c84ae/">You don’t know requestIdleCallback</a></li><li><a href="http://muyunyun.cn/posts/290a4219/">Deep into React Hooks</a></li><li><a href="http://muyunyun.cn/posts/a1be1d41/">How to make page run smoothly</a></li><li><a href="http://muyunyun.cn/posts/32fb0f08/">Deep into React Hooks —— Design Pattern</a></li><li><a href="http://muyunyun.cn/posts/76ba81e7/">Modern React test</a></li><li><a href="http://muyunyun.cn/posts/8bdf2cdf/">Learn Controlled Component and Uncontrolled Component Again</a></li><li><a href="http://muyunyun.cn/posts/33fba87f/">INHERITED AND NON-INHERITED IN CSS</a></li></ul><p>There will be more creative articles to add in the future. Let’s grow up together.</p><h3 id="Life"><a href="#Life" class="headerlink" title="Life"></a>Life</h3><p>I enjoy the quiet time sitting in the Cafe the whole day in Saturday and it’s also nice to chat with friends or family there.</p><p><img src="http://with.muyunyun.cn/65758e96048af8ff1fd619ba1abc834a.jpg-400" alt=""></p><p>And in other some weekend days, I take part in some FE conferences this year —— <code>FDConf</code>, <code>VUE Conf</code>, <code>D2</code>, <code>SEE Conf</code> and so on. From these activities I learn some some new knowledge. For example, the article <a href="http://muyunyun.cn/posts/a1be1d41/">How to make page run smoothly</a> is written after listening the sharing of Liu Bowen in FDConf. And luckily, I get the chance to take photo with <a href="https://twitter.com/youyuxi" target="_blank" rel="noopener">Evan You</a> and get the<br>signature from him.</p><p><img src="http://with.muyunyun.cn/27a9372dcab28c9c15e1b273096b2680.jpg-300" alt=""></p><p>At the same time, it’s happy to meet with old friends and make with new friends in these activities.</p><h3 id="Checklist-amp-amp-Destination"><a href="#Checklist-amp-amp-Destination" class="headerlink" title="Checklist &amp;&amp; Destination"></a>Checklist &amp;&amp; Destination</h3><p>Checking the plan of last year before making plans in new year.</p><ul><li>Reading <code>five</code> technical books and a not technical book, <del>learn Functional Programming</del>: It is a shame not achieve this target. Instead of reading the whole books, I read more single posts or chapters partly in the last year.</li><li>Finishing <del>a valuable project</del>: There are some valuable projects in my daily work, they’re still in progress.</li><li><del>Deep into <code>React</code> community</del>, submit a pr: There is some deep analyze in React this year, however it still needs making extra effort for making a pr;</li><li>Deep <del>into the document of <code>Node.Js</code></del>: the work of this year is connected with UI and component more closely, so the document of Node.Js has no much chance reading in practice;</li><li><del>Improving the skill of communication, do a sharing in a party</del>: The communication skill gets some improved, however it still needs be strengthened;</li><li><del>Invite friends fro coffee(at least 12)</del></li></ul><p>Keeping going on in the new year. Here lists some direction.</p><ul><li>Keeping reading and writing. Creating more personal thoughts;</li><li>Improving listening/writing skill in English continually;<ul><li>Way: watching ten+ english movies and try to write some english posts.</li></ul></li><li>Improving the basic skills in data structure and composition principle continually;</li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun May 10 2020 18:57:14 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;Time is flying, it arrives at the end of year again. This is my first year working in PinDuoDuo inc and it seems I arrive in the company yesterday. This point is a good chance to talk with(recognize) myself again. I try to conclude from &lt;code&gt;work&lt;/code&gt;, &lt;code&gt;output&lt;/code&gt;, &lt;code&gt;life&lt;/code&gt; and &lt;code&gt;destination&lt;/code&gt;.&lt;/p&gt;
    
    </summary>
    
    
      <category term="Annual Summary" scheme="http://muyunyun.cn/categories/Annual-Summary/"/>
    
    
      <category term="Annual Summary" scheme="http://muyunyun.cn/tags/Annual-Summary/"/>
    
  </entry>
  
  <entry>
    <title>INHERITED AND NON-INHERITED IN CSS</title>
    <link href="http://muyunyun.cn/posts/33fba87f/"/>
    <id>http://muyunyun.cn/posts/33fba87f/</id>
    <published>2019-12-10T01:30:15.000Z</published>
    <updated>2019-12-10T01:32:07.283Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 18:57:14 GMT+0800 (China Standard Time) --><p><img src="http://with.muyunyun.cn/b22bcdb94d354d3f301cae7997d9cd17.jpg" alt=""></p><p>When I look up css properties in MDN’s specifications section, there are some properties in it and it seems unfamiliar to me. So I try to find out some of them today.</p><a id="more"></a><p>The follow list try to give one word to specify the meaning of them.</p><ul><li>Initial value: Specify the CSS property’s default value;</li><li>Applies to: Specify which elements to apply to;</li><li>Inherited: Specify the CSS property is inherited or non-inherited;</li><li><a href="https://www.w3.org/TR/css3-mediaqueries/" target="_blank" rel="noopener">Media</a>: Specify how a document is to be presented on different media;</li><li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/computed_value" target="_blank" rel="noopener">Computed value</a>: The CSS property that is transferred from parent to child;</li><li><a href="https://drafts.csswg.org/web-animations/#animation-type" target="_blank" rel="noopener">Animation type</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Glossary/Canonical_order" target="_blank" rel="noopener">Canonical order</a>: Some CSS properties(font、background…) have their own CSS property value order.</li></ul><p>And this article is to discuss the topic about the knowledge of inherited and non-inherited.</p><h3 id="Initial-value-between-inherited-and-non-inherited"><a href="#Initial-value-between-inherited-and-non-inherited" class="headerlink" title="Initial value between inherited and non-inherited"></a>Initial value between inherited and non-inherited</h3><p>The initial value of a CSS property is its default value.</p><p>The Initial value has two different behavior between <code>inherited properties</code> and <code>non-inherited properties</code>.</p><p>For <code>inherited properties</code>, the initial value is <code>used on the root element only</code>.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"color: red"</span>&gt;</span></span><br><span class="line">  hello, <span class="tag">&lt;<span class="name">em</span>&gt;</span>CSS<span class="tag">&lt;/<span class="name">em</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><p>The result is the color of both <code>span</code> and <code>em</code> element are red. Because the color is an inherited property, the element will get the color property from the parent recursively until to document.</p><p>For <code>non-inherited properties</code>, the initial value is <code>used on every element</code>. When no value for a non-inherited property has been specified on an element, the element gets the initial value directly.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"border: 1px solid black"</span>&gt;</span></span><br><span class="line">  hello, <span class="tag">&lt;<span class="name">em</span>&gt;</span>CSS<span class="tag">&lt;/<span class="name">em</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><p>The result is the border is only effected on <code>span</code> element, not <code>em</code>. Because the border is a non-inherited property, and there is no border property specified on the em, so the em get the border’s initial value <code>none</code>.</p><p>It mentioned much times about inherited value and non-inherited value above, and now we sort out css properties.</p><h3 id="Inherited-Type"><a href="#Inherited-Type" class="headerlink" title="Inherited Type"></a>Inherited Type</h3><p>I’ve collected some inherited types in css, they are listed as follow:</p><ul><li><code>Font Type</code>: font-style、font-variant、font-weight、font-stretch、font-size、font-family、color、line-height;</li><li><code>Space Type</code>: letter-spacing、word-spacing、white-space;</li><li><code>Letter Type</code>: text-align、text-indent、text-shadow、text-transform;</li><li><code>List Type</code>: list-style、list-style-type、list-style-position;</li><li><code>Others</code>: visibility、cursor;</li></ul><h3 id="Non-Inherited-Type"><a href="#Non-Inherited-Type" class="headerlink" title="Non-Inherited Type"></a>Non-Inherited Type</h3><p>In the opposite of inherited type, the non-inherited types are listed as follow:</p><ul><li><code>Layout Type</code>: float、position、left、right、top、bottom、z-index、display</li><li><code>Box Type</code>: width、max-width、min-width、height、max-height、min-height、margin、padding、border;</li><li><code>Background Type</code>: background-size、background-image、background-clip、background-color、background-origin、background-position、background-repeat;</li><li><code>Others</code>: overflow、text-overflow、vertical-align;</li></ul><h3 id="Recap"><a href="#Recap" class="headerlink" title="Recap"></a>Recap</h3><p>These section introduces the inherited concept in CSS, and distinguish some inherited type and some non-inherited type from css properties. Hope it’s helpful for you.</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun May 10 2020 18:57:14 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;&lt;img src=&quot;http://with.muyunyun.cn/b22bcdb94d354d3f301cae7997d9cd17.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;When I look up css properties in MDN’s specifications section, there are some properties in it and it seems unfamiliar to me. So I try to find out some of them today.&lt;/p&gt;
    
    </summary>
    
    
      <category term="CSS" scheme="http://muyunyun.cn/categories/CSS/"/>
    
    
      <category term="CSS" scheme="http://muyunyun.cn/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>组件设计 —— 重新认识受控与非受控组件</title>
    <link href="http://muyunyun.cn/posts/8bdf2cdf/"/>
    <id>http://muyunyun.cn/posts/8bdf2cdf/</id>
    <published>2019-11-23T10:22:00.000Z</published>
    <updated>2019-11-23T10:34:38.171Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 18:57:15 GMT+0800 (China Standard Time) --><p><img src="http://with.muyunyun.cn/21ec115261725fc7a37543143c1e89ed.jpg-400" alt=""></p><a id="more"></a><h3 id="重新定义受控与非受控组件的边界"><a href="#重新定义受控与非受控组件的边界" class="headerlink" title="重新定义受控与非受控组件的边界"></a>重新定义受控与非受控组件的边界</h3><p><img src="http://with.muyunyun.cn/3e1327ce86f89d2763d8fed9c169887d.jpg-400" alt=""></p><p><a href="https://reactjs.org/docs/uncontrolled-components.html" target="_blank" rel="noopener">React 官网中</a>对非受控组件与受控组件作了如图中下划线的边界定义。一经推敲, 该定义是缺乏了些<code>完整性</code>和<code>严谨性</code>的, 比如针对非表单组件(弹框、轮播图)如何划分受控与非受控的边界? 又比如非受控组件是否真的如文案上所说的数据的展示与变更都由 dom 自身接管呢?</p><p>在非受控组件中, 通常业务调用方只需传入一个<code>初始默认值</code>便可使用该组件。以 Input 组件为例:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组件提供方</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Input</span>(<span class="params">&#123; defaultValue &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">defaultValue</span>=<span class="string">&#123;defaultValue&#125;</span> /&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用方</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Demo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Input</span> <span class="attr">defaultValue</span>=<span class="string">&#123;1&#125;</span> /&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在受控组件中, 数值的<code>展示与变更</code>则分别由组件的 <code>state</code> 与 <code>setState</code> 接管。同样以 Input 组件为例:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组件提供方</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Input</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [value, setValue] = React.useState(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">&#123;value&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;e</span> =&gt;</span> setValue(e.target.value)&#125; /&gt;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用方</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Demo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Input</span> /&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有意思的一个问题来了, <code>Input</code> 组件到底是受控的还是非受控的? 我们甚至还可以对代码稍加改动成 <code>&lt;Input defaultValue={1} /&gt;</code> 的最初调用方式:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组件提供方</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Input</span>(<span class="params">&#123; defaultValue &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [value, setValue] = React.useState(defaultValue)</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">&#123;value&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;e</span> =&gt;</span> setValue(e.target.value)&#125; /&gt;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用方</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Demo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Input</span> <span class="attr">defaultValue</span>=<span class="string">&#123;1&#125;</span> /&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尽管此时 Input 组件本身是一个受控组件, 但与之相对的调用方失去了更改 Input 组件值的<code>控制权</code>, 所以对调用方而言, Input 组件是一个非受控组件。值得一提的是, <code>以非受控组件的使用方式去调用受控组件</code>是一种反模式, 在下文中会分析其中的弊端。</p><p>如何做到不管对于组件提供方还是调用方 Input 组件都为受控组件呢? 提供方让出控制权即可, 调整代码如下<a href="https://codesandbox.io/s/clever-montalcini-kysbg" target="_blank" rel="noopener">codesandbox</a>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组件提供方</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Input</span>(<span class="params">&#123; value, onChange &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">&#123;value&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;onChange&#125;</span> /&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用方</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Demo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [value, setValue] = React.useState(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Input</span> <span class="attr">value</span>=<span class="string">&#123;value&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;e</span> =&gt;</span> setValue(e.target.value)&#125; /&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过上述代码的推演后, 概括如下: 受控以及非受控组件的边界划分取决于<code>当前组件对于子组件值的变更是否拥有控制权</code>。如若有则该子组件是当前组件的受控组件; 如若没有则该子组件是当前组件的非受控组件。</p><h3 id="职能范围"><a href="#职能范围" class="headerlink" title="职能范围"></a>职能范围</h3><p>基于调用方对于受控组件拥有控制权这一认知, 因此受控组件相较非受控组件能赋予调用方更多的定制化职能。这一思路与软件开发中的<a href="https://baike.baidu.com/item/%E5%BC%80%E6%94%BE%E5%B0%81%E9%97%AD%E5%8E%9F%E5%88%99" target="_blank" rel="noopener">开放/封闭原则</a>有异曲同工之妙, 同时让笔者受益匪浅的 <a href="https://kentcdodds.com/blog/inversion-of-control" target="_blank" rel="noopener">Inversion of Control</a> 也是类似的思想。</p><p>借助受控组件的赋能, 以 Input 组件为例, 比如调用方可以更为自由地对值进行校验限制, 又比如在值发生变更时执行一些额外逻辑。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组件提供方</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Input</span>(<span class="params">&#123; value, onChange &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">&#123;value&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;onChange&#125;</span> /&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用方</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Demo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [value, setValue] = React.useState(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Input</span> <span class="attr">value</span>=<span class="string">&#123;value&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;e</span> =&gt;</span></span></span><br><span class="line"><span class="xml">    // 只支持数值的变更</span></span><br><span class="line"><span class="xml">    if (/\D/.test(e.target.value)) return</span></span><br><span class="line"><span class="xml">    setValue(e.target.value)&#125;</span></span><br><span class="line"><span class="xml">  /&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此综合基础组件<code>扩展性</code>与<code>通用性</code>的考虑, 受控组件的职能相较非受控组件更加宽泛, 建议<code>优先使用受控组件</code>来构建基础组件。</p><h3 id="反模式-——-以非受控组件的使用方式调用受控组件"><a href="#反模式-——-以非受控组件的使用方式调用受控组件" class="headerlink" title="反模式 —— 以非受控组件的使用方式调用受控组件"></a>反模式 —— 以非受控组件的使用方式调用受控组件</h3><p>首先何谓反模式? 笔者将其总结为<code>增大隐性 bug 出现概率的模式</code>, 该模式是<code>最佳实践的对立经验</code>。如若使用了反模式就不得不花更多的精力去避免潜在 bug。官网对反模式也有很好的<a href="https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#common-bugs-when-using-derived-state" target="_blank" rel="noopener">概括总结</a>。</p><p>缘何上文提到以非受控组件的使用方式去调用受控组件是一种反模式? 观察 Input 组件的第一行代码, 其将 defaultValue 赋值给 value, 这种<code>将 props 赋值给 state</code> 的赋值行为在一定程度上会增加某些隐性 bug 的出现概率。</p><p>比如在切换导航栏的场景中, 恰巧两个导航中传进组件的 defaultValue 是相同的值, 在导航切换的过程中便会将导航一中的 Input 的状态值带到导航二中, 这显然会让使用方感到困惑。<a href="https://codesandbox.io/s/controllerinput-bobkp" target="_blank" rel="noopener">codesandbox</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组件提供方</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Input</span>(<span class="params">&#123; defaultValue &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 反模式</span></span><br><span class="line">  <span class="keyword">const</span> [value, setValue] = React.useState(defaultValue);</span><br><span class="line">  React.useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setValue(defaultValue);</span><br><span class="line">  &#125;, [defaultValue]);</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">&#123;value&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;e</span> =&gt;</span> setValue(e.target.value)&#125; /&gt;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用方</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Demo</span>(<span class="params">&#123; defaultValue &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Input</span> <span class="attr">defaultValue</span>=<span class="string">&#123;defaultValue&#125;</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [tab, setTab] = React.useState(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &#123;tab === <span class="number">1</span> ? <span class="xml"><span class="tag">&lt;<span class="name">Demo</span> <span class="attr">defaultValue</span>=<span class="string">&#123;1&#125;</span> /&gt;</span></span> : <span class="xml"><span class="tag">&lt;<span class="name">Demo</span> <span class="attr">defaultValue</span>=<span class="string">&#123;1&#125;</span> /&gt;</span></span>&#125;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; (tab === <span class="number">1</span> ? setTab(<span class="number">2</span>) : setTab(<span class="number">1</span>))&#125;&gt;</span><br><span class="line">        切换 Tab</span><br><span class="line">      &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何避免使用该反模式同时有效解决问题呢? 官方提供了两种较为优质的解法, 笔者将其留给大家思考。</p><ol><li>方法一: <a href="https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#recommendation-fully-controlled-component" target="_blank" rel="noopener">使用完全受控组件</a>(更为推荐)</li><li>方法二: <a href="https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#recommendation-fully-uncontrolled-component-with-a-key" target="_blank" rel="noopener">使用完全非受控组件 + key</a></li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun May 10 2020 18:57:15 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;&lt;img src=&quot;http://with.muyunyun.cn/21ec115261725fc7a37543143c1e89ed.jpg-400&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="React" scheme="http://muyunyun.cn/categories/React/"/>
    
    
      <category term="React" scheme="http://muyunyun.cn/tags/React/"/>
    
      <category term="components" scheme="http://muyunyun.cn/tags/components/"/>
    
  </entry>
  
  <entry>
    <title>React 现代化测试</title>
    <link href="http://muyunyun.cn/posts/76ba81e7/"/>
    <id>http://muyunyun.cn/posts/76ba81e7/</id>
    <published>2019-08-25T01:26:59.000Z</published>
    <updated>2019-08-25T01:51:28.601Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 18:57:14 GMT+0800 (China Standard Time) --><p><img src="http://with.muyunyun.cn/0bfbc9fe9777a4878ca19a1f80393bdf.jpg-muyy" alt=""></p><a id="more"></a><h3 id="测试的动机"><a href="#测试的动机" class="headerlink" title="测试的动机"></a>测试的动机</h3><p>测试用例的书写是一个风险驱动的行为, 每当收到 Bug 报告时, 先写一个单元测试来暴露这个 Bug, 在日后的代码提交中, 若该测试用例是通过的, 开发者就能更为自信地确保程序不会再次出现此 bug。</p><blockquote><p>测试的动机是有效地提高开发者的自信心。</p></blockquote><h3 id="前端现代化测试模型"><a href="#前端现代化测试模型" class="headerlink" title="前端现代化测试模型"></a>前端现代化测试模型</h3><p>前端测试中有两种模型, <code>金字塔模型</code>与<code>奖杯模型</code>。</p><p>金字塔模型摘自 <a href="https://martinfowler.com/bliki/TestPyramid.html" target="_blank" rel="noopener">Martin Fowler’s blog</a>, 模型示意图如下:</p><p><img src="http://with.muyunyun.cn/d97821c98ca86b161ac650198e6b44fd.jpg-300" alt=""></p><p>金字塔模型自下而上分为单元测试、集成测试、UI 测试, 之所以是金字塔结构是因为单元测试的成本最低, 与之相对, UI 测试的成本最高。所以单元测试写的数量最多, UI 测试写的数量最少。同时需注意的是越是上层的测试, 其通过率给开发者带来的信心是越大的。</p><p>奖杯模型摘自 Kent C. Dots 提出的 <a href="https://twitter.com/kentcdodds/status/960723172591992832?ref_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E960723172591992832&ref_url=https%3A%2F%2Fkentcdodds.com%2Fblog%2Fwrite-tests" target="_blank" rel="noopener">The Testing Trophy</a>, 该模型是笔者比较认可的前端现代化测试模型, 模型示意图如下:</p><p><img src="http://with.muyunyun.cn/0453d50194dfa1cbf7a4aeb70252c438.jpg-300" alt=""></p><p>奖杯模型中自下而上分为静态测试、单元测试、集成测试、e2e 测试, 它们的职责大致如下:</p><ul><li><code>静态测试</code>: 在编写代码逻辑阶段时进行报错提示。(代表库: eslint、flow、TypeScript)</li><li><code>单元测试</code>: 在奖杯模型中, 单元测试的职责是对一些边界情况或者特定的算法进行测试。(代表库: <a href="https://github.com/facebook/jest" target="_blank" rel="noopener">jest</a>、<a href="https://github.com/mochajs/mocha" target="_blank" rel="noopener">mocha</a>)</li><li><code>集成测试</code>: 模拟用户的行为进行测试, 对网络请求、获取数据库的数据等依赖第三方环境的行为进行 mock。(代表库: <a href="https://github.com/facebook/jest" target="_blank" rel="noopener">jest</a>、<a href="https://github.com/testing-library/react-testing-library" target="_blank" rel="noopener">react-testing-library</a>)</li><li><code>e2e 测试</code>: 模拟用户在真实环境上操作行为(包括网络请求、获取数据库数据等)的测试。(代表库: <a href="https://github.com/cypress-io/cypress" target="_blank" rel="noopener">cypress</a>)</li></ul><p>越是上层的测试给开发者带来的自信是越大的, 与此同时, 越是下层的测试测试的效率是越高的。奖杯模型综合考虑了这两点因素, 可以看到其在集成测试中的占比是最高的。</p><h3 id="基于用户行为去测试"><a href="#基于用户行为去测试" class="headerlink" title="基于用户行为去测试"></a>基于用户行为去测试</h3><p>书写测试用例是为了提高开发者对程序的自信心的, 但是很多时候书写测试用例给开发者带来了觉得在做无用功的沮丧。导致沮丧的感觉出现往往是因为开发者对组件的具体实现细节进行了测试, 如果换个角度站在用户的行为上进行测试则能极大提高测试效率。</p><p>测试组件的具体细节会带来的两个问题:</p><ol><li>测试用例对代码<code>错误否定</code>;</li><li>测试用例对代码<code>错误肯定</code>;</li></ol><p>以<code>轮播图组件</code>为例, 依次来看上述问题。轮播图组件伪代码如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Carousel</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    index: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 跳转到指定的页数 */</span></span><br><span class="line">  jump = <span class="function">(<span class="params">to: number</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      index: to</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; index &#125; = <span class="keyword">this</span>.state</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Swipe</span> <span class="attr">currentPage</span>=<span class="string">&#123;index&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> this.jump(index + 1)&#125;&gt;下一页<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>`当前位于第$&#123;index&#125;页`<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如下是基于 <code>enzyme</code> 的 api 写的测试用例:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mount &#125; <span class="keyword">from</span> <span class="string">'enzyme'</span></span><br><span class="line"></span><br><span class="line">describe(<span class="string">'Carousel Test'</span>, () =&gt; &#123;</span><br><span class="line">  it(<span class="string">'test jump'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> wrapper = mount(<span class="xml"><span class="tag">&lt;<span class="name">Carousel</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>第一页<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>第二页<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>第三页<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">Carousel</span>&gt;</span></span>)</span><br><span class="line"></span><br><span class="line">    expect(wrapper.state(<span class="string">'index'</span>)).toBe(<span class="number">0</span>)</span><br><span class="line">    wrapper.instance().jump(<span class="number">2</span>)</span><br><span class="line">    expect((wrapper.state(<span class="string">'index'</span>)).toBe(<span class="number">2</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>恭喜, 测试通过✅。某一天开发者觉得 <code>index</code> 的命名不妥, 对其重构将 <code>index</code> 更名为 <code>currentPage</code>, 此时代码如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Carousel</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    currentPage: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 跳转到指定的页数 */</span></span><br><span class="line">  jump = <span class="function">(<span class="params">to: number</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      currentPage: to</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; currentPage &#125; = <span class="keyword">this</span>.state</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Swipe</span> <span class="attr">currentPage</span>=<span class="string">&#123;currentPage&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> this.jump(currentPage + 1)&#125;&gt;下一页<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>`当前位于第$&#123;currentPage&#125;页`<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次跑测试用例, 此时在 <code>expect(wrapper.state(&#39;index&#39;)).toBe(0)</code> 的地方抛出了错误❌, 这就是所谓的测试用例对代码进行了<code>错误否定</code>。因为这段代码对于使用方来说是不存在问题的, 但是测试用例却抛出错误, 此时开发者不得不做’无用功’来调整测试用例适配新代码。调整后的测试用例如下:</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">describe('Carousel Test', () =&gt; &#123;</span><br><span class="line">  it('test jump', () =&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="deletion">-   expect(wrapper.state('index')).toBe(0)</span></span><br><span class="line"><span class="addition">+   expect(wrapper.state('currentPage')).toBe(0)</span></span><br><span class="line">    wrapper.instance().jump(2)</span><br><span class="line"><span class="deletion">-   expect((wrapper.state('index')).toBe(2)</span></span><br><span class="line"><span class="addition">+   expect((wrapper.state('currentPage')).toBe(2)</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>然后在某一天粗心的小明同学对代码做了以下改动:</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Carousel extends React.Component &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    currentPage: 0</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /* 跳转到指定的页数 */</span><br><span class="line">  jump = (to: number) =&gt; &#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      currentPage: to</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    const &#123; currentPage &#125; = this.state</span><br><span class="line">    return &lt;&gt;</span><br><span class="line">      &lt;Swipe currentPage=&#123;currentPage&#125; /&gt;</span><br><span class="line"><span class="deletion">-     &lt;button onClick=&#123;() =&gt; this.jump(currentPage + 1)&#125;&gt;下一页&lt;/button&gt;</span></span><br><span class="line"><span class="addition">+     &lt;button onClick=&#123;this.jump(currentPage + 1)&#125;&gt;下一页&lt;/button&gt;</span></span><br><span class="line">      &lt;span&gt;`当前位于第$&#123;index&#125;页`&lt;/span&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小明同学跑了上述单测, 测试通过✅, 于是开心地提交了代码。结果上线后线上出现了问题! 这就是所谓测试用例对代码进行了<code>错误肯定</code>。因为测试用例测试了组件内部细节(此处为 <code>jump</code> 函数), 让小明误以为已经覆盖了全部场景。</p><p>测试用例<code>错误否定</code>以及<code>错误肯定</code>都给开发者带来了挫败感与困扰, 究其原因是测试了组件内部的具体细节所至。而一个稳定可靠的测试用例应该脱离组件内部的实现细节, 越接近用户行为的测试用例能给开发者带来越充足的自信。相较于 enzyme, <a href="https://github.com/testing-library/react-testing-library" target="_blank" rel="noopener">react-testing-library</a> 所提供的 api 更加贴近用户的使用行为, 使用其对上述测试用例进行重构:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; render, fireEvent &#125; <span class="keyword">from</span> <span class="string">'@testing-library/react'</span></span><br><span class="line"></span><br><span class="line">describe(<span class="string">'Carousel Test'</span>, () =&gt; &#123;</span><br><span class="line">  it(<span class="string">'test jump'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; getByText &#125; = render(<span class="xml"><span class="tag">&lt;<span class="name">Carousel</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>第一页<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>第二页<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>第三页<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">Carousel</span>&gt;</span></span>)</span><br><span class="line"></span><br><span class="line">    expect(getByText(<span class="regexp">/当前位于第一页/</span>)).toBeInTheDocument()</span><br><span class="line">    fireEvent.click(getByText(<span class="regexp">/下一页/</span>))</span><br><span class="line">    expect(getByText(<span class="regexp">/当前位于第一页/</span>)).not.toBeInTheDocument()</span><br><span class="line">    expect(getByText(<span class="regexp">/当前位于第二页/</span>)).toBeInTheDocument()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>关于 <code>react-testing-Library</code> 的用法总结将在下一章节 <a href="https://github.com/MuYunyun/blog/blob/master/React/测试/Jest与ReactTestingLibrary.md" target="_blank" rel="noopener">Jest 与 react-testing-Library</a> 具体介绍。如果对 React 技术栈感兴趣, 欢迎关注<a href="https://github.com/MuYunyun/blog" target="_blank" rel="noopener">个人博客</a>。</p><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li><a href="https://kentcdodds.com/blog/write-tests" target="_blank" rel="noopener">write-tests</a></li><li><a href="https://reactjs.org/docs/testing-recipes.html" target="_blank" rel="noopener">Testing</a></li><li><a href="https://kentcdodds.com/blog/testing-implementation-details" target="_blank" rel="noopener">Testing Implementation Details</a></li><li><a href="https://kentcdodds.com/blog/why-i-never-use-shallow-rendering" target="_blank" rel="noopener">why-i-never-use-shallow-rendering</a></li><li><a href="https://blog.sapegin.me/all/react-testing-1-best-practices/" target="_blank" rel="noopener">react-testing-1-best-practices</a></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun May 10 2020 18:57:14 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;&lt;img src=&quot;http://with.muyunyun.cn/0bfbc9fe9777a4878ca19a1f80393bdf.jpg-muyy&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="React" scheme="http://muyunyun.cn/categories/React/"/>
    
      <category term="测试" scheme="http://muyunyun.cn/categories/React/%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="React" scheme="http://muyunyun.cn/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>React Hooks 深入系列 —— 设计模式</title>
    <link href="http://muyunyun.cn/posts/32fb0f08/"/>
    <id>http://muyunyun.cn/posts/32fb0f08/</id>
    <published>2019-07-31T20:46:20.000Z</published>
    <updated>2019-08-25T01:27:45.979Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 18:57:15 GMT+0800 (China Standard Time) --><p><img src="http://with.muyunyun.cn/34a60f7edb08afaf6d721708ab21b4d7.jpg-muyy" alt=""></p><p>本文是 <a href="https://github.com/MuYunyun/blog/blob/master/React/React_Hooks深入系列.md" target="_blank" rel="noopener">React Hooks 深入系列</a>的后续。此篇详细介绍了 Hooks 相对 class 的优势所在, 并介绍了相关 api 的设计思想, 同时对 Hooks 如何对齐 class 的生命周期钩子作了阐述。</p><a id="more"></a><h3 id="React-Logo-与-Hooks"><a href="#React-Logo-与-Hooks" class="headerlink" title="React Logo 与 Hooks"></a>React Logo 与 Hooks</h3><p><img src="http://with.muyunyun.cn/ddbdcec2fc39ba350fc74647f4fad6f5.jpg-300" alt=""></p><p>React 的 logo 是一个原子图案, 原子组成了物质的表现。类似的, React 就像原子般构成了页面的表现; 而 Hooks 就如夸克, 其更接近 React 本质的样子, 但是直到 4 年后的今天才被真正设计出来。 —— Dan in React Conf(2018)</p><h3 id="why-Hooks"><a href="#why-Hooks" class="headerlink" title="why Hooks?"></a>why Hooks?</h3><p>一: <code>多个组件间逻辑复用</code>: 在 Class 中使用 React 不能将带有 state 的逻辑给单独抽离成 function, 其只能通过嵌套组件的方式来解决多个组件间逻辑复用的问题, 基于嵌套组件的思想存在 <a href="https://github.com/MuYunyun/blog/blob/master/React/从0到1实现React/8.HOC探索.md" target="_blank" rel="noopener">HOC</a> 与 <code>render props</code> 两种设计模式。但是这两种设计模式是否存在缺陷呢?</p><ul><li>嵌套地狱, 当嵌套层级过多后, 数据源的追溯会变得十分困难, 导致定位 bug 不容易; (hoc、render props)</li><li>性能, 需要额外的组件实例存在额外的开销; (hoc、render props)</li><li>命名重复性, 在一个组件中同时使用多个 hoc, 不排除这些 hoc 里的方法存在命名冲突的问题; (hoc)</li></ul><p>二: <code>单个组件中的逻辑复用</code>: Class 中的生命周期 <code>componentDidMount</code>、<code>componentDidUpdate</code> 甚至 <code>componentWillUnMount</code> 中的大多数逻辑基本是类似的, 必须拆散在不同生命周期中维护相同的逻辑对使用者是不友好的, 这样也造成了组件的代码量增加。</p><p>三: Class 的其它一些问题: 在 React 使用 Class 需要书写大量样板, 用户通常会对 Class 中 Constructor 的 bind 以及 this 的使用感到困惑; 当结合 class 与 TypeScript 一起使用时, 需要对 defaultValue 做额外声明处理; 此外 React Team 表示 Class 在机器编译优化方面也不是很理想。</p><h3 id="useState-返回的值为什么是数组而非对象"><a href="#useState-返回的值为什么是数组而非对象" class="headerlink" title="useState 返回的值为什么是数组而非对象?"></a>useState 返回的值为什么是数组而非对象?</h3><p>原因是数组的解构比对象更加方便, 可以观察以下两种数据结构解构的差异。</p><p>返回数组时, 可以直接解构成任意名字。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[name, setName] = useState(<span class="string">'路飞'</span>)</span><br><span class="line">[age, setAge] = useState(<span class="number">12</span>)</span><br></pre></td></tr></table></figure><p>返回对象时, 却需要多一层的命名。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">value</span>: name, <span class="attr">setValue</span>: setName&#125; = useState(<span class="string">'路飞'</span>)</span><br><span class="line">&#123;<span class="attr">value</span>: name, <span class="attr">setValue</span>: setName&#125; = useState(<span class="number">12</span>)</span><br></pre></td></tr></table></figure><h3 id="Hooks-传递的设计"><a href="#Hooks-传递的设计" class="headerlink" title="Hooks 传递的设计"></a>Hooks 传递的设计</h3><p>Hooks 是否可以设计成在组件中通过函数传参来使用? 比如进行如下调用?</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> SomeContext = <span class="built_in">require</span>(<span class="string">'./SomeContext)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">function Example(&#123; someProp &#125;, hooks) &#123;</span></span><br><span class="line"><span class="string">  const contextValue = hooks.useContext(SomeContext)</span></span><br><span class="line"><span class="string">  return &lt;div&gt;&#123;someProp&#125;&#123;contextValue&#125;&lt;/div&gt;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>使用传递的劣势是会出现冗余的传递。(可以联想 context 解决了什么)</p><h3 id="Hooks-与-Class-中调用-setState-有不同的表现差异么"><a href="#Hooks-与-Class-中调用-setState-有不同的表现差异么" class="headerlink" title="Hooks 与 Class 中调用 setState 有不同的表现差异么?"></a>Hooks 与 Class 中调用 setState 有不同的表现差异么?</h3><p>Hooks 中的 setState 与 Class 中最大区别在于 Hooks 不会对多次 setState 进行合并操作。如果要执行合并操作, 可执行如下操作:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setState(<span class="function"><span class="params">prevState</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; ...prevState, ...updateValues &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>此外可以对 class 与 Hooks 之间 <code>setState</code> 是异步还是同步的表现进行对比, 可以先对以下 4 种情形 render 输出的个数进行观察分析:</p><h3 id="是否能使用-React-Hooks-替代-Redux"><a href="#是否能使用-React-Hooks-替代-Redux" class="headerlink" title="是否能使用 React Hooks 替代 Redux"></a>是否能使用 React Hooks 替代 Redux</h3><p>在 React 16.8 版本之后, 针对<code>不是特别复杂</code>的业务场景, 可以使用 React 提供的 <code>useContext</code>、<code>useReducer</code> 实现自定义简化版的 redux, 可见 <a href="https://github.com/MuYunyun/todoList" target="_blank" rel="noopener">todoList</a> 中的运用。核心代码如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; createContext, useContext, useReducer &#125; <span class="keyword">from</span> <span class="string">"react"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 StoreContext</span></span><br><span class="line"><span class="keyword">const</span> StoreContext = createContext()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建 Provider 容器层</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> StoreProvider = <span class="function">(<span class="params">&#123;reducer, initialState, children&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;StoreContext.Provider value=&#123;useReducer(reducer, initialState)&#125;&gt;</span><br><span class="line">      &#123;children&#125;</span><br><span class="line">    &lt;<span class="regexp">/StoreContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 在子组件中调用 useStoreContext, 从而取得 Provider 中的 value</span></span><br><span class="line"><span class="regexp">export const useStoreContext = () =&gt; useContext(StoreContext)</span></span><br></pre></td></tr></table></figure><p>但是针对特别复杂的场景目前不建议使用此模式, 因为 context 的机制会有性能问题。具体原因可见 <a href="https://github.com/reduxjs/react-redux/issues/1177" target="_blank" rel="noopener">react-redux v7 回退到订阅的原因</a></p><h3 id="Hooks-中如何获取先前的-props-以及-state"><a href="#Hooks-中如何获取先前的-props-以及-state" class="headerlink" title="Hooks 中如何获取先前的 props 以及 state"></a>Hooks 中如何获取先前的 props 以及 state</h3><p>React 官方在未来很可能会提供一个 <code>usePrevious</code> 的 hooks 来获取之前的 props 以及 state。</p><p><code>usePrevious</code> 的核心思想是用 ref 来存储先前的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">usePrevous</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ref = useRef()</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    ref.current = value</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> ref.current</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Hooks-中如何调用实例上的方法"><a href="#Hooks-中如何调用实例上的方法" class="headerlink" title="Hooks 中如何调用实例上的方法"></a>Hooks 中如何调用实例上的方法</h3><p>在 Hooks 中使用 useRef() 等价于在 Class 中使用 this.something。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* in a function */</span></span><br><span class="line"><span class="keyword">const</span> X = useRef()</span><br><span class="line">X.current <span class="comment">// can read or write</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* in a Class */</span></span><br><span class="line"><span class="keyword">this</span>.X    <span class="comment">// can read or write</span></span><br></pre></td></tr></table></figure><blockquote><p><a href="https://reactjs.org/docs/hooks-faq.html#is-there-something-like-instance-variables" target="_blank" rel="noopener">Is there something like instance variables</a></p></blockquote><h3 id="Hooks-中-getDerivedStateFromProps-的替代方案"><a href="#Hooks-中-getDerivedStateFromProps-的替代方案" class="headerlink" title="Hooks 中 getDerivedStateFromProps 的替代方案"></a>Hooks 中 getDerivedStateFromProps 的替代方案</h3><p>在 <a href="https://github.com/MuYunyun/blog/blob/master/React/React暗器百解.md" target="_blank" rel="noopener">React 暗器百解</a> 中提到了 <code>getDerivedStateFromProps</code> 是一种反模式, 但是极少数情况还是用得到该钩子, Hooks 没有该 api, 那其如何达到 getDerivedStateFromProps 的效果呢?</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ScrollView</span>(<span class="params">&#123;row&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [isScrollingDown, setISScrollingDown] = setState(<span class="literal">false</span>)</span><br><span class="line">  <span class="keyword">const</span> [prevRow, setPrevRow] = setState(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 核心是创建一个 prevRow state 与父组件传进来的 row 进行比较</span></span><br><span class="line">  <span class="keyword">if</span> (row !== prevRow) &#123;</span><br><span class="line">    setISScrollingDown(prevRow !== <span class="literal">null</span> &amp;&amp; row &gt; prevRow)</span><br><span class="line">    setPrevRow(row)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="string">`Scrolling down <span class="subst">$&#123;isScrollingDown&#125;</span>`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Hooks-中-forceUpdate-的替代方案"><a href="#Hooks-中-forceUpdate-的替代方案" class="headerlink" title="Hooks 中 forceUpdate 的替代方案"></a>Hooks 中 forceUpdate 的替代方案</h3><p>可以使用 <code>useReducer</code> 来 hack <code>forceUpdate</code>, 但是尽量避免 forceUpdate 的使用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [ignored, forceUpdate] = useReduce(<span class="function"><span class="params">x</span> =&gt;</span> x + <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleClick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  forceUpdate()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Hooks-中-shouldComponentUpdate-的替代方案"><a href="#Hooks-中-shouldComponentUpdate-的替代方案" class="headerlink" title="Hooks 中 shouldComponentUpdate 的替代方案"></a>Hooks 中 shouldComponentUpdate 的替代方案</h3><p>在 Hooks 中可以使用 <code>useMemo</code> 来作为 <code>shouldComponentUpdate</code> 的替代方案, 但 <code>useMemo</code> 只对 props 进行浅比较。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">React.useMemo(<span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// your component</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="useMemo-与-useCallback-的区别"><a href="#useMemo-与-useCallback-的区别" class="headerlink" title="useMemo 与 useCallback 的区别"></a>useMemo 与 useCallback 的区别</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useMemo(<span class="function"><span class="params">()</span> =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">component</span> /&gt;</span></span>) 等价于 useCallback(<span class="xml"><span class="tag">&lt;<span class="name">component</span> /&gt;</span></span>)</span><br></pre></td></tr></table></figure><ul><li>useCallback: 一般用于缓存函数</li><li>useMemo: 一般用于缓存组件</li></ul><h4 id="依赖列表中移除函数是否是安全的"><a href="#依赖列表中移除函数是否是安全的" class="headerlink" title="依赖列表中移除函数是否是安全的?"></a>依赖列表中移除函数是否是安全的?</h4><p>通常来说依赖列表中移除函数是不安全的。观察如下 demo</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; useState, useEffect &#125; = React</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params">&#123; someProp &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(someProp) <span class="comment">// 这里只输出 1, 点击按钮的 2 并没有输出。</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  useEffect(</span><br><span class="line">    () =&gt; &#123;</span><br><span class="line">      doSomething()</span><br><span class="line">    &#125;,</span><br><span class="line">    [] <span class="comment">// 🔴 这是不安全的, 因为在 doSomething 函数中使用了 someProps 属性</span></span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>example<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [value, setValue] = useState(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;Example someProp=&#123;value&#125; /&gt;</span><br><span class="line">      &lt;Button onClick=&#123;() =&gt; setValue(<span class="number">2</span>)&#125;&gt;button&lt;<span class="regexp">/Button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在该 demo 中, 点击 button 按钮, 并没有打印出 2。解决上述问题有两种方法。</p><p>方法一: 将函数放入 <code>useEffect</code> 中, 同时将相关属性放入依赖项中。因为在依赖中改变的相关属性一目了然, 所以这也是首推的做法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params">&#123; someProp &#125;</span>) </span>&#123;</span><br><span class="line">  useEffect(</span><br><span class="line">    () =&gt; &#123;</span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(someProp)</span><br><span class="line">      &#125;</span><br><span class="line">      doSomething()</span><br><span class="line">    &#125;,</span><br><span class="line">    [someProps] <span class="comment">// 相关属性改变一目了然</span></span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>example<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二: 把函数加入依赖列表中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params">&#123; someProp &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(someProp)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  useEffect(</span><br><span class="line">    () =&gt; &#123;</span><br><span class="line">      doSomething()</span><br><span class="line">    &#125;,</span><br><span class="line">    [doSomething]</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>example<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方案二基本上不会单独使用, 它一般结合 <code>useCallback</code> 一起使用来处理某些函数计算量较大的函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params">&#123; someProp &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> doSomething = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(someProp)</span><br><span class="line">  &#125;, [someProp])</span><br><span class="line"></span><br><span class="line">  useEffect(</span><br><span class="line">    doSomething(),</span><br><span class="line">    [doSomething]</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>example<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="如何避免重复创建昂贵的对象"><a href="#如何避免重复创建昂贵的对象" class="headerlink" title="如何避免重复创建昂贵的对象"></a>如何避免重复创建昂贵的对象</h4><ul><li>方法一: 使用 <code>useState</code> 的懒初始化, 用法如下</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [value, setValue] = useState(<span class="function"><span class="params">()</span> =&gt;</span> createExpensiveObj)</span><br></pre></td></tr></table></figure><blockquote><p>见 <a href="https://reactjs.org/docs/hooks-reference.html#lazy-initial-state" target="_blank" rel="noopener">lazy-initial-state</a>;</p></blockquote><ul><li>方法二: 使用自定义 useRef 函数</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Image</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ref = useRef(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getExpensiveObj</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ref.current === <span class="literal">null</span>) &#123;</span><br><span class="line">      ref.current = ExpensiveObj</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ref.current</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// if need ExpensiveObj, call getExpensiveObj()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h3><ul><li><a href="https://github.com/reactjs/rfcs/pull/68#issuecomment-439314884" target="_blank" rel="noopener">Hooks RFCS</a></li><li><a href="https://reactjs.org/docs/hooks-faq.html" target="_blank" rel="noopener">Hooks FAQ</a></li><li><a href="https://medium.com/@dan_abramov/making-sense-of-react-hooks-fdbde8803889" target="_blank" rel="noopener">Making Sense of React Hooks</a></li><li><a href="https://zhuanlan.zhihu.com/p/68477600" target="_blank" rel="noopener">Vue Function-based API RFC</a></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun May 10 2020 18:57:15 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;&lt;img src=&quot;http://with.muyunyun.cn/34a60f7edb08afaf6d721708ab21b4d7.jpg-muyy&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;本文是 &lt;a href=&quot;https://github.com/MuYunyun/blog/blob/master/React/React_Hooks深入系列.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;React Hooks 深入系列&lt;/a&gt;的后续。此篇详细介绍了 Hooks 相对 class 的优势所在, 并介绍了相关 api 的设计思想, 同时对 Hooks 如何对齐 class 的生命周期钩子作了阐述。&lt;/p&gt;
    
    </summary>
    
    
      <category term="React" scheme="http://muyunyun.cn/categories/React/"/>
    
    
      <category term="React" scheme="http://muyunyun.cn/tags/React/"/>
    
      <category term="Hooks" scheme="http://muyunyun.cn/tags/Hooks/"/>
    
  </entry>
  
  <entry>
    <title>如何使页面交互更流畅</title>
    <link href="http://muyunyun.cn/posts/a1be1d41/"/>
    <id>http://muyunyun.cn/posts/a1be1d41/</id>
    <published>2019-05-26T01:48:24.000Z</published>
    <updated>2019-07-31T20:58:28.650Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 18:57:15 GMT+0800 (China Standard Time) --><p><img src="http://with.muyunyun.cn/7f0c7b0e28fbeccf363daf5ee47d7105.jpg-muyy" alt=""></p><p>本篇是对 FDCon2019 上《让你的网页更丝滑》课题的复盘文。该课题也是博主感兴趣的领域, 后续对该文的细节进行进一步补充。</p><a id="more"></a><h3 id="流畅性"><a href="#流畅性" class="headerlink" title="流畅性"></a>流畅性</h3><ul><li>被动交互: animation</li><li>主动交互: 鼠标、键盘</li></ul><h3 id="被动交互"><a href="#被动交互" class="headerlink" title="被动交互"></a>被动交互</h3><p><img src="http://with.muyunyun.cn/23b109b73c8296e2c0d9178d214f33f0.jpg-400" alt=""></p><p>当前市面上的设备频率在 60 HZ 以上。</p><h3 id="主动交互"><a href="#主动交互" class="headerlink" title="主动交互"></a>主动交互</h3><p>跑如下界面 <a href="https://code.h5jun.com/pojob" target="_blank" rel="noopener">https://code.h5jun.com/pojob</a></p><p>结合如下代码块, 可以看到 100ms 以下的点击是顺畅的, 而超过 100ms 的点击就会有卡顿现象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> observer = <span class="keyword">new</span> PerformanceObserver(<span class="function"><span class="keyword">function</span>(<span class="params">list</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> perfEntries = list.getEntries()</span><br><span class="line">  <span class="built_in">console</span>.log(perfEntries)</span><br><span class="line">&#125;);</span><br><span class="line">observer.observe(&#123;<span class="attr">entryTypes</span>: [<span class="string">"longtask"</span>]&#125;);</span><br></pre></td></tr></table></figure><h4 id="让用户感觉到流畅"><a href="#让用户感觉到流畅" class="headerlink" title="让用户感觉到流畅"></a>让用户感觉到流畅</h4><p>衡量一个网页/App 是否流畅有个比较好用的 <a href="https://developers.google.com/web/fundamentals/performance/rail" target="_blank" rel="noopener">Rail 模型</a>, 它大概有以下几个评判标准值。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Response —— <span class="number">100</span>ms</span><br><span class="line">Animation —— <span class="number">16.7</span>ms</span><br><span class="line">Idle —— <span class="number">50</span>ms</span><br><span class="line">Load —— <span class="number">1000</span>ms</span><br></pre></td></tr></table></figure><h3 id="像素管道"><a href="#像素管道" class="headerlink" title="像素管道"></a>像素管道</h3><p>像素管道一般由 5 个部分组成。JavaScript、样式、布局、绘制、合成。如下图所示:</p><p><img src="http://with.muyunyun.cn/a4498ef249fafc3d47f1443df4108256.jpg" alt=""></p><blockquote><p><a href="https://developers.google.com/web/fundamentals/performance/rendering/?hl=zh-cn" target="_blank" rel="noopener">渲染性能</a></p></blockquote><h3 id="保证主动交互让用户感觉流畅"><a href="#保证主动交互让用户感觉流畅" class="headerlink" title="保证主动交互让用户感觉流畅"></a>保证主动交互让用户感觉流畅</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> start = performance.now()</span><br><span class="line">      <span class="keyword">while</span> (performance.now() - start &lt; <span class="number">1000</span>) &#123; &#125;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'done!'</span>)</span><br><span class="line">    &#125;, <span class="number">5000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;input type=<span class="string">"text"</span> /&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://with.muyunyun.cn/574ac0a2b41a78fdb00f2db3d250de37.jpg-400" alt=""></p><p>一般超过 50 ms 认为是 <code>long task(长任务)</code>, <code>long task</code> 会阻塞 <code>main thread</code> 的运行, 如下是两种解决方案。</p><h4 id="Web-Worker"><a href="#Web-Worker" class="headerlink" title="Web Worker"></a>Web Worker</h4><p><code>app.js</code> 代码如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;useEffect&#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> WorkerCode <span class="keyword">from</span> <span class="string">'./worker'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> testWorker = <span class="keyword">new</span> Worker(WorkerCode)</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      testWorker.postMessage(&#123;&#125;)</span><br><span class="line">      testWorker.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">ev</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(ev.data)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">5000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;input type=<span class="string">"text"</span> /&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>worker.js</code> 代码如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> workerCode = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  self.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> start = performance.now()</span><br><span class="line">    <span class="keyword">while</span> (performance.now() - start &lt; <span class="number">1000</span>) &#123; &#125;</span><br><span class="line">    postMessage(<span class="string">'done!'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://with.muyunyun.cn/df7d2b274685c20638cdde68cb54927d.jpg" alt=""></p><p>此时在输入框输入时没有卡顿的感觉。</p><h4 id="Time-Slicing"><a href="#Time-Slicing" class="headerlink" title="Time Slicing"></a>Time Slicing</h4><p>下面是另外一种使页面流畅的方法 —— <code>Time Slicing</code>(时间分片)。</p><p>观察 Chrome 的 Performance, 火焰图如下,</p><p><img src="http://with.muyunyun.cn/8cbc0ea884095aa25a79bd9d474ff2e5.jpg" alt=""></p><p>从火焰图可以看出主线程被拆分为了多个时间分片, 所以不会造成卡顿。时间分片的代码片段如下所示:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeSlicing</span>(<span class="params">gen</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> gen === <span class="string">'function'</span>) gen = gen()</span><br><span class="line">  <span class="keyword">if</span> (!gen || <span class="keyword">typeof</span> gen.next !== <span class="string">'function'</span>) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  (<span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> res = gen.next() <span class="comment">// ①</span></span><br><span class="line">    <span class="keyword">if</span> (res.done) <span class="keyword">return</span> <span class="comment">// ⑤</span></span><br><span class="line">    setTimeout(next) <span class="comment">// ③</span></span><br><span class="line">  &#125;)()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用时间分片函数</span></span><br><span class="line">timeSlicing(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> start = performance.now()</span><br><span class="line">  <span class="keyword">while</span> (performance.now() - start &lt; <span class="number">1000</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'执行逻辑'</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="comment">// ②</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'done'</span>) <span class="comment">// ④</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>该函数虽然代码量不长, 但却不易理解。前置知识 <a href="https://github.com/MuYunyun/blog/blob/master/BasicSkill/readES6/Generator.md" target="_blank" rel="noopener">Generator</a></p><p>下面对该函数进行分析:</p><ol><li>往时间分片函数 <code>timeSlicing</code> 中传入 <code>generator</code> 函数;</li><li>函数的执行顺序 —— ①、②、③、① (此时有个竞赛的关系, 如果 <code>performance.now() - start &lt; 1000</code> 则继续 ②、③, 如果 <code>performance.now() - start &gt;= 1000</code> 则跳出循环执行 ④、⑤);</li></ol><h4 id="conclusion"><a href="#conclusion" class="headerlink" title="conclusion"></a>conclusion</h4><p>针对 <code>long task</code> 会阻塞 <code>main thread</code> 的运行的情形, 给出两种解决方案:</p><ul><li><code>Web Worker</code>: 使用 <code>Web Worker</code> 提供的多线程环境来处理 <code>long task</code>;</li><li><code>Time Slicing</code>: 将主线程上的 <code>long task</code> 进行时间分片;</li></ul><h3 id="保证被动交互让用户感觉流畅"><a href="#保证被动交互让用户感觉流畅" class="headerlink" title="保证被动交互让用户感觉流畅"></a>保证被动交互让用户感觉流畅</h3><p>保证 <code>16.7ms</code> 有新的一帧传输到界面上。除去用户的逻辑代码, 一帧内留给浏览器整合的时间大概只有 <code>6ms</code> 左右, 回到像素管道上来, 我们可以从这几方面进行优化:</p><h4 id="避免-CSS-选择器嵌套过深"><a href="#避免-CSS-选择器嵌套过深" class="headerlink" title="避免 CSS 选择器嵌套过深"></a>避免 CSS 选择器嵌套过深</h4><p>Style 这部分的优化在 css 样式选择器的使用, css 选择器使用的层级越多, 耗费的时间越多。以下是测试 css 选择器不同层级筛选相同元素的一次测试结果。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-class">.box</span><span class="selector-pseudo">:not(</span><span class="selector-pseudo">:empty)</span><span class="selector-pseudo">:last-of-type</span> <span class="selector-tag">span</span>         2<span class="selector-class">.25ms</span></span><br><span class="line"><span class="selector-tag">index</span><span class="selector-class">.html</span><span class="selector-pseudo">:85</span> <span class="selector-class">.box--last</span> <span class="selector-tag">span</span>                 0<span class="selector-class">.28ms</span></span><br><span class="line"><span class="selector-tag">index</span><span class="selector-class">.html</span><span class="selector-pseudo">:85</span> <span class="selector-class">.box</span><span class="selector-pseudo">:nth-last-child(-n+1)</span> <span class="selector-tag">span</span>  2<span class="selector-class">.51ms</span></span><br></pre></td></tr></table></figure><h4 id="避免布局重排"><a href="#避免布局重排" class="headerlink" title="避免布局重排"></a>避免布局重排</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先修改值</span></span><br><span class="line">el.style.witdh = <span class="string">'100px'</span></span><br><span class="line"><span class="comment">// 后取值</span></span><br><span class="line"><span class="keyword">const</span> width = el.offsetWidth</span><br></pre></td></tr></table></figure><p>这段代码有什么问题呢?</p><p><img src="http://with.muyunyun.cn/9f446b40c45fa93b26bf91927e84c676.jpg" alt=""></p><p>可以看到它会造成布局重排。</p><p><img src="http://with.muyunyun.cn/02a6a152cb141781df115840495ed356.jpg" alt=""></p><p>应对的策略是调整它们的执行顺序,</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先取值</span></span><br><span class="line"><span class="keyword">const</span> width = el.offsetWidth</span><br><span class="line"><span class="comment">// 后修改值</span></span><br><span class="line">el.style.witdh = <span class="string">'100px'</span></span><br></pre></td></tr></table></figure><p><img src="http://with.muyunyun.cn/b84405a014e98f0903703f7d45b9497d.jpg" alt=""></p><p>可以看到经过调换顺序后, 后执行的 el.style.width 会新开一个像素管道, 而不会在原先的像素管道进行重排。</p><p>此外不要在循环中执行如下的操作,</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">const</span> newWidth = container.offsetWidth; <span class="comment">// ①</span></span><br><span class="line">  boxes[i].style.width = newWidth + <span class="string">'px'</span>; <span class="comment">// ②</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以在火焰图中看到它发生了重绘的警告,</p><p><img src="http://with.muyunyun.cn/4ee7202c8d28e685a9cd347061eb39e9.jpg" alt=""></p><p>执行顺序是 ①②①②①②①…, 假若我们在第一个 ① 后面插入一条竖线后 ①|②①②①②①, 其就变成先修改值后取值的情景, 所以也就发生了重绘!</p><p>正确的使用姿势应该如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> newWidth = container.offsetWidth;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">  boxes[i].style.width = newWidth + <span class="string">'px'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="避免重绘"><a href="#避免重绘" class="headerlink" title="避免重绘"></a>避免重绘</h4><p>创建 Layers(图层) 可以避免重绘,</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translateZ</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun May 10 2020 18:57:15 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;&lt;img src=&quot;http://with.muyunyun.cn/7f0c7b0e28fbeccf363daf5ee47d7105.jpg-muyy&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;本篇是对 FDCon2019 上《让你的网页更丝滑》课题的复盘文。该课题也是博主感兴趣的领域, 后续对该文的细节进行进一步补充。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://muyunyun.cn/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://muyunyun.cn/tags/JavaScript/"/>
    
      <category term="性能" scheme="http://muyunyun.cn/tags/%E6%80%A7%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>React Hooks 深入系列</title>
    <link href="http://muyunyun.cn/posts/290a4219/"/>
    <id>http://muyunyun.cn/posts/290a4219/</id>
    <published>2019-05-12T05:23:44.000Z</published>
    <updated>2019-07-31T20:48:37.306Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 18:57:15 GMT+0800 (China Standard Time) --><p><img src="http://with.muyunyun.cn/34a60f7edb08afaf6d721708ab21b4d7.jpg-muyy" alt=""></p><p>本文为对 hooks 碎片化的理解。同时欢迎关注基于 hooks 构建的 UI 组件库 —— <a href="https://github.com/ming-cult/snake-design" target="_blank" rel="noopener">snake-design</a>。</p><a id="more"></a><p>在 class 已经融入 React 生态的节点下, React 推出的 Hooks 具有如下优势:</p><ul><li>更简洁的书写;</li><li>相对类中的 <code>HOC</code> 与 <code>render Props</code>, Hooks 拥有更加自由地组合抽象的能力;</li></ul><h3 id="使用-Hooks-的注意项"><a href="#使用-Hooks-的注意项" class="headerlink" title="使用 Hooks 的注意项"></a>使用 Hooks 的注意项</h3><ul><li><p>在 <code>hooks</code> 中每一次 <code>render</code> 都有自己的 <code>state</code> 和 <code>props</code>, 这与 <code>class</code> 中存在差异, 见 <a href="https://overreacted.io/a-complete-guide-to-useeffect/#each-render-has-its-own-everything" target="_blank" rel="noopener">Hooks 每次渲染都是闭包</a></p><ul><li><code>class</code> 中可以用闭包模拟 <code>hooks</code> 的表现, <a href="https://codesandbox.io/s/w7vjo07055" target="_blank" rel="noopener">链接</a>, <code>hooks</code> 中可以使用 <code>ref</code> 模拟 <code>class</code> 的表现, <a href="https://codesandbox.io/s/rm7z22qnlp" target="_blank" rel="noopener">链接</a>;</li></ul></li><li><p>写出 useEffect 的所用到的依赖</p></li></ul><p>在以下 demo 中, <code>useEffect</code> 的第二个参数传入 <code>[]</code>, 希望的是 <code>useEffect</code> 里的函数只执行一次(类似在 <code>componentDidMount</code> 中执行一次, 但是注意这里仅仅是<code>类似</code>, 详细原因见上一条注意项), 页面上每隔 1s 递增 1。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Demo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> id = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      setCount(count + <span class="number">1</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      clearInterval(id);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这样达到我们预期的效果了么? <a href="https://codesandbox.io/s/n3o2m1wpj4" target="_blank" rel="noopener">demo</a>, 可以看到界面上只增加到 1 就停止了。原因就是传入的第二个参数 <code>[]</code> 搞的鬼, <code>[]</code> 表示没有外界状态对 <code>effect</code> 产生干扰。流程大致如下:</p><ol><li>第一次调用 <code>useEffect</code> 传入的 <code>count</code> 为 0, 于是 <code>setCount(0 + 1)</code>;</li><li>受 <code>useEffect</code> 第二个参数 <code>[]</code> 的影响，<code>count</code> 仍然为 0, 所以相当于还是 <code>setCount(0 + 1)</code>;</li></ol><p>那如何修正上述问题呢? 方法有两个(方法一为主, 方法二为辅):</p><ul><li>方法一: 将 <code>[]</code> 改为 <code>[count]</code></li><li>方法二: 将 <code>setCount(count + 1)</code> 改为 <code>setCount(count =&gt; count + 1)</code>。这种方法的思想是修正状态的值而不依赖外面传进的状态。</li></ul><p>不过遇到 <code>setCount(count =&gt; count + 1)</code> 的情况就可以考虑使用 <code>useReducer</code> 了。</p><h4 id="何时使用-useReducer"><a href="#何时使用-useReducer" class="headerlink" title="何时使用 useReducer"></a>何时使用 useReducer</h4><p>使用 <code>useState</code> 的地方都能用 <code>useReducer</code> 进行替代。相较 <code>useState</code>, <code>useReducer</code> 有如下优势:</p><ul><li><code>useReducer</code> 将 <code>how</code>(reducer) 和 <code>what</code>(dispatch(action)) 进行抽离; 使用 <code>reducer</code> 逻辑状态进行集中化维护;</li><li>相比 useState, useReducer 没有<a href="https://overreacted.io/a-complete-guide-to-useeffect/#each-render-has-its-own-everything" target="_blank" rel="noopener">闭包问题</a>;</li><li>当状态的一个 state 依赖状态中的另一个 state 时, 这种情况最好使用 useReducer; 可以参考 <a href="https://overreacted.io/a-complete-guide-to-useeffect/#decoupling-updates-from-actions" target="_blank" rel="noopener">decoupling-updates-from-actions</a> 中 Dan 列举的 demo。</li></ul><h4 id="处理-useEffect-中的公用函数"><a href="#处理-useEffect-中的公用函数" class="headerlink" title="处理 useEffect 中的公用函数"></a>处理 useEffect 中的公用函数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Demo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getFetchUrl</span>(<span class="params">query</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`http://demo<span class="subst">$&#123;query&#125;</span>`</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> url = getFetchUrl(<span class="string">'react'</span>)</span><br><span class="line">  &#125;, [getFetchUrl]);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> url = getFetchUrl(<span class="string">'redux'</span>)</span><br><span class="line">  &#125;, [getFetchUrl]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时 <code>useEffect</code> 中传入的第二个参数 <code>getFetchUrl</code> 相当于每次都是新的, 所以每次都会请求数据, 那除了 <code>[getFetchUrl]</code> 将改为 <code>[]</code> 这种不推荐的写法外，有两种解决方法:</p><p>*. 方法一: 提升 <code>getFetchUrl</code> 的作用域;<br>*. 方法二: 使用 <code>useCallback</code> 或者 <code>useMemo</code> 来包裹 getFetchUrl;</p><blockquote><p><code>React.memo</code> 修饰一个函数组件, <code>useMemo</code> 修饰一个函数。它们本质都是运用缓存。</p></blockquote><h3 id="React-Hooks-内部是怎么工作的"><a href="#React-Hooks-内部是怎么工作的" class="headerlink" title="React Hooks 内部是怎么工作的"></a>React Hooks 内部是怎么工作的</h3><p>为了理解 React Hooks 内部实现原理, 对 <code>useState</code>、<code>useEffect</code> 进行了简单的实现。</p><h4 id="useState-的简单实现"><a href="#useState-的简单实现" class="headerlink" title="useState 的简单实现"></a>useState 的简单实现</h4><p>使用闭包来实现 <code>useState</code> 的简单逻辑:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里使用闭包</span></span><br><span class="line"><span class="keyword">const</span> React = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> _val</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    useState(initialValue) &#123;</span><br><span class="line">      _val = _val || initialValue</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">setVal</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        _val = value</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> [_val, setVal]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>测试如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = React.useState(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    render: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(count),</span><br><span class="line">    click: <span class="function"><span class="params">()</span> =&gt;</span> setCount(count + <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Counter().render() <span class="comment">// 0</span></span><br><span class="line">Counter().click()  <span class="comment">// 模拟点击</span></span><br><span class="line">Counter().render() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h4 id="useEffect-的简单实现"><a href="#useEffect-的简单实现" class="headerlink" title="useEffect 的简单实现"></a>useEffect 的简单实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> React = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> _val, _deps</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    useState(initialValue) &#123;</span><br><span class="line">      _val = _val || initialValue</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">setVal</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        _val = value</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> [_val, setVal]</span><br><span class="line">    &#125;,</span><br><span class="line">    useEffect(callback, deps) &#123;</span><br><span class="line">      <span class="keyword">const</span> ifUpdate = !deps</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 判断 Deps 中的依赖是否改变</span></span><br><span class="line">      <span class="keyword">const</span> ifDepsChange = _deps ? !_deps.every(<span class="function">(<span class="params">r, index</span>) =&gt;</span> r === deps[index]) : <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (ifUpdate || ifDepsChange) &#123;</span><br><span class="line">        callback()</span><br><span class="line"></span><br><span class="line">        _deps = deps || []</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>测试代码如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123;useState, useEffect&#125; = React</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'useEffect'</span>, count)</span><br><span class="line">  &#125;, [count])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    render: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'render'</span>, count),</span><br><span class="line">    click: <span class="function"><span class="params">()</span> =&gt;</span> setCount(count + <span class="number">1</span>),</span><br><span class="line">    noop: <span class="function"><span class="params">()</span> =&gt;</span> setCount(count), <span class="comment">// 保持不变, 观察 useEffect 是否被调用</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Counter().render() <span class="comment">// 'useEffect' 0, 'render', 0</span></span><br><span class="line">Counter().noop()</span><br><span class="line">Counter().render() <span class="comment">// 'render', 0</span></span><br><span class="line">Counter().click()</span><br><span class="line">Counter().render() <span class="comment">// 'useEffect' 1, 'render', 1</span></span><br></pre></td></tr></table></figure><h4 id="处理多次调用的情形"><a href="#处理多次调用的情形" class="headerlink" title="处理多次调用的情形"></a>处理多次调用的情形</h4><p>为了在 <code>hooks</code> 中能使用多次 <code>useState</code>, <code>useEffect</code>, 将各个 <code>useState</code>, <code>useEffect</code> 的调用存进一个数组中, 在上面基础上进行如下改造:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> React = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> hooks = []</span><br><span class="line">  <span class="keyword">let</span> currentHook = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    render(Component) &#123;</span><br><span class="line">      <span class="keyword">const</span> component = Component()</span><br><span class="line">      component.render()</span><br><span class="line">      currentHook = <span class="number">0</span> <span class="comment">// 重置, 这里很关键, 将 hooks 的执行放到 hooks 队列中, 确保每次执行的顺序保持一致。</span></span><br><span class="line">      <span class="keyword">return</span> component</span><br><span class="line">    &#125;,</span><br><span class="line">    useState(initialValue) &#123;</span><br><span class="line">      hooks[currentHook] = hooks[currentHook] || initialValue</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">setVal</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        hooks[currentHook] = value</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> [hooks[currentHook++], setVal]</span><br><span class="line">    &#125;,</span><br><span class="line">    useEffect(callback, deps) &#123;</span><br><span class="line">      <span class="keyword">const</span> ifUpdate = !deps</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 判断 Deps 中的依赖是否改变</span></span><br><span class="line">      <span class="keyword">const</span> ifDepsChange = hooks[currentHook] ? !hooks[currentHook].every(<span class="function">(<span class="params">r, index</span>) =&gt;</span> r === deps[index]) : <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (ifUpdate || ifDepsChange) &#123;</span><br><span class="line">        callback()</span><br><span class="line"></span><br><span class="line">        hooks[currentHook++] = deps || []</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>测试代码如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123;useState, useEffect&#125; = React</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">const</span> [type, setType] = useState(<span class="string">'hi'</span>)</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'useEffect'</span>, count)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'type'</span>, type)</span><br><span class="line">  &#125;, [count, type])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    render: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'render'</span>, count),</span><br><span class="line">    click: <span class="function"><span class="params">()</span> =&gt;</span> setCount(count + <span class="number">1</span>),</span><br><span class="line">    noop: <span class="function"><span class="params">()</span> =&gt;</span> setCount(count), <span class="comment">// 保持不变, 观察 useEffect 是否被调用</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 如下 mock 执行了 useEffect、render; 这里使用 React.render 的原因是为了重置 currentHook 的值 */</span></span><br><span class="line"><span class="keyword">let</span> comp = React.render(Counter) <span class="comment">// useEffect 0 type hi render 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 如下 mock 只执行了 render */</span></span><br><span class="line">comp.noop()</span><br><span class="line">comp = React.render(Counter) <span class="comment">// render 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 如下 mock 重新执行了 useEffect、render */</span></span><br><span class="line">comp.click()</span><br><span class="line">React.render(Counter) <span class="comment">// useEffect 1, render 1</span></span><br></pre></td></tr></table></figure><h3 id="相关资源"><a href="#相关资源" class="headerlink" title="相关资源"></a>相关资源</h3><ul><li><a href="https://github.com/rehooks/awesome-react-hooks" target="_blank" rel="noopener">awesome-react-hooks</a></li><li><a href="https://github.com/gragland/usehooks" target="_blank" rel="noopener">usehooks</a></li><li><a href="https://www.netlify.com/blog/2019/03/11/deep-dive-how-do-react-hooks-really-work/" target="_blank" rel="noopener">deep-dive-how-do-react-hooks-really-work</a></li><li><a href="https://overreacted.io/a-complete-guide-to-useeffect/" target="_blank" rel="noopener">a-complete-guide-to-useeffect</a>: 推荐 Dan 的这篇文章</li><li><a href="https://adamrackis.dev/state-and-use-reducer/" target="_blank" rel="noopener">Hooks, State, Closures, and useReducer</a>: 作为 <a href="https://overreacted.io/a-complete-guide-to-useeffect/#decoupling-updates-from-actions" target="_blank" rel="noopener">decoupling-updates-from-actions</a> 的补充</li><li><a href="https://kentcdodds.com/blog/should-i-usestate-or-usereducer/" target="_blank" rel="noopener">Should I useState or useReducer</a>:</li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun May 10 2020 18:57:15 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;&lt;img src=&quot;http://with.muyunyun.cn/34a60f7edb08afaf6d721708ab21b4d7.jpg-muyy&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;本文为对 hooks 碎片化的理解。同时欢迎关注基于 hooks 构建的 UI 组件库 —— &lt;a href=&quot;https://github.com/ming-cult/snake-design&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;snake-design&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="React" scheme="http://muyunyun.cn/categories/React/"/>
    
      <category term="Hooks" scheme="http://muyunyun.cn/categories/React/Hooks/"/>
    
    
      <category term="React" scheme="http://muyunyun.cn/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>你不知道的 requestIdleCallback</title>
    <link href="http://muyunyun.cn/posts/ba7c84ae/"/>
    <id>http://muyunyun.cn/posts/ba7c84ae/</id>
    <published>2019-03-23T12:30:38.000Z</published>
    <updated>2020-05-08T11:36:18.544Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 18:57:15 GMT+0800 (China Standard Time) --><p><img src="http://with.muyunyun.cn/7558dee9cbc163226d4a821596c00245.jpg-muyy" alt=""></p><p>本文副标题是 <code>Request Schedule 源码解析一</code>。在本章中会介绍 <code>requestIdleCallback</code> 的用法以及其缺陷, 接着对 React 团队对该 api 的 hack 部分的源码进行剖析。在下一篇中会结合优先级对 React 的调度算法进行宏观的解释, 欢迎关注<a href="https://github.com/MuYunyun/blog" target="_blank" rel="noopener">个人博客</a>。</p><a id="more"></a><p><code>React 调度算法</code> 与 <code>requestIdleCallback</code> 这个 api 息息相关。<code>requestIdleCallback</code> 的作用是是在浏览器一帧的剩余空闲时间内执行优先度相对较低的任务, 其用法如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tasksNum = <span class="number">10000</span></span><br><span class="line"></span><br><span class="line">requestIdleCallback(unImportWork)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unImportWork</span>(<span class="params">deadline</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (deadline.timeRemaining() &amp;&amp; tasksNum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`执行了<span class="subst">$&#123;<span class="number">10000</span> - tasksNum + <span class="number">1</span>&#125;</span>个任务`</span>)</span><br><span class="line">    tasksNum--</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (tasksNum &gt; <span class="number">0</span>) &#123; <span class="comment">// 在未来的帧中继续执行</span></span><br><span class="line">    requestIdleCallback(unImportWork)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>deadline</code> 有两个参数</p><ul><li><code>timeRemaining()</code>: 当前帧还剩下多少时间</li><li><code>didTimeout</code>: 是否超时</li></ul><p>另外 <code>requestIdleCallback</code> 后如果跟上第二个参数 <code>{timeout: ...}</code> 则会强制浏览器在当前帧执行完后执行。</p><h3 id="requestIdleCallback-的缺陷"><a href="#requestIdleCallback-的缺陷" class="headerlink" title="requestIdleCallback 的缺陷"></a>requestIdleCallback 的缺陷</h3><blockquote><p>requestIdleCallback is called only 20 times per second - Chrome on my 6x2 core Linux machine, it’s not really useful for UI work。—— from <a href="https://github.com/facebook/react/issues/13206#issuecomment-418923831" target="_blank" rel="noopener">Releasing Suspense</a></p></blockquote><p>也就是说 <code>requestIdleCallback</code> 的 FPS 只有 <code>20</code>, 这远远低于页面流畅度的要求！(一般 FPS 为 60 时对用户来说是感觉流程的, 即一帧时间为 16.7 ms), 这也是 React 需要自己实现 <code>requestIdleCallback</code> 的原因。</p><h3 id="源码解析之-requestIdleCallback"><a href="#源码解析之-requestIdleCallback" class="headerlink" title="源码解析之 requestIdleCallback"></a>源码解析之 requestIdleCallback</h3><h4 id="非-DOM-环境"><a href="#非-DOM-环境" class="headerlink" title="非 DOM 环境"></a>非 DOM 环境</h4><p>在不能操作 DOM 的环境下, 可以借助 <code>setTimeout</code> 来模拟 <code>requestIdleCallback</code> 的实现。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">requestIdleCallback = <span class="function">(<span class="params">callback</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(callback(&#123;</span><br><span class="line">    timeRemaining() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">Infinity</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面将 React 源码中关于服务端的实现也呈现出来:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> _callback = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">const</span> _flushCallback = <span class="function"><span class="keyword">function</span> (<span class="params">didTimeout</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (_callback !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      _callback(didTimeout);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      _callback = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">requestHostCallback = <span class="function"><span class="keyword">function</span> (<span class="params">cb</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (_callback !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果 _callback 不为空, 则将 requestHostCallback 放到下一个事件队列中再次执行</span></span><br><span class="line">    setTimeout(requestHostCallback, <span class="number">0</span>, cb);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    _callback = cb;</span><br><span class="line">    setTimeout(_flushCallback, <span class="number">0</span>, <span class="literal">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">cancelHostCallback = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  _callback = <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br><span class="line">shouldYieldToHost = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="DOM-环境"><a href="#DOM-环境" class="headerlink" title="DOM 环境"></a>DOM 环境</h4><p>在浏览器端的环境下, 介绍一个与 <code>requestIdleCallback</code> 功能相近的 api —— <code>requestAnimationFrame(callback)</code>, 其会在下次重绘前执行指定的回调函数，因此这个 api 在动效领域得到了广泛的使用。下面通过一个简单的 demo 来认识它:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> frame</span><br><span class="line"><span class="keyword">let</span> n = <span class="number">5</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params">timeStamp</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(timeStamp) <span class="comment">// 开始执行回调的时间戳</span></span><br><span class="line"><span class="comment">// 如果想要产生循环动画的效果, 需在回调函数中再次调用 requestAnimationFrame()</span></span><br><span class="line"><span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    requestAnimationFrame(callback)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'测试执行顺序'</span>)</span><br><span class="line">n--</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">frame = requestAnimationFrame(callback) <span class="comment">// 在下次重绘之前调用回调</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果想要销毁该回调, 可以执行 cancelAnimationFrame(frame)</span></span><br></pre></td></tr></table></figure><p>执行上述代码, 控制台(chrome)打印如下数据:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">先输出 <span class="number">5</span> 次 <span class="string">'测试执行顺序'</span></span><br><span class="line"><span class="number">1795953.649</span></span><br><span class="line"><span class="number">1795970.318</span></span><br><span class="line"><span class="number">1795986.987</span></span><br><span class="line"><span class="number">1796003.656</span></span><br><span class="line"><span class="number">1796020.325</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>可以看到在浏览器上一帧的时间大致为 <code>16ms</code>。同时可以看到 <code>requestAnimation(callback)</code> 中的 callback 也是异步的(只不过它是基于帧与帧间的异步), 所以上述打印结果是先打印出 5 次 ‘测试执行顺序’ 后再依次打印出 5 个时间戳。</p><p><code>requestHostCallback</code>(也就是 requestIdleCallback) 这部分源码的实现比较复杂, 可以将其分解为以下几个重要的步骤(有一些细节点可以看注释):</p><ol><li>步骤一: 如果有优先级更高的任务, 则通过 <code>postMessage</code> 触发步骤四, 否则如果 <code>requestAnimationFrame</code> 在当前帧没有安排任务, 则开始一个帧的流程;</li><li>步骤二: 在一个帧的流程中调用 <code>requestAnimationFrameWithTimeout</code> 函数, 该函数调用了 <code>requestAnimationFrame</code>, 并对执行时间超过 <code>100ms</code> 的任务用 <code>setTimeout</code> 放到下一个事件队列中处理;</li><li>步骤三: 执行 <code>requestAnimationFrame</code> 中的回调函数 <code>animationTick</code>, 在该回调函数中得到当前帧的截止时间 <code>frameDeadline</code>, 并通过 <code>postMessage</code> 触发步骤四;</li><li>步骤四: 通过 <code>onmessage</code> 接受 <code>postMessage</code> 指令, 触发消息事件的执行。在 <code>onmessage</code> 函数中根据 <code>frameDeadline - currentTime &lt;= 0</code> 判断任务是否可以在当前帧执行，如果可以的话执行该任务, 否则进入下一帧的调用。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> requestHostCallback;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> cancelHostCallback;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> shouldYieldToHost;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> getCurrentTime;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ANIMATION_FRAME_TIMEOUT = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">let</span> rAFID;</span><br><span class="line"><span class="keyword">let</span> rAFTimeoutID;</span><br><span class="line"><span class="comment">// ② 调用 requestAnimationFrame, 并对执行时间超过 100 ms 的任务用 setTimeout 进行处理</span></span><br><span class="line"><span class="keyword">const</span> requestAnimationFrameWithTimeout = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  rAFID = requestAnimationFrame(<span class="function"><span class="keyword">function</span> (<span class="params">timestamp</span>) </span>&#123;</span><br><span class="line">    clearTimeout(rAFTimeoutID);</span><br><span class="line">    callback(timestamp); <span class="comment">// 一帧中任务调用的核心流程的实现, 接着看第 ③ 步</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 如果在一帧中某个任务执行时间超过 100 ms 则终止该帧的执行并将该任务放入下一个事件队列中</span></span><br><span class="line">  rAFTimeoutID = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    cancelAnimationFrame(rAFID);</span><br><span class="line">    callback(getCurrentTime());</span><br><span class="line">  &#125;, ANIMATION_FRAME_TIMEOUT);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">getCurrentTime = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> performance.now();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> scheduledHostCallback = <span class="literal">null</span>; <span class="comment">// 调度器回调函数</span></span><br><span class="line"><span class="keyword">let</span> isMessageEventScheduled = <span class="literal">false</span>; <span class="comment">// 消息事件是否执行</span></span><br><span class="line"><span class="keyword">let</span> timeoutTime = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> isAnimationFrameScheduled = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> isFlushingHostCallback = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> frameDeadline = <span class="number">0</span>; <span class="comment">// 当前帧的截止时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设最开始的 FPS(feet per seconds) 为 30, 但这个值会随着动画帧调用的频率而动态变化</span></span><br><span class="line"><span class="keyword">let</span> previousFrameTime = <span class="number">33</span>; <span class="comment">// 一帧的时间: 1000 / 30 ≈ 33</span></span><br><span class="line"><span class="keyword">let</span> activeFrameTime = <span class="number">33</span>;</span><br><span class="line"></span><br><span class="line">shouldYieldToHost = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> frameDeadline &lt;= getCurrentTime();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> channel = <span class="keyword">new</span> MessageChannel();</span><br><span class="line"><span class="keyword">const</span> port = channel.port2;</span><br><span class="line"><span class="comment">// ④ 接受 `postMessage` 指令, 触发消息事件的执行。在其中判断任务是否在当前帧执行，如果在的话执行该任务</span></span><br><span class="line">channel.port1.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  isMessageEventScheduled = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> prevScheduledCallback = scheduledHostCallback;</span><br><span class="line">  <span class="keyword">const</span> prevTimeoutTime = timeoutTime;</span><br><span class="line">  scheduledHostCallback = <span class="literal">null</span>;</span><br><span class="line">  timeoutTime = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> currentTime = getCurrentTime();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> didTimeout = <span class="literal">false</span>; <span class="comment">// 是否超时</span></span><br><span class="line">  <span class="comment">// 如果当前帧已经没有时间剩余, 检查是否有 timeout 参数，如果有的话是否已经超过这个时间</span></span><br><span class="line">  <span class="keyword">if</span> (frameDeadline - currentTime &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prevTimeoutTime !== <span class="number">-1</span> &amp;&amp; prevTimeoutTime &lt;= currentTime) &#123;</span><br><span class="line">      <span class="comment">// didTimeout 为 true 后, 在当前帧中执行(针对优先级较高的任务)</span></span><br><span class="line">      didTimeout = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 在下一帧中执行</span></span><br><span class="line">      <span class="keyword">if</span> (!isAnimationFrameScheduled) &#123;</span><br><span class="line">        isAnimationFrameScheduled = <span class="literal">true</span>;</span><br><span class="line">        requestAnimationFrameWithTimeout(animationTick);</span><br><span class="line">      &#125;</span><br><span class="line">      scheduledHostCallback = prevScheduledCallback;</span><br><span class="line">      timeoutTime = prevTimeoutTime;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (prevScheduledCallback !== <span class="literal">null</span>) &#123;</span><br><span class="line">    isFlushingHostCallback = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      prevScheduledCallback(didTimeout);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      isFlushingHostCallback = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ③ requestAnimationFrame 的回调函数。传入的 rafTime 为执行该帧的时间戳。</span></span><br><span class="line"><span class="keyword">const</span> animationTick = <span class="function"><span class="keyword">function</span> (<span class="params">rafTime</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果存在调度器回调函数则在一帧的开头急切地安排下一帧的动画回调(急切是因为如果在帧的后半段安排动画回调的话, 就会增大下一帧超过 100ms 的几率, 从而会浪费一个帧的利用, 可以结合步骤②来理解这句话), 如果不存在调度器回调函数否则立马终止执行。</span></span><br><span class="line">  <span class="keyword">if</span> (scheduledHostCallback !== <span class="literal">null</span>) &#123;</span><br><span class="line">    requestAnimationFrameWithTimeout(animationTick);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    isAnimationFrameScheduled = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> nextFrameTime = rafTime - frameDeadline + activeFrameTime; <span class="comment">// 当前帧开始调用动画的时间 - 上一帧调用动画的截止时间 + 当前帧执行的时间，这里的 nextFrameTime 仅仅是临时变量</span></span><br><span class="line">  <span class="comment">// 如果连续两帧的时间都小于当前帧的时间, 则说明得调高 FPS</span></span><br><span class="line">  <span class="keyword">if</span> (nextFrameTime &lt; activeFrameTime &amp;&amp; previousFrameTime &lt; activeFrameTime) &#123;</span><br><span class="line">    <span class="comment">// 将 activeFrameTime 的值减小相当于调高 FPS。同时取 nextFrameTime 与 previousFrameTime 中较大的一个以让前后两帧都不出问题。</span></span><br><span class="line">    activeFrameTime =</span><br><span class="line">      nextFrameTime &lt; previousFrameTime ? previousFrameTime : nextFrameTime;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    previousFrameTime = nextFrameTime;</span><br><span class="line">  &#125;</span><br><span class="line">  frameDeadline = rafTime + activeFrameTime; <span class="comment">// 当前帧的截止时间(上面几行代码的目的是得到该 frameDeadline 值, 该值在 postMessage 会用来判断)</span></span><br><span class="line">  <span class="keyword">if</span> (!isMessageEventScheduled) &#123;</span><br><span class="line">    isMessageEventScheduled = <span class="literal">true</span>;</span><br><span class="line">    port.postMessage(<span class="literal">undefined</span>); <span class="comment">// 最后进入第④步, 通过 postMessage 触发消息事件。</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DOM 环境下 requestIdleCallback 的实现, 这里第二个参数在最新的 requestIdleCallback 中因为对象类型</span></span><br><span class="line">requestHostCallback = <span class="function"><span class="keyword">function</span> (<span class="params">callback, absoluteTimeout</span>) </span>&#123;</span><br><span class="line">  scheduledHostCallback = callback; <span class="comment">// 这里的 callback 为调度器回调函数</span></span><br><span class="line">  timeoutTime = absoluteTimeout;</span><br><span class="line">  <span class="keyword">if</span> (isFlushingHostCallback || absoluteTimeout &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 针对优先级较高的任务不等下一个帧，在当前帧通过 postMessage 尽快执行</span></span><br><span class="line">    port.postMessage(<span class="literal">undefined</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isAnimationFrameScheduled) &#123;</span><br><span class="line">    <span class="comment">// ① 如果 rAF 在当前帧没有安排任务, 则开始一个帧的流程</span></span><br><span class="line">    isAnimationFrameScheduled = <span class="literal">true</span>;</span><br><span class="line">    requestAnimationFrameWithTimeout(animationTick);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">cancelHostCallback = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  scheduledHostCallback = <span class="literal">null</span>;</span><br><span class="line">  isMessageEventScheduled = <span class="literal">false</span>;</span><br><span class="line">  timeoutTime = <span class="number">-1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h3><ul><li><a href="https://github.com/facebook/react/blob/master/packages/scheduler/src/forks/SchedulerHostConfig.default.js" target="_blank" rel="noopener">requestIdleCallback polyful</a></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun May 10 2020 18:57:15 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;&lt;img src=&quot;http://with.muyunyun.cn/7558dee9cbc163226d4a821596c00245.jpg-muyy&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;本文副标题是 &lt;code&gt;Request Schedule 源码解析一&lt;/code&gt;。在本章中会介绍 &lt;code&gt;requestIdleCallback&lt;/code&gt; 的用法以及其缺陷, 接着对 React 团队对该 api 的 hack 部分的源码进行剖析。在下一篇中会结合优先级对 React 的调度算法进行宏观的解释, 欢迎关注&lt;a href=&quot;https://github.com/MuYunyun/blog&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;个人博客&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="React" scheme="http://muyunyun.cn/categories/React/"/>
    
    
      <category term="React" scheme="http://muyunyun.cn/tags/React/"/>
    
      <category term="Schedule" scheme="http://muyunyun.cn/tags/Schedule/"/>
    
  </entry>
  
  <entry>
    <title>深度理解 React Suspense</title>
    <link href="http://muyunyun.cn/posts/44b01006/"/>
    <id>http://muyunyun.cn/posts/44b01006/</id>
    <published>2019-03-04T15:45:01.000Z</published>
    <updated>2019-03-04T16:28:15.691Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 18:57:15 GMT+0800 (China Standard Time) --><p><img src="http://with.muyunyun.cn/7e992292f9fac2209d9e74499cea1840.jpg-muyy" alt=""></p><p>本文介绍与 <code>Suspense</code> 在三种情景下使用方法，并结合源码进行相应解析。欢迎关注<a href="https://github.com/MuYunyun/blog" target="_blank" rel="noopener">个人博客</a>。</p><a id="more"></a><h3 id="Code-Spliting"><a href="#Code-Spliting" class="headerlink" title="Code Spliting"></a>Code Spliting</h3><p>在 16.6 版本之前，<code>code-spliting</code> 通常是由第三方库来完成的，比如 <a href="https://github.com/jamiebuilds/react-loadable" target="_blank" rel="noopener">react-loadble</a>(核心思路为: 高阶组件 + webpack dynamic import), 在 16.6 版本中提供了 <code>Suspense</code> 和 <code>lazy</code> 这两个钩子, 因此在之后的版本中便可以使用其来实现 <code>Code Spliting</code>。</p><blockquote><p>目前阶段, 服务端渲染中的 <code>code-spliting</code> 还是得使用 <code>react-loadable</code>, 可查阅 <a href="https://reactjs.org/docs/code-splitting.html#reactlazy" target="_blank" rel="noopener">React.lazy</a>, 暂时先不探讨原因。</p></blockquote><p><code>Code Spliting</code> 在 <code>React</code> 中的使用方法是在 <code>Suspense</code> 组件中使用 <code>&lt;LazyComponent&gt;</code> 组件:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Suspense, lazy &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> DemoA = lazy(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'./demo/a'</span>))</span><br><span class="line"><span class="keyword">const</span> DemoB = lazy(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'./demo/b'</span>))</span><br><span class="line"></span><br><span class="line">&lt;Suspense&gt;</span><br><span class="line">  &lt;NavLink to=<span class="string">"/demoA"</span>&gt;DemoA&lt;<span class="regexp">/NavLink&gt;</span></span><br><span class="line"><span class="regexp">  &lt;NavLink to="/</span>demoB<span class="string">"&gt;DemoB&lt;/NavLink&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  &lt;Router&gt;</span></span><br><span class="line"><span class="string">    &lt;DemoA path="</span>/demoA<span class="string">" /&gt;</span></span><br><span class="line"><span class="string">    &lt;DemoB path="</span>/demoB<span class="string">" /&gt;</span></span><br><span class="line"><span class="string">  &lt;/Router&gt;</span></span><br><span class="line"><span class="string">&lt;/Suspense&gt;</span></span><br></pre></td></tr></table></figure><p>源码中 <code>lazy</code> 将传入的参数封装成一个 <code>LazyComponent</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lazy</span>(<span class="params">ctor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    $$<span class="keyword">typeof</span>: REACT_LAZY_TYPE, <span class="comment">// 相关类型</span></span><br><span class="line">    _ctor: ctor,</span><br><span class="line">    _status: <span class="number">-1</span>,   <span class="comment">// dynamic import 的状态</span></span><br><span class="line">    _result: <span class="literal">null</span>, <span class="comment">// 存放加载文件的资源</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察 <a href="https://github.com/MuYunyun/react/blob/29b7b775f2ecf878eaf605be959d959030598b07/packages/react-reconciler/src/ReactFiberLazyComponent.js#L30-L87" target="_blank" rel="noopener">readLazyComponentType</a> 后可以发现 <code>dynamic import</code> 本身类似 <code>Promise</code> 的执行机制, 也具有 <code>Pending</code>、<code>Resolved</code>、<code>Rejected</code> 三种状态, 这就比较好理解为什么 <code>LazyComponent</code> 组件需要放在 <code>Suspense</code> 中执行了(<code>Suspense</code> 中提供了相关的捕获机制, 下文会进行模拟实现`), 相关源码如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readLazyComponentType</span>(<span class="params">lazyComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> status = lazyComponent._status;</span><br><span class="line">  <span class="keyword">const</span> result = lazyComponent._result;</span><br><span class="line">  <span class="keyword">switch</span> (status) &#123;</span><br><span class="line">    <span class="keyword">case</span> Resolved: &#123; <span class="comment">// Resolve 时，呈现相应资源</span></span><br><span class="line">      <span class="keyword">const</span> Component = result;</span><br><span class="line">      <span class="keyword">return</span> Component;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> Rejected: &#123; <span class="comment">// Rejected 时，throw 相应 error</span></span><br><span class="line">      <span class="keyword">const</span> error = result;</span><br><span class="line">      <span class="keyword">throw</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> Pending: &#123;  <span class="comment">// Pending 时, throw 相应 thenable</span></span><br><span class="line">      <span class="keyword">const</span> thenable = result;</span><br><span class="line">      <span class="keyword">throw</span> thenable;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>: &#123; <span class="comment">// 第一次执行走这里</span></span><br><span class="line">      lazyComponent._status = Pending;</span><br><span class="line">      <span class="keyword">const</span> ctor = lazyComponent._ctor;</span><br><span class="line">      <span class="keyword">const</span> thenable = ctor(); <span class="comment">// 可以看到和 Promise 类似的机制</span></span><br><span class="line">      thenable.then(</span><br><span class="line">        moduleObject =&gt; &#123;</span><br><span class="line">          <span class="keyword">if</span> (lazyComponent._status === Pending) &#123;</span><br><span class="line">            <span class="keyword">const</span> defaultExport = moduleObject.default;</span><br><span class="line">            lazyComponent._status = Resolved;</span><br><span class="line">            lazyComponent._result = defaultExport;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        error =&gt; &#123;</span><br><span class="line">          <span class="keyword">if</span> (lazyComponent._status === Pending) &#123;</span><br><span class="line">            lazyComponent._status = Rejected;</span><br><span class="line">            lazyComponent._result = error;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">      );</span><br><span class="line">      <span class="comment">// Handle synchronous thenables.</span></span><br><span class="line">      <span class="keyword">switch</span> (lazyComponent._status) &#123;</span><br><span class="line">        <span class="keyword">case</span> Resolved:</span><br><span class="line">          <span class="keyword">return</span> lazyComponent._result;</span><br><span class="line">        <span class="keyword">case</span> Rejected:</span><br><span class="line">          <span class="keyword">throw</span> lazyComponent._result;</span><br><span class="line">      &#125;</span><br><span class="line">      lazyComponent._result = thenable;</span><br><span class="line">      <span class="keyword">throw</span> thenable;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Async-Data-Fetching"><a href="#Async-Data-Fetching" class="headerlink" title="Async Data Fetching"></a>Async Data Fetching</h3><p>为了解决获取的数据在不同时刻进行展现的问题(在 <a href="https://github.com/demos-platform/suspenseDemo" target="_blank" rel="noopener">suspenseDemo</a> 中有相应演示), <code>Suspense</code> 给出了解决方案。</p><p>下面放两段代码，可以从中直观地感受在 <code>Suspense</code> 中使用 <code>Async Data Fetching</code> 带来的便利。</p><ul><li>一般进行数据获取的代码如下:</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    data: <span class="literal">null</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    fetchAPI(<span class="string">`/api/demo/<span class="subst">$&#123;<span class="keyword">this</span>.props.id&#125;</span>`</span>).then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123; data &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; data &#125; = <span class="keyword">this</span>.state;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (data == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Spinner</span> /&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> &#123; name &#125; = data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;&#123;name&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>在 <code>Suspense</code> 中进行数据获取的代码如下:</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> resource = unstable_createResource(<span class="function">(<span class="params">id</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> fetchAPI(<span class="string">`/api/demo`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> data = resource.read(<span class="keyword">this</span>.props.id)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> &#123; name &#125; = data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;&#123;name&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>可以看到在 <code>Suspense</code> 中进行数据获取的代码量相比正常的进行数据获取的代码少了将近一半！少了哪些地方呢?</p><ul><li>减少了 <code>loading</code> 状态的维护(在最外层的 Suspense 中统一维护子组件的 loading)</li><li>减少了不必要的生命周期的书写</li></ul><h3 id="总结-如何在-Suspense-中使用-Data-Fetching"><a href="#总结-如何在-Suspense-中使用-Data-Fetching" class="headerlink" title="总结: 如何在 Suspense 中使用 Data Fetching"></a>总结: 如何在 Suspense 中使用 Data Fetching</h3><p>当前 <code>Suspense</code> 的使用分为三个部分:</p><p>第一步: 用 <code>Suspens</code> 组件包裹子组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Suspense &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line">&lt;Suspense fallback=&#123;&lt;Loading /&gt;&#125;&gt;</span><br><span class="line">  &lt;ChildComponent&gt;</span><br><span class="line">&lt;<span class="regexp">/Suspense&gt;</span></span><br></pre></td></tr></table></figure><p>第二步: 在子组件中使用 <code>unstable_createResource</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; unstable_createResource &#125; <span class="keyword">from</span> <span class="string">'react-cache'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> resource = unstable_createResource(<span class="function">(<span class="params">id</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> fetch(<span class="string">`/demo/<span class="subst">$&#123;id&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>第三步: 在 <code>Component</code> 中使用第一步创建的 <code>resource</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = resource.read(<span class="string">'demo'</span>)</span><br></pre></td></tr></table></figure><h3 id="相关思路解读"><a href="#相关思路解读" class="headerlink" title="相关思路解读"></a>相关思路解读</h3><p>来看下源码中 <code>unstable_createResource</code> 的部分会比较清晰:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">unstable_createResource</span>(<span class="params">fetch, maybeHashInput</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> resource = &#123;</span><br><span class="line">    read(input) &#123;</span><br><span class="line">      ...</span><br><span class="line">      <span class="keyword">const</span> result = accessResult(resource, fetch, input, key);</span><br><span class="line">      <span class="keyword">switch</span> (result.status) &#123;</span><br><span class="line">        <span class="keyword">case</span> Pending: &#123;</span><br><span class="line">          <span class="keyword">const</span> suspender = result.value;</span><br><span class="line">          <span class="keyword">throw</span> suspender;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> Resolved: &#123;</span><br><span class="line">          <span class="keyword">const</span> value = result.value;</span><br><span class="line">          <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> Rejected: &#123;</span><br><span class="line">          <span class="keyword">const</span> error = result.value;</span><br><span class="line">          <span class="keyword">throw</span> error;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="comment">// Should be unreachable</span></span><br><span class="line">          <span class="keyword">return</span> (<span class="literal">undefined</span>: any);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> resource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结合该部分源码, 进行如下推测:</p><ol><li>第一次请求没有缓存, 子组件 <code>throw</code> 一个 <code>thenable</code> 对象, <code>Suspense</code> 组件内的 <code>componentDidCatch</code> 捕获之, 此时展示 <code>Loading</code> 组件;</li><li>当 <code>Promise</code> 态的对象变为完成态后, 页面刷新此时 <code>resource.read()</code> 获取到相应完成态的值;</li><li>之后如果相同参数的请求, 则走 <code>LRU</code> 缓存算法, 跳过 <code>Loading</code> 组件返回结果(缓存算法见后记);</li></ol><p>官方作者是说法如下:</p><p><img src="http://with.muyunyun.cn/22849313e0b8b19e833df9a9a59a8546.jpg-400" alt=""></p><p>所以说法大致相同, 下面实现一个简单版的 <code>Suspense</code>:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Suspense</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    promise: <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidCatch(e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (e <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">        promise: e</span><br><span class="line">      &#125;, () =&gt; &#123;</span><br><span class="line">        e.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">            promise: <span class="literal">null</span></span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; fallback, children &#125; = <span class="keyword">this</span>.props</span><br><span class="line">    <span class="keyword">const</span> &#123; promise &#125; = <span class="keyword">this</span>.state</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">      &#123; promise ? fallback : children &#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进行如下调用</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;Suspense fallback=&#123;&lt;div&gt;loading...&lt;<span class="regexp">/div&gt;&#125;&gt;</span></span><br><span class="line"><span class="regexp">  &lt;PromiseThrower /</span>&gt;</span><br><span class="line">&lt;<span class="regexp">/Suspense&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">let cache = "";</span></span><br><span class="line"><span class="regexp">let returnData = cache;</span></span><br><span class="line"><span class="regexp">const fetch = () =&gt;</span></span><br><span class="line"><span class="regexp">  new Promise(resolve =&gt; &#123;</span></span><br><span class="line"><span class="regexp">    setTimeout(() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">      resolve("数据加载完毕");</span></span><br><span class="line"><span class="regexp">    &#125;, 2000);</span></span><br><span class="line"><span class="regexp">  &#125;);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">class PromiseThrower extends React.Component &#123;</span></span><br><span class="line"><span class="regexp">  getData = () =&gt; &#123;</span></span><br><span class="line"><span class="regexp">    const getData = fetch();</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    getData.then(data =&gt; &#123;</span></span><br><span class="line"><span class="regexp">      returnData = data;</span></span><br><span class="line"><span class="regexp">    &#125;);</span></span><br><span class="line"><span class="regexp">    if (returnData === cache) &#123;</span></span><br><span class="line"><span class="regexp">      throw getData;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">    return returnData;</span></span><br><span class="line"><span class="regexp">  &#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    return &lt;&gt;&#123;this.getData()&#125;&lt;/</span>&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://with.muyunyun.cn/90586c1edf33c7d143f2a3ec59667ab4.gif" alt=""></p><p>效果调试可以点击<a href="https://codesandbox.io/s/1zy82mm0j4" target="_blank" rel="noopener">这里</a>, 在 <code>16.6</code> 版本之后, <code>componentDidCatch</code> 只能捕获 <code>commit phase</code> 的异常。所以在 <code>16.6</code> 版本之后实现的 <code>&lt;PromiseThrower&gt;</code> 又有一些差异(即将 <code>throw thenable</code> 移到 <code>componentDidMount</code> 中进行)。</p><h3 id="ConcurrentMode-Suspense"><a href="#ConcurrentMode-Suspense" class="headerlink" title="ConcurrentMode + Suspense"></a>ConcurrentMode + Suspense</h3><p>当网速足够快, 数据立马就获取到了，此时页面存在的 <code>Loading</code> 按钮就显得有些多余了。(在 <a href="https://github.com/demos-platform/suspenseDemo" target="_blank" rel="noopener">suspenseDemo</a> 中有相应演示), <code>Suspense</code> 在 <code>Concurrent Mode</code> 下给出了相应的解决方案, 其提供了 <code>maxDuration</code> 参数。用法如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Suspense maxDuration=&#123;<span class="number">500</span>&#125; fallback=&#123;&lt;Loading /&gt;&#125;&gt;</span><br><span class="line">  ...</span><br><span class="line">&lt;<span class="regexp">/Suspense&gt;</span></span><br></pre></td></tr></table></figure><p>该 Demo 的效果为当获取数据的时间大于(是否包含等于还没确认) 500 毫秒, 显示自定义的 <code>&lt;Loading /&gt;</code> 组件, 当获取数据的时间小于 500 毫秒, 略过 <code>&lt;Loading&gt;</code> 组件直接展示用户的数据。<a href="https://github.com/MuYunyun/react/blob/29b7b775f2ecf878eaf605be959d959030598b07/packages/react-reconciler/src/ReactFiberUnwindWork.js#L232-L242" target="_blank" rel="noopener">相关源码</a>。</p><p>需要注意的是 <code>maxDuration</code> 属性只有在 <code>Concurrent Mode</code> 下才生效, 可参考<a href="https://github.com/MuYunyun/react/blob/29b7b775f2ecf878eaf605be959d959030598b07/packages/react-reconciler/src/ReactFiberUnwindWork.js#L270-L277" target="_blank" rel="noopener">源码中的注释</a>。在 Sync 模式下, <code>maxDuration</code> 始终为 0。</p><h3 id="后记-缓存算法"><a href="#后记-缓存算法" class="headerlink" title="后记: 缓存算法"></a>后记: 缓存算法</h3><ul><li><code>LRU</code> 算法: <code>Least Recently Used</code> 最近最少使用算法(根据时间);</li><li><code>LFU</code> 算法: <code>Least Frequently Used</code> 最近最少使用算法(根据次数);</li></ul><blockquote><p><a href="https://juejin.im/post/5c0392656fb9a049fb4366fa" target="_blank" rel="noopener">漫画：什么是 LRU 算法</a></p></blockquote><p>若数据的长度限定是 3, 访问顺序为 <code>set(2,2),set(1,1),get(2),get(1),get(2),set(3,3),set(4,4)</code>, 则根据 <code>LRU</code> 算法删除的是 <code>(3, 3)</code>, 根据 <code>LFU</code> 算法删除的是 <code>(1, 1)</code>。</p><p><code>react-cache</code> 采用的是 <code>LRU</code> 算法。</p><h3 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h3><ul><li><a href="https://github.com/demos-platform/suspenseDemo" target="_blank" rel="noopener">suspenseDemo</a>: 文字相关案例都集成在该 demo 中</li><li><a href="https://github.com/facebook/react/issues/13206" target="_blank" rel="noopener">Releasing Suspense</a>: <code>Suspense</code> 开发进度</li><li><a href="https://medium.com/@ryanflorence/the-suspense-is-killing-redux-e888f9692430" target="_blank" rel="noopener">the suspense is killing redux</a></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun May 10 2020 18:57:15 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;&lt;img src=&quot;http://with.muyunyun.cn/7e992292f9fac2209d9e74499cea1840.jpg-muyy&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;本文介绍与 &lt;code&gt;Suspense&lt;/code&gt; 在三种情景下使用方法，并结合源码进行相应解析。欢迎关注&lt;a href=&quot;https://github.com/MuYunyun/blog&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;个人博客&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="React" scheme="http://muyunyun.cn/categories/React/"/>
    
    
      <category term="React" scheme="http://muyunyun.cn/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>探索 React Fiber 数据结构</title>
    <link href="http://muyunyun.cn/posts/9f41fc98/"/>
    <id>http://muyunyun.cn/posts/9f41fc98/</id>
    <published>2019-02-23T13:27:41.000Z</published>
    <updated>2019-03-04T16:28:15.690Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 18:57:14 GMT+0800 (China Standard Time) --><p><img src="http://with.muyunyun.cn/dd8ac42021e3a5913a5c5d51437ade02.jpg-muyy" alt=""></p><p>此章节会通过两个 <code>demo</code> 来展示 <code>Stack Reconciler</code> 以及 <code>Fiber Reconciler</code> 的数据结构。</p><a id="more"></a><p><img src="http://with.muyunyun.cn/7621091ae74df1bbd8b00586128a7d44.jpg-300v" alt=""></p><p>首先用代码表示上图节点间的关系。比如 <code>a1 节点</code>下有 <code>b1、b2、b3 节点</code>, 就可以把它们间的关系写成 <code>a1.render = () =&gt; [b1, b2, b3]</code>;</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a1 = &#123; <span class="attr">name</span>: <span class="string">'a1'</span>, render = <span class="function"><span class="params">()</span> =&gt;</span> [b1, b2, b3] &#125;</span><br><span class="line"><span class="keyword">var</span> b1 = &#123; <span class="attr">name</span>: <span class="string">'b1'</span>, render = <span class="function"><span class="params">()</span> =&gt;</span> [c1] &#125;</span><br><span class="line"><span class="keyword">var</span> b2 = &#123; <span class="attr">name</span>: <span class="string">'b2'</span>, render = <span class="function"><span class="params">()</span> =&gt;</span> [c2] &#125;</span><br><span class="line"><span class="keyword">var</span> b3 = &#123; <span class="attr">name</span>: <span class="string">'b3'</span>, render = <span class="function"><span class="params">()</span> =&gt;</span> [] &#125;</span><br><span class="line"><span class="keyword">var</span> c1 = &#123; <span class="attr">name</span>: <span class="string">'c1'</span>, render = <span class="function"><span class="params">()</span> =&gt;</span> [d1] &#125;</span><br><span class="line"><span class="keyword">var</span> c2 = &#123; <span class="attr">name</span>: <span class="string">'c2'</span>, render = <span class="function"><span class="params">()</span> =&gt;</span> [] &#125;</span><br><span class="line"><span class="keyword">var</span> d1 = &#123; <span class="attr">name</span>: <span class="string">'d1'</span>, render = <span class="function"><span class="params">()</span> =&gt;</span> [d2] &#125;</span><br><span class="line"><span class="keyword">var</span> d2 = &#123; <span class="attr">name</span>: <span class="string">'d2'</span>, render = <span class="function"><span class="params">()</span> =&gt;</span> [] &#125;</span><br></pre></td></tr></table></figure><h4 id="Stack-Reconciler"><a href="#Stack-Reconciler" class="headerlink" title="Stack Reconciler"></a>Stack Reconciler</h4><p>在 <code>React 16</code> 之前，节点之间的关系可以用数据结构中<code>树的深度遍历</code>来表示。</p><p>如下实现 <code>walk</code> 函数, 将深度遍历的节点打印出来。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">walk(a1)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">walk</span>(<span class="params">instance</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!instance) <span class="keyword">return</span></span><br><span class="line">  <span class="built_in">console</span>.log(instance.name)</span><br><span class="line">  instance.render().map(walk)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为: <code>a1 b1 c1 d1 d2 b2 c2 b3</code></p><h4 id="Fiber-Reconciler"><a href="#Fiber-Reconciler" class="headerlink" title="Fiber Reconciler"></a>Fiber Reconciler</h4><p>在 <code>React 16</code> 中，节点之间的关系可以用数据结构中的<code>链表</code>来表示。</p><p>节点之间的链表有三种情形, 用图表示如下:</p><p><img src="http://with.muyunyun.cn/d7378495a2f16e9058c80326705465f4.jpg-300v" alt=""></p><ol><li>父节点到子节点(红色虚线)</li><li>同层节点(黄色虚线)</li><li>子节点到父节点(蓝色虚线)</li></ol><blockquote><p>父节点指向第一个子节点, 每个子节点都指向父节点，同层节点间是单向链表。</p></blockquote><p>首先, 构建节点的数据结构, 如下所示:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> FiberNode = <span class="function"><span class="keyword">function</span>(<span class="params">instance</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.instance = instance</span><br><span class="line">  <span class="keyword">this</span>.parent = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">this</span>.sibling = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">this</span>.child = <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后创建一个将节点串联起来的 <code>connect</code> 函数:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> connect = <span class="function"><span class="keyword">function</span>(<span class="params">parent, childList</span>) </span>&#123;</span><br><span class="line">  parent.child = childList.reduceRight(<span class="function">(<span class="params">prev, current</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> fiberNode = <span class="keyword">new</span> FiberNode(current)</span><br><span class="line">    fiberNode.parent = parent</span><br><span class="line">    fiberNode.sibling = prev</span><br><span class="line">    <span class="keyword">return</span> fiberNode</span><br><span class="line">  &#125;, <span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> parent.child</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在 JavaScript 中实现链表的数据结构可以巧用 reduceRight</p></blockquote><p><code>connect</code> 函数中实现了上述链表关系。可以像这样使用它:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> parent = <span class="keyword">new</span> FiberNode(a1)</span><br><span class="line"><span class="keyword">var</span> childFirst = connect(parent, a1.render())</span><br></pre></td></tr></table></figure><p>这样子便完成了 <code>a1 节点</code>指向 <code>b1 节点</code>的链表、<code>b1、b2、b3 节点间</code>的单向链表以及 <code>b1、b2、b3 节点</code>指向 <code>a1 节点</code>的链表。</p><p>最后剩下 <code>goWalk</code> 函数将全部节点给遍历完。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打印日志以及添加列表</span></span><br><span class="line"><span class="keyword">var</span> walk = <span class="function"><span class="keyword">function</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(node.instance.name)</span><br><span class="line">  <span class="keyword">const</span> childLists = node.instance.render()</span><br><span class="line">  <span class="keyword">let</span> child = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">if</span> (childLists.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    child = connect(node, childLists)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> child</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> goWalk = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> currentNode = root</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> child = walk(currentNode)</span><br><span class="line">    <span class="comment">// 如果有子节点</span></span><br><span class="line">    <span class="keyword">if</span> (child) &#123;</span><br><span class="line">      currentNode = child</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有相邻节点, 则返回到父节点</span></span><br><span class="line">    <span class="keyword">while</span> (!currentNode.sibling) &#123;</span><br><span class="line">      currentNode = currentNode.parent</span><br><span class="line">      <span class="keyword">if</span> (currentNode === root) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 相邻节点</span></span><br><span class="line">    currentNode = currentNode.sibling</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">goWalk(<span class="keyword">new</span> FiberNode(a1))</span><br></pre></td></tr></table></figure><p>打印结果为 <code>a1 b1 c1 d1 d2 b2 c2 b3</code></p><h3 id="Fiber-Reconciler-的优势"><a href="#Fiber-Reconciler-的优势" class="headerlink" title="Fiber Reconciler 的优势"></a>Fiber Reconciler 的优势</h3><p>通过分析上述两种数据结构实现的代码，可以得出下面结论:</p><ul><li>基于树的深度遍历实现的 Reconciler: 一旦进入调用栈便无法暂停;</li><li>基于链表实现的 Reconciler: 在 <code>while(true) {}</code> 的循环中, 可以通过 <code>currentNode</code> 的赋值重新得到需要操作的节点，而在赋值之前便可以’暂停’来执行其它逻辑, 这也是 <code>requestIdleCallback</code> 能得以在 <code>Fiber Reconciler</code> 的原因。</li></ul><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li><a href="https://medium.com/react-in-depth/the-how-and-why-on-reacts-usage-of-linked-list-in-fiber-67f1014d0eb7" target="_blank" rel="noopener">The how and why on React’s usage of linked list in Fiber to walk the component’s tree</a></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun May 10 2020 18:57:14 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;&lt;img src=&quot;http://with.muyunyun.cn/dd8ac42021e3a5913a5c5d51437ade02.jpg-muyy&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;此章节会通过两个 &lt;code&gt;demo&lt;/code&gt; 来展示 &lt;code&gt;Stack Reconciler&lt;/code&gt; 以及 &lt;code&gt;Fiber Reconciler&lt;/code&gt; 的数据结构。&lt;/p&gt;
    
    </summary>
    
    
      <category term="React" scheme="http://muyunyun.cn/categories/React/"/>
    
    
      <category term="React" scheme="http://muyunyun.cn/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>函数式编程入门</title>
    <link href="http://muyunyun.cn/posts/8b09c168/"/>
    <id>http://muyunyun.cn/posts/8b09c168/</id>
    <published>2019-02-05T05:23:23.000Z</published>
    <updated>2019-02-06T14:48:36.870Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 18:57:15 GMT+0800 (China Standard Time) --><p><img src="http://with.muyunyun.cn/aca1db3dd5aaabfbc4351181d1a39df6.jpg-muyy" alt=""></p><p>该系列会有 3 篇文章，分别介绍什么是函数式编程、剖析函数式编程库、以及函数式编程在 React 中的应用，欢迎关注我的 <a href="https://github.com/MuYunyun/blog" target="_blank" rel="noopener">blog</a></p><a id="more"></a><h3 id="命令式编程和声明式编程"><a href="#命令式编程和声明式编程" class="headerlink" title="命令式编程和声明式编程"></a>命令式编程和声明式编程</h3><p>拿泡茶这个事例进行区分命令式编程和声明式编程</p><ul><li>命令式编程</li></ul><p>1.烧开水(为第一人称)<br>2.拿个茶杯<br>3.放茶叶<br>4.冲水</p><ul><li>声明式编程</li></ul><p>1.给我泡杯茶(为第二人称)</p><p>举个 demo</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 命令式编程</span></span><br><span class="line"><span class="keyword">const</span> convert = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    result[i] = arr[i].toLowerCase()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明式编程</span></span><br><span class="line"><span class="keyword">const</span> convert = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.map(<span class="function"><span class="params">r</span> =&gt;</span> r.toLowerCase())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="什么是函数式编程"><a href="#什么是函数式编程" class="headerlink" title="什么是函数式编程"></a>什么是函数式编程</h3><p>函数式编程是声明式编程的范式。在函数式编程中数据在由纯函数组成的管道中传递。</p><blockquote><p>函数式编程可以用简单如<code>交换律、结合律、分配律</code>的数学之法来帮我们简化代码的实现。</p></blockquote><p>它具有如下一些特性:</p><ul><li>纯粹性: 纯函数不改变除当前作用域以外的值;</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 反面示例</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">0</span></span><br><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">b</span>) =&gt;</span> a = a + b <span class="comment">// 两次 add(1) 结果不一致</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例</span></span><br><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b</span><br></pre></td></tr></table></figure><ul><li>数据不可变性: Immutable</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 反面示例</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="keyword">const</span> arrAdd = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  arr.push(value)</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arrAdd(<span class="number">3</span>) <span class="comment">// [1, 2, 3]</span></span><br><span class="line">arrAdd(<span class="number">3</span>) <span class="comment">// [1, 2, 3, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正面示例</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="keyword">const</span> arrAdd = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> arr.concat(value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arrAdd(<span class="number">3</span>) <span class="comment">// [1, 2, 3]</span></span><br><span class="line">arrAdd(<span class="number">3</span>) <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><blockquote><p>在后记 1 中对数组字符串方法是否对原值有影响作了整理</p></blockquote><ul><li>函数柯里化: 将多个入参的函数转化为一个入参的函数;</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="function"><span class="params">a</span> =&gt;</span> <span class="function"><span class="params">b</span> =&gt;</span> <span class="function"><span class="params">c</span> =&gt;</span> a + b + c</span><br><span class="line">add(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><ul><li>偏函数: 将多个入参的函数转化成两部分;</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="function"><span class="params">a</span> =&gt;</span> <span class="function">(<span class="params">b, c</span>) =&gt;</span> a + b + c</span><br><span class="line">add(<span class="number">1</span>)(<span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><ul><li>可组合: 函数之间能组合使用</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">x</span>) =&gt;</span> x + x</span><br><span class="line"><span class="keyword">const</span> mult = <span class="function">(<span class="params">x</span>) =&gt;</span> x * x</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> addAndMult = <span class="function">(<span class="params">x</span>) =&gt;</span> add(mult(x))</span><br></pre></td></tr></table></figure><h3 id="柯里化-curry"><a href="#柯里化-curry" class="headerlink" title="柯里化(curry)"></a>柯里化(curry)</h3><p>如下是一个加法函数:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="function">(<span class="params">a, b, c</span>) =&gt;</span> a + b + c</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><p>假如有这样一个 <code>curry</code> 函数, 用其包装 <code>add</code> 函数后返回一个新的函数 <code>curryAdd</code>, 我们可以将参数 <code>a、b</code> 进行分开传递进行调用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> curryAdd = curry(add)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下输出结果都相同</span></span><br><span class="line">curryAdd(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="comment">// 6</span></span><br><span class="line">curryAdd(<span class="number">1</span>, <span class="number">2</span>)(<span class="number">3</span>) <span class="comment">// 6</span></span><br><span class="line">curryAdd(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>) <span class="comment">// 6</span></span><br><span class="line">curryAdd(<span class="number">1</span>)(<span class="number">2</span>, <span class="number">3</span>) <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><h4 id="动手实现一个-curry-函数"><a href="#动手实现一个-curry-函数" class="headerlink" title="动手实现一个 curry 函数"></a>动手实现一个 curry 函数</h4><p>核心思路: 若传进去的参数个数未达到 <code>curryAdd</code> 的个数，则将参数缓存在闭包变量 lists 中:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">fn, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> length = fn.length</span><br><span class="line">  <span class="keyword">let</span> lists = args || []</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> listLen</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">..._args</span>) </span>&#123;</span><br><span class="line">    lists = [...lists, ..._args]</span><br><span class="line">    listLen = lists.length</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (listLen &lt; length) &#123;</span><br><span class="line">      <span class="keyword">const</span> that = lists</span><br><span class="line">      lists = []</span><br><span class="line">      <span class="keyword">return</span> curry(fn, ...that)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (listLen === length) &#123;</span><br><span class="line">      <span class="keyword">const</span> that = lists</span><br><span class="line">      lists = []</span><br><span class="line">      <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, that)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码组合-compose"><a href="#代码组合-compose" class="headerlink" title="代码组合(compose)"></a>代码组合(compose)</h3><p>现在有 <code>toUpperCase</code>、<code>reverse</code>、<code>head</code> 三个函数, 分别如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> toUpperCase = <span class="function">(<span class="params">str</span>) =&gt;</span> str.toUpperCase()</span><br><span class="line"><span class="keyword">var</span> reverse = <span class="function">(<span class="params">arr</span>) =&gt;</span> arr.reverse()</span><br><span class="line"><span class="keyword">var</span> head = <span class="function">(<span class="params">arr</span>) =&gt;</span> arr[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>接着使用它们实现将数组末位元素大写化输出, 可以这样做:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseHeadUpperCase = <span class="function">(<span class="params">arr</span>) =&gt;</span> toUpperCase(head(reverse(arr)))</span><br><span class="line"></span><br><span class="line">reverseHeadUpperCase([<span class="string">'apple'</span>, <span class="string">'banana'</span>, <span class="string">'peach'</span>]) <span class="comment">// "PEACH"</span></span><br></pre></td></tr></table></figure><p>此时在构建 <code>reverseHeadUpperCase</code> 函数的时候, 必须手动声明传入参数 arr, 是否能提供一个 <code>compose</code> 函数让使用者更加友好的使用呢? 类似如下形式:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseHeadUpperCase = compose(toUpperCase, head, reverse)</span><br><span class="line"></span><br><span class="line">reverseHeadUpperCase([<span class="string">'apple'</span>, <span class="string">'banana'</span>, <span class="string">'peach'</span>]) <span class="comment">// "PEACH"</span></span><br></pre></td></tr></table></figure><p>此外 <code>compose</code> 函数符合<code>结合律</code>, 我们可以这样子使用:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">compose(compose(toUpperCase, head), reverse)</span><br><span class="line">compose(toUpperCase, compose(head, reverse))</span><br></pre></td></tr></table></figure><p>以上两种写法与 <code>compose(toUpperCase, head, reverse)</code> 的效果完全相同, 都是依次从右到左执行传参中的函数。</p><p>此外 <code>compose</code> 和 <code>map</code> 一起使用时也有相关的结合律, 以下两种写法效果相等</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">compose(map(f), map(g))</span><br><span class="line">map(compose(f, g))</span><br></pre></td></tr></table></figure><h4 id="动手实现一个-compose-函数"><a href="#动手实现一个-compose-函数" class="headerlink" title="动手实现一个 compose 函数"></a>动手实现一个 compose 函数</h4><p>代码精华集中在一行之内, 其为众多开源库(比如 Redux) 所采用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> compose = <span class="function">(<span class="params">...args</span>) =&gt;</span> <span class="function">(<span class="params">initValue</span>) =&gt;</span> args.reduceRight(<span class="function">(<span class="params">a, c</span>) =&gt;</span> c(a), initValue)</span><br></pre></td></tr></table></figure><h3 id="范畴论"><a href="#范畴论" class="headerlink" title="范畴论"></a>范畴论</h3><p>范畴论是数学中的一个分支。可以将范畴理解为一个容器, 把原来对值的操作，现转为对容器的操作。如下图:</p><p><img src="http://with.muyunyun.cn/c65fa1b63dbe9fa0a0771e7e561dc85b.jpg-200" alt=""></p><blockquote><p>学习函数式编程就是学习各种函子的过程。</p></blockquote><p>函数式编程中, <code>函子(Functor)</code> 是实现了 <code>map</code> 函数的容器, 下文中将函子视为范畴，模型可表示如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Functor</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(value) &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  map(fn) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Functor(fn(<span class="keyword">this</span>.value))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是在函数式编程中, 要避免使用 <code>new</code> 这种面向对象的编程方式, 取而代之对外暴露了一个 <code>of</code> 的接口, 也称为 <code>pointed functor</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Functor.of = <span class="function"><span class="params">value</span> =&gt;</span> <span class="keyword">new</span> Functor(value)</span><br></pre></td></tr></table></figure><h4 id="Maybe-函子"><a href="#Maybe-函子" class="headerlink" title="Maybe 函子"></a>Maybe 函子</h4><p><code>Maybe 函子</code>是为了解决 <code>this.value</code> 为 null 的情形, 用法如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Maybe.of(<span class="literal">null</span>).map(<span class="function"><span class="params">r</span> =&gt;</span> r.toUpperCase()) <span class="comment">// null</span></span><br><span class="line">Maybe.of(<span class="string">'m'</span>).map(<span class="function"><span class="params">r</span> =&gt;</span> r.toUpperCase())  <span class="comment">// Maybe &#123;value: "M"&#125;</span></span><br></pre></td></tr></table></figure><p>实现代码如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Maybe</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(value) &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  map(fn) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.value ? <span class="keyword">new</span> Maybe(fn(<span class="keyword">this</span>.value)) : <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Maybe.of = <span class="function"><span class="params">value</span> =&gt;</span> <span class="keyword">new</span> Maybe(value)</span><br></pre></td></tr></table></figure><h4 id="Either-函子"><a href="#Either-函子" class="headerlink" title="Either 函子"></a>Either 函子</h4><p><code>Either 函子</code> 是为了对应 <code>if...else...</code> 的语法, 即<code>非左即右</code>。因此可以将之拆分为 <code>Left</code> 和 <code>Right</code> 两个函子, 它们的用法如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Left.of(<span class="number">1</span>).map(<span class="function"><span class="params">r</span> =&gt;</span> r + <span class="number">1</span>)  <span class="comment">// Left &#123;value: 1&#125;</span></span><br><span class="line"></span><br><span class="line">Right.of(<span class="number">1</span>).map(<span class="function"><span class="params">r</span> =&gt;</span> r + <span class="number">1</span>) <span class="comment">// Right &#123;value: 2&#125;</span></span><br></pre></td></tr></table></figure><p><code>Left 函子</code>实现代码如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Left</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(value) &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  map(fn) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Left.of = <span class="function"><span class="params">value</span> =&gt;</span> <span class="keyword">new</span> Left(value)</span><br></pre></td></tr></table></figure><p><code>Right 函子</code>实现代码如下(其实就是上面的 <code>Functor</code>):</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Right</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(value) &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  map(fn) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Right(fn(<span class="keyword">this</span>.value))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Right.of = <span class="function"><span class="params">value</span> =&gt;</span> <span class="keyword">new</span> Right(value)</span><br></pre></td></tr></table></figure><p>具体 <code>Either</code> 函数只是对调用 <code>Left 函子</code> 或 <code>Right 函子</code> 作一层筛选, 其接收 <code>f</code>、<code>g</code> 两个函数以及一个函子(<code>Left or Right</code>)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Either = <span class="function"><span class="keyword">function</span>(<span class="params">f, g, functor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span>(functor.constructor) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'Left'</span>:</span><br><span class="line">      <span class="keyword">return</span> f(functor.value)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'Right'</span>:</span><br><span class="line">      <span class="keyword">return</span> g(functor.value)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> f(functor.value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 demo:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Either(<span class="function">(<span class="params">v</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'left'</span>, v), (v) =&gt; <span class="built_in">console</span>.log(<span class="string">'def'</span>, v), left)   <span class="comment">// left 1</span></span><br><span class="line">Either(<span class="function">(<span class="params">v</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'rigth'</span>, v), (v) =&gt; <span class="built_in">console</span>.log(<span class="string">'def'</span>, v), rigth) <span class="comment">// rigth 2</span></span><br></pre></td></tr></table></figure><h4 id="Monad-函子"><a href="#Monad-函子" class="headerlink" title="Monad 函子"></a>Monad 函子</h4><p>函子会发生嵌套, 比如下面这样:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Functor.of(Functor.of(<span class="number">1</span>)) <span class="comment">// Functor &#123; value: Functor &#123; value: 1 &#125; &#125;</span></span><br></pre></td></tr></table></figure><p><code>Monad 函子</code> 对外暴露了 <code>join</code> 和 <code>flatmap</code> 接口, 调用者从而可以扁平化嵌套的函子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Monad</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(value) &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  map(fn) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Monad(fn(<span class="keyword">this</span>.value))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  join() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.value</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  flatmap(fn) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.map(fn).join()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Monad.of = <span class="function"><span class="params">value</span> =&gt;</span> <span class="keyword">new</span> Monad(value)</span><br></pre></td></tr></table></figure><p>使用方法:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// join</span></span><br><span class="line">Monad.of(Monad.of(<span class="number">1</span>).join()) <span class="comment">// Monad &#123; value: 1 &#125;</span></span><br><span class="line">Monad.of(Monad.of(<span class="number">1</span>)).join() <span class="comment">// Monad &#123; value: 1 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// flatmap</span></span><br><span class="line">Monad.of(<span class="number">1</span>).flatmap(<span class="function"><span class="params">r</span> =&gt;</span> r + <span class="number">1</span>)  <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><blockquote><p>Monad 函子可以运用在 I/O 这种不纯的操作上将之变为纯函数的操作，目前比较懵懂，日后补充。</p></blockquote><h3 id="后记-1-数组字符串方法小结-是否对原值有影响"><a href="#后记-1-数组字符串方法小结-是否对原值有影响" class="headerlink" title="后记 1: 数组字符串方法小结(是否对原值有影响)"></a>后记 1: 数组字符串方法小结(是否对原值有影响)</h3><h4 id="不会对原数组有影响的方法"><a href="#不会对原数组有影响的方法" class="headerlink" title="不会对原数组有影响的方法"></a>不会对原数组有影响的方法</h4><h5 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">var</span> result = test.slice(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(test)   <span class="comment">// [1, 2, 3]</span></span><br><span class="line"><span class="built_in">console</span>.log(result) <span class="comment">// [1]</span></span><br></pre></td></tr></table></figure><h5 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">var</span> result = test.concat(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(test)   <span class="comment">// [1, 2, 3]</span></span><br><span class="line"><span class="built_in">console</span>.log(result) <span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure><h4 id="对原数组有影响的方法"><a href="#对原数组有影响的方法" class="headerlink" title="对原数组有影响的方法"></a>对原数组有影响的方法</h4><h5 id="splice-这个需要特别记一下"><a href="#splice-这个需要特别记一下" class="headerlink" title="splice(这个需要特别记一下)"></a>splice(这个需要特别记一下)</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">var</span> result = test.splice(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(test)   <span class="comment">// [2, 3]</span></span><br><span class="line"><span class="built_in">console</span>.log(result) <span class="comment">// [1]</span></span><br></pre></td></tr></table></figure><h5 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">arr.sort(<span class="function">(<span class="params">r1, r2</span>) =&gt;</span> (r1 - r2))</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure><h5 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">var</span> result = test.reverse()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(test)   <span class="comment">// [3, 2, 1]</span></span><br><span class="line"><span class="built_in">console</span>.log(result) <span class="comment">// [3, 2, 1]</span></span><br></pre></td></tr></table></figure><h5 id="push-pop-unshift-shift"><a href="#push-pop-unshift-shift" class="headerlink" title="push/pop/unshift/shift"></a>push/pop/unshift/shift</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">var</span> result = test.push(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(test)   <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"><span class="built_in">console</span>.log(result) <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><h4 id="不会对原字符串造成影响的方法"><a href="#不会对原字符串造成影响的方法" class="headerlink" title="不会对原字符串造成影响的方法"></a>不会对原字符串造成影响的方法</h4><h5 id="substr-substring-slice"><a href="#substr-substring-slice" class="headerlink" title="substr/substring/slice"></a>substr/substring/slice</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// substr</span></span><br><span class="line"><span class="keyword">var</span> test = <span class="string">'abc'</span></span><br><span class="line"><span class="keyword">var</span> result = test.substr(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(test)   <span class="comment">// 'abc'</span></span><br><span class="line"><span class="built_in">console</span>.log(result) <span class="comment">// a</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// substring</span></span><br><span class="line"><span class="keyword">var</span> test = <span class="string">'abc'</span></span><br><span class="line"><span class="keyword">var</span> result = test.substring(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(test)   <span class="comment">// 'abc'</span></span><br><span class="line"><span class="built_in">console</span>.log(result) <span class="comment">// a</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// slice</span></span><br><span class="line"><span class="keyword">var</span> test = <span class="string">'abc'</span></span><br><span class="line"><span class="keyword">var</span> result = test.slice(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(test)   <span class="comment">// 'abc'</span></span><br><span class="line"><span class="built_in">console</span>.log(result) <span class="comment">// a</span></span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://mostly-adequate.gitbooks.io/mostly-adequate-guide" target="_blank" rel="noopener">mostly-adequate-guide</a></li><li><a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese" target="_blank" rel="noopener">JavaScript 函数式编程指南</a></li><li><a href="https://github.com/mqyqingfeng/Blog/issues/42" target="_blank" rel="noopener">JavaScript 专题之函数柯里化</a></li><li><a href="http://www.ruanyifeng.com/blog/2017/02/fp-tutorial.html" target="_blank" rel="noopener">函数式编程入门教程</a></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun May 10 2020 18:57:15 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;&lt;img src=&quot;http://with.muyunyun.cn/aca1db3dd5aaabfbc4351181d1a39df6.jpg-muyy&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;该系列会有 3 篇文章，分别介绍什么是函数式编程、剖析函数式编程库、以及函数式编程在 React 中的应用，欢迎关注我的 &lt;a href=&quot;https://github.com/MuYunyun/blog&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;blog&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="fp" scheme="http://muyunyun.cn/categories/fp/"/>
    
    
      <category term="fp" scheme="http://muyunyun.cn/tags/fp/"/>
    
  </entry>
  
  <entry>
    <title>2018 年度总结 —— 缘见</title>
    <link href="http://muyunyun.cn/posts/24141498/"/>
    <id>http://muyunyun.cn/posts/24141498/</id>
    <published>2019-01-09T01:09:12.000Z</published>
    <updated>2020-01-01T08:54:15.541Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 18:57:14 GMT+0800 (China Standard Time) --><p><img src="http://with.muyunyun.cn/19d9a998a632b464fed6d929326b0271.jpg-muyy" alt=""></p><blockquote><p>度过在点我达两年欢快的时光，开启在拼多多的新的旅程。</p></blockquote><a id="more"></a><h3 id="life"><a href="#life" class="headerlink" title="life"></a>life</h3><p><img src="http://with.muyunyun.cn/cbc85e6d794d9e52b0f60aa6fa18950b.jpg-400" alt=""></p><ul><li>2 月: 在老家的方岩山上跨了年；</li><li>3 月: 和 w 做了过山车；</li><li>4 月：面基了 <a href="https://juejin.im/user/584d7a3e2f301e00572fb7fc" target="_blank" rel="noopener">小小倩</a>; 参加了杭州的草莓音乐节；</li><li>5 月：参加了掘金在杭的线下交流会, 初识<a href="https://juejin.im/user/58f87ae844d9040069ca7507" target="_blank" rel="noopener">染陌</a>、<a href="https://juejin.im/user/58f876dc5c497d0058e38ae1" target="_blank" rel="noopener">阿相</a>、静霞等掘金小伙伴，缘起；</li><li>6 月：和小伙伴们游玩崇明岛，逛了魔都夜景；参加了 GraphQL 的专题技术分享, 和带我入门前端的 scott 老师握了手;</li><li>9 月: 和小伙伴们在浙大玉泉校区参加 nodeparty;</li><li>11 月：面基了刃捷兄，参加了 VueConf；加入<a href="https://github.com/frontend9" target="_blank" rel="noopener">前端九部</a>；期间用脚本叫 r 起床并播报天气预报，脚本坚持了两周;</li><li>12 月：去黄山山顶吃到了热腾腾的泡面; 在 nodeparty 上, 贺老对语言特性的深刻见解只有敬佩。</li><li>1 月：接连两天的 SEE`、d2 大会除了干货满满，俨然成为了追星大会。见到了玉伯、张秋怡等大大的真容，和情封前辈进行了深度交流, 同时和九部的小伙伴也进行了线下聚餐。</li></ul><h3 id="Siren"><a href="#Siren" class="headerlink" title="Siren"></a>Siren</h3><p><code>Siren</code> 是星巴克 <code>Logo</code> 上双尾女海妖的名字。本意是希望星巴克的咖啡就像 <code>Siren</code> 的歌声那样美妙, 除此之外它还有个引申意 —— 克制欲望。</p><p><img src="http://with.muyunyun.cn/aafa6d3e872bb6f9bef26b5ef6d228e5.jpg-400" alt=""></p><p>18 年下半年的周末大多待在下城区金逸影城(也就是 18 年 <code>VueConf</code> 的举办地)的星巴克里看看书之类, 这家星巴克在喧嚣和安静之间保持了恰当好处, 坐在周围的可能是谈论艺术的大学教授，或者是带小朋友做作业的家长，又或者是看书的同学。自由、温馨，时间在这里可快可慢。</p><p><img src="http://with.muyunyun.cn/f9b9be1e727cb817fc78668cc31b3191.jpg-400" alt=""></p><h3 id="18-年-——-见闻色"><a href="#18-年-——-见闻色" class="headerlink" title="18 年 —— 见闻色"></a>18 年 —— 见闻色</h3><p>以下是对 <a href="http://muyunyun.cn/posts/b9cd3f63/">18 年计划</a>的 review</p><table><thead><tr><th align="center">flag</th><th align="center">完成情况</th></tr></thead><tbody><tr><td align="center">对知识点采取思维脑图的方式进行学习</td><td align="center">创建了 <a href="https://github.com/MuYunyun/blog" target="_blank" rel="noopener">blog</a> 项目进行了知识点的整理输出</td></tr><tr><td align="center">参与到一个千星 Star 的开源项目的改善，提高阅读源码的能力，阅读 6 本技术书籍，1 本非技术书籍</td><td align="center">在开源项目的参与深度上有所欠缺, 书籍阅读指标基本达成</td></tr><tr><td align="center">课外学习积累相关方面知识并尝试用到公司项目中</td><td align="center">指标达成</td></tr><tr><td align="center">避免讲话结巴，加强语言组织能力和逻辑能力，没想清楚问题之前不要轻易回答</td><td align="center">沟通交流能力需持续加强</td></tr><tr><td align="center">加强自控能力, 规定的时间做规定的事情，做到按时起睡，不晚于 8 点半起床</td><td align="center">自控能力有所提高，按时起睡指标未达成</td></tr></tbody></table><h3 id="19-年-——-武装色"><a href="#19-年-——-武装色" class="headerlink" title="19 年 —— 武装色"></a>19 年 —— 武装色</h3><ul><li>阅读 5 本技术书籍，1 本非技术书籍，学习函数式编程</li><li>落地一个有价值的项目</li><li>深入 <code>React.js</code> 社区，提一次 pr</li><li>研读 <code>node.js</code> 文档</li><li>提升沟通交流能力, 做一次 party 分享</li><li>请挚友喝星巴克(保底 12 杯)</li></ul><h3 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h3><p>感恩亦师亦友的愚安 boss, 以及给我帮助的点我达小伙伴们; 感激对我给予肯定的刃捷、明江前辈; 感激与我聊到凌晨的兵长兄; 感谢给我提供前行指引的死月、芙兰姐; 感谢掘金社区让我结识了小小倩、染陌、相学长等好友。感谢所有内推、面试过我的前辈, 让我认识到自己的不足。最后感谢所有杭州的朋友们，期待下次更好的遇见！</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun May 10 2020 18:57:14 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;&lt;img src=&quot;http://with.muyunyun.cn/19d9a998a632b464fed6d929326b0271.jpg-muyy&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;度过在点我达两年欢快的时光，开启在拼多多的新的旅程。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Annual Summary" scheme="http://muyunyun.cn/categories/Annual-Summary/"/>
    
    
      <category term="Annual Summary" scheme="http://muyunyun.cn/tags/Annual-Summary/"/>
    
  </entry>
  
  <entry>
    <title>React16.x特性剪辑</title>
    <link href="http://muyunyun.cn/posts/b7beaf79/"/>
    <id>http://muyunyun.cn/posts/b7beaf79/</id>
    <published>2018-11-22T14:21:39.000Z</published>
    <updated>2018-11-26T15:58:19.945Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 18:57:14 GMT+0800 (China Standard Time) --><p><img src="http://with.muyunyun.cn/5fcc4e9364e64a6ab9e082c5d5ab06e8.jpg-muyy" alt=""></p><p>本文整理了 React 16.x 出现的耳目一新的概念与 api 以及应用场景。</p><blockquote><p>更多 React 系列文章可以订阅<a href="https://github.com/MuYunyun/blog" target="_blank" rel="noopener">blog</a></p></blockquote><a id="more"></a><h3 id="16-0-Fiber"><a href="#16-0-Fiber" class="headerlink" title="16.0 Fiber"></a>16.0 Fiber</h3><p>he<br>在 16 之前的版本的渲染过程可以想象成一次性潜水 30 米，在这期间做不了其它事情(Stack Reconciler);</p><p><img src="http://with.muyunyun.cn/39db8e34ec1ce048695c3bde132a739e.jpg-200" alt=""></p><p>痛点概括:</p><ul><li>一次性渲染到底</li><li>中途遇到优先级更高的事件无法调整相应的顺序</li></ul><p>在 16 版本上, React 带来了 Fiber 的架构, 接着拿上面的潜水例子为例，现在变为可以每次潜 10 米，分 3 个 chunk 进行; chunk 和 chunk 之间通过链表连接; chunk 间插入优先级更高的任务, 先前的任务被抛弃。</p><p><img src="http://with.muyunyun.cn/02a6b5ac36b12b3c676157ef3985fe4a.jpg-200" alt=""></p><blockquote><p>开启 Fiber 后，获取异步数据的方法应放到 render 后面的生命周期钩子里(phase 2 阶段)进行, 因为 render 前面的生命周期钩子(phase 1阶段)会被执行多次</p></blockquote><blockquote><p>注意: 并没有缩短原先组件的渲染时间(甚至还加长了)，但用户却能感觉操作变流畅了。</p></blockquote><h3 id="render"><a href="#render" class="headerlink" title="render()"></a>render()</h3><p>在 React16 版本中 render() 增加了一些返回类型，到目前为止支持的返回类型如下：</p><ul><li>React elements.</li><li>Arrays and fragments.</li><li>Portals.</li><li>String and numbers.</li><li>Booleans or null.</li></ul><blockquote><p>[render](<a href="https://reactjs.org/docs/react-component.html#render]" target="_blank" rel="noopener">https://reactjs.org/docs/react-component.html#render]</a></p></blockquote><p>其中 render() 支持返回 Arrays 能让我们少写一个父节点, 如下所示:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> renderArray = <span class="function"><span class="params">()</span> =&gt;</span> [</span><br><span class="line">  &lt;div&gt;A&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  &lt;div&gt;B&lt;/</span>div&gt;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><blockquote><p>个人认为 render() 支持返回数组完全可以取代 <a href="https://reactjs.org/docs/fragments.html" target="_blank" rel="noopener">Fragments</a></p></blockquote><h3 id="Portals-传送门"><a href="#Portals-传送门" class="headerlink" title="Portals(传送门)"></a>Portals(传送门)</h3><p>将 react 子节点渲染到指定的节点上</p><p>案例：实现一个 Modal 组件，<a href="https://codepen.io/gaearon/pen/yzMaBd" target="_blank" rel="noopener">demo</a></p><p>另外关于 Portals 做到冒泡到父节点的兄弟节点这个现象, <a href="https://codepen.io/gaearon/pen/jGBWpE" target="_blank" rel="noopener">demo</a>, 我想可以这样子实现：如果组件返回是 Portal 对象，则将该组件的父组件的上的事件 copy 到该组件上。其实并不是真的冒泡到了父节点的兄弟节点上。</p><h3 id="Error-Boundaries"><a href="#Error-Boundaries" class="headerlink" title="Error Boundaries"></a>Error Boundaries</h3><p>React 16 提供了一个新的错误捕获钩子 <code>componentDidCatch(error, errorInfo)</code>, 它能将子组件生命周期里所抛出的错误捕获, 防止页面全局崩溃。<a href="https://codepen.io/gaearon/pen/wqvxGa?editors=0010" target="_blank" rel="noopener">demo</a></p><p>componentDidCatch 并不会捕获以下几种错误</p><ul><li>事件机制抛出的错误(事件里的错误并不会影响渲染)</li><li>Error Boundaries 自身抛出的错误</li><li>异步产生的错误</li><li>服务端渲染</li></ul><h3 id="服务端渲染"><a href="#服务端渲染" class="headerlink" title="服务端渲染"></a>服务端渲染</h3><p>服务端渲染一般是作为最后的优化手段, 这里浅显(缺乏经验)谈下 React 16 在其上的优化。</p><p>在 React 16 版本中引入了 <code>React.hydrate()</code>, 它的作用主要是将相关的事件<code>注水</code>进 <code>html</code> 页面中, 同时会比较前端生成的 <code>html</code> 和服务端传到前端的 <code>html</code> 的文本内容的差异, 如果两者不一致将前端产生的文本内容替换服务端生成的(忽略属性)。</p><h3 id="支持自定义属性"><a href="#支持自定义属性" class="headerlink" title="支持自定义属性"></a>支持自定义属性</h3><p>在 React 16 版本中, 支持自定义属性(推荐 <code>data-xxx</code>), 因而 React 可以少维护一份 attribute 白名单, 这也是 React 16 体积减少的一个重要因素。</p><h3 id="life-cycle"><a href="#life-cycle" class="headerlink" title="life cycle"></a>life cycle</h3><p>在 React 16.3 的版本中，新加入了两个生命周期：</p><ul><li><p><code>getDerivedStateFromProps(nextProps, prevState)</code>: 更加语义化, 用来替代 componentWillMount、componentWillReceiveProps(nextProps);</p></li><li><p><code>getSnapshotBeforeUpdate(prevProps, prevState)</code>: 可以将结果传入 componentDidUpdate 里, 从而达到 dom 数据统一。用来替代 componentWillUpdate()（缺点是 React 开启异步渲染后，componentWillUpdate() 与 componentDidUpdate() 间获取的 dom 会不统一;</p></li></ul><h3 id="16-7-Hooks"><a href="#16-7-Hooks" class="headerlink" title="16.7 Hooks"></a>16.7 Hooks</h3><p>在 React 16.7 之前，React 有两种形式的组件，有状态组件(类)和无状态组件(函数)。Hooks 的意义就是赋能先前的无状态组件，让之变为有状态。这样一来更加契合了 React 所推崇的函数式编程。</p><p>接下来梳理 Hooks 中最核心的 2 个 api, <code>useState</code> 和 <code>useEffect</code></p><h4 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h4><p>useState 返回状态和一个更新状态的函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [count, setCount] = useState(initialState)</span><br></pre></td></tr></table></figure><p>使用 Hooks 相比之前用 class 的写法最直观的感受是更为简洁</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;</span></span><br><span class="line"><span class="regexp">        Click me</span></span><br><span class="line"><span class="regexp">      &lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="useEffect-fn"><a href="#useEffect-fn" class="headerlink" title="useEffect(fn)"></a>useEffect(fn)</h4><p>在每次 render 后都会执行这个钩子。可以将它当成是 <code>componentDidMount</code>、<code>componentDidUpdate</code>、<code>componentWillUnmount</code> 的合集。因此使用 useEffect 比之前优越的地方在于：</p><ol><li>可以避免在 <code>componentDidMount、componentDidUpdate</code> 书写重复的代码;</li><li>可以将关联逻辑写进一个 <code>useEffect</code>;(在以前得写进不同生命周期里);</li></ol><blockquote><p>在上述提到的生命周期钩子之外，其它的钩子是否在 hooks 也有对应的方案或者舍弃了其它生命周期钩子, 后续进行观望。</p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun May 10 2020 18:57:14 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;&lt;img src=&quot;http://with.muyunyun.cn/5fcc4e9364e64a6ab9e082c5d5ab06e8.jpg-muyy&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;本文整理了 React 16.x 出现的耳目一新的概念与 api 以及应用场景。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;更多 React 系列文章可以订阅&lt;a href=&quot;https://github.com/MuYunyun/blog&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;blog&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="React" scheme="http://muyunyun.cn/categories/React/"/>
    
    
      <category term="React" scheme="http://muyunyun.cn/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>解读 IoC 框架 InversifyJS</title>
    <link href="http://muyunyun.cn/posts/73be8760/"/>
    <id>http://muyunyun.cn/posts/73be8760/</id>
    <published>2018-11-07T07:20:30.000Z</published>
    <updated>2018-11-26T14:48:20.563Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 18:57:15 GMT+0800 (China Standard Time) --><p><img src="http://with.muyunyun.cn/dacdda6b87f5e7acc3ffc74759f97360.jpg-muyy" alt=""></p><p>InversityJS 是一个 IoC 框架。IoC(Inversion of Control) 包括依赖注入(Dependency Injection) 和依赖查询(Dependency Lookup)。</p><p>相比于类继承的方式，控制反转解耦了父类和子类的联系。</p><a id="more"></a><h3 id="案例解析"><a href="#案例解析" class="headerlink" title="案例解析"></a>案例解析</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'reflect-metadata'</span></span><br><span class="line"><span class="keyword">import</span> &#123; inject, injectable, Container &#125; <span class="keyword">from</span> <span class="string">'inversify'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> container = <span class="keyword">new</span> Container()</span><br><span class="line"></span><br><span class="line"><span class="meta">@injectable</span>()</span><br><span class="line"><span class="keyword">class</span> PopMusic &#123;</span><br><span class="line">  getName() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'流行音乐'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">container.bind(<span class="string">'request1'</span>).to(PopMusic)</span><br><span class="line"></span><br><span class="line"><span class="meta">@injectable</span>()</span><br><span class="line"><span class="keyword">class</span> ClassicalMusic &#123;</span><br><span class="line">  getName() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'古典音乐'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">container.bind(<span class="string">'request2'</span>).to(ClassicalMusic)</span><br><span class="line"></span><br><span class="line"><span class="meta">@injectable</span>()</span><br><span class="line"><span class="keyword">class</span> Music &#123;</span><br><span class="line">  pm: <span class="built_in">any</span></span><br><span class="line">  cm: <span class="built_in">any</span></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span></span><br><span class="line"><span class="params">    <span class="meta">@inject</span>(<span class="string">'request1'</span>) popMusic: <span class="built_in">any</span>,</span></span><br><span class="line"><span class="params">    <span class="meta">@inject</span>(<span class="string">'request2'</span>) classicalMusic: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.pm = popMusic</span><br><span class="line">    <span class="keyword">this</span>.cm = classicalMusic</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getName() &#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">this</span>.pm.getName() + <span class="keyword">this</span>.cm.getName()</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">container.bind(<span class="string">'Plan'</span>).to(Music)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> music: <span class="built_in">any</span> = container.get(<span class="string">'Plan'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(music.getName()) <span class="comment">// 流行音乐古典音乐</span></span><br></pre></td></tr></table></figure><p>上述案例可以抽象为下图：</p><p><img src="http://with.muyunyun.cn/8a9ccba28d00ea0c752c3601d716ebcd.jpg-400" alt=""></p><blockquote><p>虚线表示可以注入，但在代码中没有表现出来。</p></blockquote><p>代码流程可概括如下：</p><p>1.将所有相关类(这里指 Music、popMusic、classicMusic) 通过 <code>@injectable</code> 声明进 <code>container</code> 容器;</p><p>2.通过 <code>container.get()</code> 获取 <code>container.bind().to(target)</code> 中的目标对象(这里指 Music);</p><p>3.如果目标对象中的 constructor() 里有 <code>@inject()</code>, 则将相应的实例(这里指 PopMusic 与 classicalMusic 的实例)当作构造函数的参数’注入’;</p><h3 id="inject-injectable-相关源码"><a href="#inject-injectable-相关源码" class="headerlink" title="inject/injectable 相关源码"></a>inject/injectable 相关源码</h3><p>inject 源码简化如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一个属性装饰器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inject</span>(<span class="params">serviceIdentifier</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target, targetKey</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> metadataValue = &#123; [targetKey]: [Metadata &#123; <span class="attr">key</span>: <span class="string">'inject'</span>, <span class="attr">value</span>: serviceIdentifier &#125;)] &#125;</span><br><span class="line">    <span class="built_in">Reflect</span>.defineMetadata(<span class="string">'inversify:tagged_props'</span>, metadataValue, target.constructor);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>injectable 源码简化如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是一个类装饰器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">injectable</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> metadataValue = []</span><br><span class="line">    <span class="built_in">Reflect</span>.defineMetadata(<span class="string">'inversify:paramtypes'</span>, metadataValue, target)</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从简化版源码中可以看到 inject/injectable 最终是对 <code>Reflect.defineMetadata()</code> 的一个使用。可以将 metadata 看成是一种相对高效的数据结构。</p><h4 id="reflect-metadata"><a href="#reflect-metadata" class="headerlink" title="reflect-metadata"></a>reflect-metadata</h4><p>InversityJS 深度结合了 <a href="https://github.com/rbuckton/reflect-metadata" target="_blank" rel="noopener">reflect-metadata</a>, reflect-metadata 在 Reflect 基础上对其 api 进行了扩展。</p><blockquote><p>metadata 本质上是一个 <code>WeakMap</code> 对象。扩展：<a href="https://github.com/MuYunyun/blog/blob/master/BasicSkill/algorithm/字典.md#map-和-weakmap-的区别" target="_blank" rel="noopener">Map 和 WeakMap 的区别</a></p></blockquote><p><code>Reflect.defineMetadata(metadataKey, metadataValue, target[, propertyKey])</code> 简化版实现如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Metadata = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineMetadata</span>(<span class="params">metadataKey, metadataValue, target, propertyKey</span>) </span>&#123;</span><br><span class="line">  metadataMap = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">  metadataMap.set(metadataKey, metadataValue)</span><br><span class="line">  targetMetadata = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">  targetMetadata.set(propertyKey, metadataMap)</span><br><span class="line">  Metadata.set(target, targetMetadata)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Reflect.getOwnMetadata(metadataKey, target[, propertyKey])</code> 简化版实现如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getOwnMetadata</span>(<span class="params">metadataKey, target, propertyKey</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> targetMetadata = Metadata.get(target)</span><br><span class="line">  <span class="keyword">var</span> metadataMap = targetMetadata.get(propertyKey)</span><br><span class="line">  <span class="keyword">return</span> metadataMap.get(metadataKey)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其数据结构可表示如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">WeakMap</span> &#123;</span><br><span class="line">  target: <span class="built_in">Map</span> &#123;</span><br><span class="line">    propertyKey: <span class="built_in">Map</span> &#123;</span><br><span class="line">      metadataKey: metadataValue</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li><a href="https://github.com/inversify/InversifyJS/blob/master/wiki/architecture.md" target="_blank" rel="noopener">Architecture overview</a></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun May 10 2020 18:57:15 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;&lt;img src=&quot;http://with.muyunyun.cn/dacdda6b87f5e7acc3ffc74759f97360.jpg-muyy&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;InversityJS 是一个 IoC 框架。IoC(Inversion of Control) 包括依赖注入(Dependency Injection) 和依赖查询(Dependency Lookup)。&lt;/p&gt;&lt;p&gt;相比于类继承的方式，控制反转解耦了父类和子类的联系。&lt;/p&gt;
    
    </summary>
    
    
      <category term="IoC" scheme="http://muyunyun.cn/categories/IoC/"/>
    
    
      <category term="设计模式" scheme="http://muyunyun.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>探寻 JavaScript 精度问题</title>
    <link href="http://muyunyun.cn/posts/49fa8af8/"/>
    <id>http://muyunyun.cn/posts/49fa8af8/</id>
    <published>2018-10-03T08:04:01.000Z</published>
    <updated>2018-11-26T14:48:20.564Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 18:57:15 GMT+0800 (China Standard Time) --><p>阅读完本文可以了解到 <code>0.1 + 0.2</code> 为什么等于 <code>0.30000000000000004</code> 以及 JavaScript 中最大安全数是如何来的。</p><a id="more"></a><h3 id="十进制小数转为二进制小数方法"><a href="#十进制小数转为二进制小数方法" class="headerlink" title="十进制小数转为二进制小数方法"></a>十进制小数转为二进制小数方法</h3><p>拿 173.8125 举例如何将之转化为二进制小数。</p><p>①. 针对整数部分 173，采取<code>除 2 取余，逆序排列</code>;</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">173</span> / <span class="number">2</span> = <span class="number">86</span> ... <span class="number">1</span></span><br><span class="line"><span class="number">86</span> / <span class="number">2</span> = <span class="number">43</span> ... <span class="number">0</span></span><br><span class="line"><span class="number">43</span> / <span class="number">2</span> = <span class="number">21</span> ... <span class="number">1</span>   ↑</span><br><span class="line"><span class="number">21</span> / <span class="number">2</span> = <span class="number">10</span> ... <span class="number">1</span>   | 逆序排列</span><br><span class="line"><span class="number">10</span> / <span class="number">2</span> = <span class="number">5</span> ... <span class="number">0</span>    |</span><br><span class="line"><span class="number">5</span> / <span class="number">2</span> = <span class="number">2</span> ... <span class="number">1</span>     |</span><br><span class="line"><span class="number">2</span> / <span class="number">2</span> = <span class="number">1</span> ... <span class="number">0</span></span><br><span class="line"><span class="number">1</span> / <span class="number">2</span> = <span class="number">0</span> ... <span class="number">1</span></span><br></pre></td></tr></table></figure><p>得整数部分的二进制为 <code>10101101</code>。</p><p>②. 针对小数部分 0.8125，采用<code>乘 2 取整，顺序排列</code>;</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.8125</span> * <span class="number">2</span> = <span class="number">1.625</span>  |</span><br><span class="line"><span class="number">0.625</span> * <span class="number">2</span> = <span class="number">1.25</span>    | 顺序排列</span><br><span class="line"><span class="number">0.25</span> * <span class="number">2</span> = <span class="number">0.5</span>      |</span><br><span class="line"><span class="number">0.5</span> * <span class="number">2</span> = <span class="number">1</span>         ↓</span><br></pre></td></tr></table></figure><p>得小数部分的二进制为 <code>1101</code>。</p><p>③. 将前面两部的结果相加，结果为 <code>10101101.1101</code>;</p><h3 id="小心，二进制小数丢失了精度！"><a href="#小心，二进制小数丢失了精度！" class="headerlink" title="小心，二进制小数丢失了精度！"></a>小心，二进制小数丢失了精度！</h3><p>根据上面的知识，将十进制小数 <code>0.1</code> 转为二进制：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.1</span> * <span class="number">2</span> = <span class="number">0.2</span></span><br><span class="line"><span class="number">0.2</span> * <span class="number">2</span> = <span class="number">0.4</span> <span class="comment">// 注意这里</span></span><br><span class="line"><span class="number">0.4</span> * <span class="number">2</span> = <span class="number">0.8</span></span><br><span class="line"><span class="number">0.8</span> * <span class="number">2</span> = <span class="number">1.6</span></span><br><span class="line"><span class="number">0.6</span> * <span class="number">2</span> = <span class="number">1.2</span></span><br><span class="line"><span class="number">0.2</span> * <span class="number">2</span> = <span class="number">0.4</span> <span class="comment">// 注意这里，循环开始</span></span><br><span class="line"><span class="number">0.4</span> * <span class="number">2</span> = <span class="number">0.8</span></span><br><span class="line"><span class="number">0.8</span> * <span class="number">2</span> = <span class="number">1.6</span></span><br><span class="line"><span class="number">0.6</span> * <span class="number">2</span> = <span class="number">1.2</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>可以发现有限十进制小数 <code>0.1</code> 却转化成了无限二进制小数 <code>0.00011001100...</code>，可以看到精度在转化过程中丢失了！</p><p>能被转化为有限二进制小数的十进制小数的最后一位必然以 5 结尾(因为只有 0.5 * 2 才能变为整数)。所以十进制中一位小数 <code>0.1 ~ 0.9</code> 当中除了 <code>0.5</code> 之外的值在转化成二进制的过程中都丢失了精度。</p><h3 id="推导-0-1-0-2-为何等于-0-30000000000000004"><a href="#推导-0-1-0-2-为何等于-0-30000000000000004" class="headerlink" title="推导 0.1 + 0.2 为何等于 0.30000000000000004"></a>推导 0.1 + 0.2 为何等于 0.30000000000000004</h3><p>在 JavaScript 中所有数值都以 IEEE-754 标准的 <code>64 bit</code> 双精度浮点数进行存储的。先来了解下 IEEE-754 标准下的<a href="https://zh.wikipedia.org/wiki/%E9%9B%99%E7%B2%BE%E5%BA%A6%E6%B5%AE%E9%BB%9E%E6%95%B8" target="_blank" rel="noopener">双精度浮点数</a>。</p><p><img src="http://with.muyunyun.cn/dda7d5b38676abfa13afb344f8a792ed.jpg-300" alt=""></p><p>这幅图很关键，可以从图中看到 IEEE-754 标准下双精度浮点数由三部分组成，分别如下：</p><ul><li>sign(符号): 占 1 bit, 表示正负;</li><li>exponent(指数): 占 11 bit，表示范围;</li><li>mantissa(尾数): 占 52 bit，表示精度，多出的末尾如果是 1 需要进位;</li></ul><p>推荐阅读 <a href="https://github.com/camsong/blog/issues/9" target="_blank" rel="noopener">JavaScript 浮点数陷阱及解法</a>，阅读完该文后可以了解到以下公式的由来。</p><p><img src="http://with.muyunyun.cn/5c268e4bd6e0bf2466598d9d5cb58a16.jpg-200" alt=""></p><blockquote><p>精度位总共是 53 bit，因为用科学计数法表示，所以首位固定的 1 就没有占用空间。即公式中 (M + 1) 里的 1。另外公式里的 1023 是 2^11 的一半。小于 1023 的用来表示小数，大于 1023 的用来表示整数。</p></blockquote><blockquote><p>指数可以控制到 2^1024 - 1，而精度最大只达到 2^53 - 1，两者相比可以得出 JavaScript 实际可以精确表示的数字其实很少。</p></blockquote><p><code>0.1</code> 转化为二进制为 <code>0.0001100110011...</code>，用科学计数法表示为 <code>1.100110011... x 2^(-4)</code>，根据上述公式，<code>S</code> 为 <code>0</code>(1 bit)，<code>E</code> 为 <code>-4 + 1023</code>，对应的二进制为 <code>01111111011</code>(11 bit)，<code>M</code> 为 <code>1001100110011001100110011001100110011001100110011010</code>(52 bit，另外注意末尾的进位)，<code>0.1</code> 的存储示意图如下:</p><p><img src="http://with.muyunyun.cn/5b7c0dcc0b1770b6eed238e288eb4c0e.jpg-300" alt=""></p><p>同理，<code>0.2</code> 转化为二进制为 <code>0.001100110011...</code>，用科学计数法表示为 <code>1.100110011... x 2^(-3)</code>，根据上述公式，<code>E</code> 为 <code>-3 + 1023</code>，对应的二进制为 <code>01111111100</code>, <code>M</code> 为 <code>1001100110011001100110011001100110011001100110011010</code>, <code>0.2</code> 的存储示意图如下:</p><p><img src="http://with.muyunyun.cn/cb0ef89aa0ed6e8d32b90d1a29cfc9e1.jpg-300" alt=""></p><p><code>0.1 + 0.2</code> 即 2^(-4) x 1.1001100110011001100110011001100110011001100110011010 与 2^(-3) x 1.1001100110011001100110011001100110011001100110011010 之和</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算过程</span></span><br><span class="line"><span class="number">0.00011001100110011001100110011001100110011001100110011010</span></span><br><span class="line"><span class="number">0.0011001100110011001100110011001100110011001100110011010</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 相加得</span></span><br><span class="line"><span class="number">0.01001100110011001100110011001100110011001100110011001110</span></span><br></pre></td></tr></table></figure><p><code>0.01001100110011001100110011001100110011001100110011001110</code> 转化为十进制就是 <code>0.30000000000000004</code>。验证完成!</p><h3 id="JavaScript-的最大安全数是如何来的"><a href="#JavaScript-的最大安全数是如何来的" class="headerlink" title="JavaScript 的最大安全数是如何来的"></a>JavaScript 的最大安全数是如何来的</h3><p>根据双精度浮点数的构成，精度位数是 <code>53 bit</code>。安全数的意思是在 <code>-2^53 ~ 2^53</code> 内的整数(不包括边界)与唯一的双精度浮点数互相对应。举个例子比较好理解：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) === <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) + <span class="number">1</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><code>Math.pow(2, 53)</code> 竟然与 <code>Math.pow(2, 53) + 1</code> 相等！这是因为 Math.pow(2, 53) + 1 已经超过了尾数的精度限制(53 bit)，在这个例子中 <code>Math.pow(2, 53)</code> 和 <code>Math.pow(2, 53) + 1</code> 对应了同一个双精度浮点数。所以 <code>Math.pow(2, 53)</code> 就不是安全数了。</p><blockquote><p>最大的安全数为 <code>Math.pow(2, 53) - 1</code>，即 <code>9007199254740991</code>。</p></blockquote><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li><a href="http://justjavac.com/codepuzzle/2012/11/11/codepuzzle-float-who-stole-your-accuracy.html" target="_blank" rel="noopener">代码之谜系列</a></li><li><a href="http://www.binaryconvert.com/convert_double.html" target="_blank" rel="noopener">IEEE-754 进制转换图生成</a></li><li><a href="https://github.com/camsong/blog/issues/9" target="_blank" rel="noopener">JavaScript 浮点数陷阱及解法</a>: 推荐阅读</li><li><a href="https://www.zhihu.com/question/29010688" target="_blank" rel="noopener">javascript 里最大的安全的整数为什么是2的53次方减一</a></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun May 10 2020 18:57:15 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;阅读完本文可以了解到 &lt;code&gt;0.1 + 0.2&lt;/code&gt; 为什么等于 &lt;code&gt;0.30000000000000004&lt;/code&gt; 以及 JavaScript 中最大安全数是如何来的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScrip" scheme="http://muyunyun.cn/categories/JavaScrip/"/>
    
      <category term="精度" scheme="http://muyunyun.cn/categories/JavaScrip/%E7%B2%BE%E5%BA%A6/"/>
    
    
      <category term="JavaScript" scheme="http://muyunyun.cn/tags/JavaScript/"/>
    
      <category term="精度" scheme="http://muyunyun.cn/tags/%E7%B2%BE%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>从 0 到 1 实现 React 系列 —— 6.onChange 事件以及受控组件</title>
    <link href="http://muyunyun.cn/posts/da72b66c/"/>
    <id>http://muyunyun.cn/posts/da72b66c/</id>
    <published>2018-09-18T08:00:25.000Z</published>
    <updated>2018-11-26T14:48:20.566Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 18:57:15 GMT+0800 (China Standard Time) --><p><img src="http://with.muyunyun.cn/9c461a61924ed0fecb6024a256671251.jpg-muyy" alt=""></p><p>本系列文章在实现一个 cpreact 的同时帮助大家理顺 React 框架的核心内容(JSX/虚拟DOM/组件/生命周期/diff算法/setState/PureComponent/HOC/…) <a href="https://github.com/MuYunyun/cpreact" target="_blank" rel="noopener">项目地址</a></p><a id="more"></a><h3 id="从一个疑问点开始"><a href="#从一个疑问点开始" class="headerlink" title="从一个疑问点开始"></a>从一个疑问点开始</h3><p>接上一章 <a href="https://github.com/MuYunyun/blog/blob/master/从0到1实现React/8.HOC探索.md#属性代理props-proxy" target="_blank" rel="noopener">HOC 探索</a> 抛出的问题 ———— react 中的 onChange 事件和原生 DOM 事件中的 onchange 表现不一致，举例说明如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// React 中的 onChange 事件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.onChange = <span class="keyword">this</span>.onChange.bind(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  onChange(e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'键盘松开立刻执行'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;input onChange=&#123;<span class="keyword">this</span>.onChange&#125; /&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*--------------分割线---------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 原生 DOM 事件中的 onchange 事件：&lt;input id='test'&gt;</span></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'test'</span>).addEventListener(<span class="string">'change'</span>, (e) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'键盘松开以后还需按下回车键或者点下鼠标才会触发'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="拨云见雾"><a href="#拨云见雾" class="headerlink" title="拨云见雾"></a>拨云见雾</h3><p>我们来看下 React 的一个 issue <a href="https://github.com/facebook/react/issues/13525" target="_blank" rel="noopener">React Fire: Modernizing React DOM</a>。有两点信息和这篇文章的话题相关。</p><ul><li>Drastically simplify the event system</li><li>Migrate from onChange to onInput and don’t polyfill it for uncontrolled components</li></ul><p>从这两点内容我们可以得知下面的信息：</p><p>React 实现了一套<a href="https://reactjs.org/docs/events.html#event-pooling" target="_blank" rel="noopener">合成事件机制</a>，也就是它的事件机制和原生事件间会有不同。比如它目前 onChange 事件其实对应着原生事件中的 input 事件。在这个 issue 中明确了未来会使用 onInput 事件替代 onChange 事件，并且会大幅度地简化合成事件。</p><p>有了以上信息后，我们对 onChange 事件(将来的 onInput 事件)的代码作如下更改：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setAttribute</span>(<span class="params">dom, attr, value</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (attr.match(<span class="regexp">/on\w+/</span>)) &#123;        <span class="comment">// 处理事件的属性:</span></span><br><span class="line">    <span class="keyword">let</span> eventName = attr.toLowerCase().substr(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> (eventName === <span class="string">'change'</span>) &#123; eventName = <span class="string">'input'</span> &#125; <span class="comment">// 和现阶段的 react 统一</span></span><br><span class="line">    dom.addEventListener(eventName, value)</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自由组件以及受控组件"><a href="#自由组件以及受控组件" class="headerlink" title="自由组件以及受控组件"></a>自由组件以及受控组件</h3><p>区分自由组件以及受控组件在于表单的值是否由 <code>value</code> 这个属性控制，比较如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> case1 = <span class="function"><span class="params">()</span> =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> /&gt;</span></span>                    <span class="comment">// 此时输入框内可以随意增减任意值</span></span><br><span class="line"><span class="keyword">const</span> case2 = <span class="function"><span class="params">()</span> =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">defaultValue</span>=<span class="string">&#123;123&#125;</span> /&gt;</span></span> <span class="comment">// 此时输入框内显示 123，能随意增减值</span></span><br><span class="line"><span class="keyword">const</span> case3 = <span class="function"><span class="params">()</span> =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">&#123;123&#125;</span> /&gt;</span></span>        <span class="comment">// 此时输入框内显示 123，并且不能随意增减值</span></span><br></pre></td></tr></table></figure><p><code>case3</code> 的情形即为简化版的受控组件。</p><h3 id="受控组件的实现"><a href="#受控组件的实现" class="headerlink" title="受控组件的实现"></a>受控组件的实现</h3><p>题目可以换个问法：当 <code>input</code> 的传入属性为 <code>value</code> 时(且没有 onChange 属性)，如何禁用用户的输入事件的同时又能获取焦点?</p><p><img src="http://with.muyunyun.cn/0fa301946b3f4bf315d742735c333562.jpg-200" alt=""></p><p>首先想到了 html 自带属性 readonly、disable，它们都能禁止用户的输入，但是它们不能满足获取焦点这个条件。结合前文 <code>onChange</code> 的实现是监听 <code>input</code> 事件，代码分为以下两种情况：</p><p>1.dom 节点包含 <code>value</code> 属性、<code>onChange</code> 属性<br>2.dom 节点包含 <code>value</code> 属性，不包含 <code>onChange</code> 属性</p><p>代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">vdomToDom</span>(<span class="params">vdom</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (vdom.attributes</span><br><span class="line">    &amp;&amp; vdom.attributes.hasOwnProperty(<span class="string">'onChange'</span>)</span><br><span class="line">    &amp;&amp; vdom.attributes.hasOwnProperty(<span class="string">'value'</span>)) &#123; <span class="comment">// 受控组件逻辑</span></span><br><span class="line">      ...</span><br><span class="line">      dom.addEventListener(<span class="string">'input'</span>, (e) =&gt; &#123;</span><br><span class="line">        changeCb.call(<span class="keyword">this</span>, e)</span><br><span class="line">        dom.value = oldValue</span><br><span class="line">      &#125;)</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (vdom.attributes</span><br><span class="line">    &amp;&amp; !vdom.attributes.hasOwnProperty(<span class="string">'onChange'</span>)</span><br><span class="line">    &amp;&amp; vdom.attributes.hasOwnProperty(<span class="string">'value'</span>)) &#123; <span class="comment">// 受控组件逻辑</span></span><br><span class="line">    ...</span><br><span class="line">    dom.addEventListener(<span class="string">'input'</span>, (e) =&gt; &#123;</span><br><span class="line">      dom.value = oldValue</span><br><span class="line">    &#125;)</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现它们的核心都在这段代码上：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dom.addEventListener(<span class="string">'input'</span>, (e) =&gt; &#123;</span><br><span class="line">  changeCb.call(<span class="keyword">this</span>, e)</span><br><span class="line">  dom.value = oldValue</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>区别是当有 <code>onChange 属性</code> 时，能提供相应的回调函数 <code>changeCb</code> 通过事件循环机制改变表单的值。看如下两个例子的比较：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">&#123;123&#125;</span> /&gt;</span></span></span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="http://with.muyunyun.cn/353c8119b3c60a7f8f7696633c97ad28.jpg-200" alt=""></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>()</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">num</span>: <span class="number">123</span> &#125;</span><br><span class="line">    <span class="keyword">this</span>.change = <span class="keyword">this</span>.change.bind(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  change(e) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      num: e.target.value</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input value=&#123;<span class="keyword">this</span>.state.num&#125; onChange=&#123;<span class="keyword">this</span>.change&#125; /&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>这段代码中的 <code>change</code> 函数即上个段落所谓的 <code>changeCb</code> 函数，通过 <code>setState</code> 的事件循环机制改变表单的值。</p><p>效果如下：</p><p><img src="http://with.muyunyun.cn/aec70ef0cebf603a0871d61f21e93532.gif" alt=""></p><p>至此，模拟了受控组件的实现。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun May 10 2020 18:57:15 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;&lt;img src=&quot;http://with.muyunyun.cn/9c461a61924ed0fecb6024a256671251.jpg-muyy&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;本系列文章在实现一个 cpreact 的同时帮助大家理顺 React 框架的核心内容(JSX/虚拟DOM/组件/生命周期/diff算法/setState/PureComponent/HOC/…) &lt;a href=&quot;https://github.com/MuYunyun/cpreact&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;项目地址&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="React" scheme="http://muyunyun.cn/categories/React/"/>
    
    
      <category term="React" scheme="http://muyunyun.cn/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>从 0 到 1 实现 React 系列 —— 5.PureComponent 实现 &amp;&amp; HOC 探幽</title>
    <link href="http://muyunyun.cn/posts/92dc08c6/"/>
    <id>http://muyunyun.cn/posts/92dc08c6/</id>
    <published>2018-08-27T03:39:06.000Z</published>
    <updated>2018-11-26T14:48:20.564Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 18:57:15 GMT+0800 (China Standard Time) --><p><img src="http://with.muyunyun.cn/9c461a61924ed0fecb6024a256671251.jpg-muyy" alt=""></p><p>本系列文章在实现一个 cpreact 的同时帮助大家理顺 React 框架的核心内容(JSX/虚拟DOM/组件/生命周期/diff算法/setState/PureComponent/HOC/…) <a href="https://github.com/MuYunyun/cpreact" target="_blank" rel="noopener">项目地址</a></p><a id="more"></a><ul><li><a href="https://github.com/MuYunyun/blog/issues/24" target="_blank" rel="noopener">从 0 到 1 实现 React 系列 —— JSX 和 Virtual DOM</a></li><li><a href="https://github.com/MuYunyun/blog/issues/25" target="_blank" rel="noopener">从 0 到 1 实现 React 系列 —— 组件和 state|props</a></li><li><a href="https://github.com/MuYunyun/blog/issues/26" target="_blank" rel="noopener">从 0 到 1 实现 React 系列 —— 生命周期和 diff 算法</a></li><li><a href="https://github.com/MuYunyun/blog/issues/27" target="_blank" rel="noopener">从 0 到 1 实现 React 系列 —— 优化 setState 和 ref 的实现</a></li><li><a href="https://github.com/MuYunyun/blog/issues/29" target="_blank" rel="noopener">从 0 到 1 实现 React 系列 —— PureComponent 实现 &amp;&amp; HOC 探幽</a></li></ul><h3 id="PureComponent-精髓"><a href="#PureComponent-精髓" class="headerlink" title="PureComponent 精髓"></a>PureComponent 精髓</h3><p>使用 PureComponent 是优化 React 性能的一种常用手段，相较于 Component, PureComponent 会在 render 之前自动执行一次 shouldComponentUpdate() 函数，根据返回的 bool 值判断是否进行 render。其中有个重点是 PureComponent 在 shouldComponentUpdate() 的时候会进行 shallowEqual(浅比较)。</p><p>PureComponent 的浅比较策略如下：</p><p>对 prevState/nextState 以及 prevProps/nextProps 这两组数据进行浅比较：</p><p>1.对象第一层数据未发生改变，render 方法不会触发；<br>2.对象第一层数据发生改变(包括第一层数据引用的改变)，render 方法会触发;</p><h4 id="PureComponent-的实现"><a href="#PureComponent-的实现" class="headerlink" title="PureComponent 的实现"></a>PureComponent 的实现</h4><p>照着上述思路我们来实现 PureComponent 的逻辑</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PureComponent</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.props = props || &#123;&#125;</span><br><span class="line">  <span class="keyword">this</span>.state = &#123;&#125;</span><br><span class="line"></span><br><span class="line">  isShouldComponentUpdate.call(<span class="keyword">this</span>) <span class="comment">// 为每个 PureComponent 绑定 shouldComponentUpdate 方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PureComponent.prototype.setState = <span class="function"><span class="keyword">function</span>(<span class="params">updater, cb</span>) </span>&#123;</span><br><span class="line">  isShouldComponentUpdate.call(<span class="keyword">this</span>) <span class="comment">// 调用 setState 时，让 this 指向子类的实例，目的取到子类的 this.state</span></span><br><span class="line">  asyncRender(updater, <span class="keyword">this</span>, cb)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isShouldComponentUpdate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> cpState = <span class="keyword">this</span>.state</span><br><span class="line">  <span class="keyword">const</span> cpProps = <span class="keyword">this</span>.props</span><br><span class="line">  <span class="keyword">this</span>.shouldComponentUpdate = <span class="function"><span class="keyword">function</span> (<span class="params">nextProps, nextState</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!shallowEqual(cpState, nextState) || !shallowEqual(cpProps, nextProps)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>  <span class="comment">// 只要 state 或 props 浅比较不等的话，就进行渲染</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span> <span class="comment">// 浅比较相等的话，不渲染</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 浅比较逻辑</span></span><br><span class="line"><span class="keyword">const</span> shallowEqual = <span class="function"><span class="keyword">function</span>(<span class="params">oldState, nextState</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> oldKeys = <span class="built_in">Object</span>.keys(oldState)</span><br><span class="line">  <span class="keyword">const</span> newKeys = <span class="built_in">Object</span>.keys(nextState)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (oldKeys.length !== newKeys.length) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> flag = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; oldKeys.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!nextState.hasOwnProperty(oldKeys[i])) &#123;</span><br><span class="line">      flag = <span class="literal">false</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nextState[oldKeys[i]] !== oldState[oldKeys[i]]) &#123;</span><br><span class="line">      flag = <span class="literal">false</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> flag</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h4><p>测试用例用 在 React 上提的一个 <a href="https://github.com/facebook/react/issues/13438#issuecomment-414128918" target="_blank" rel="noopener">issue</a> 中的案例，我们期望点击增加按钮后，页面上显示的值能够加 1。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">PureComponent</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      count: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.click = <span class="keyword">this</span>.click.bind(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  click() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      count: ++<span class="keyword">this</span>.state.count,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.click&#125;&gt;增加&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div&gt;&#123;this.state.count&#125;&lt;/</span>div&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>然而，我们点击上述代码，页面上显示的 0 分毫不动！！！</p><p>揭秘如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">click() &#123;</span><br><span class="line">  <span class="keyword">const</span> t = ++<span class="keyword">this</span>.state.count</span><br><span class="line">  <span class="built_in">console</span>.log(t === <span class="keyword">this</span>.state.count) <span class="comment">// true</span></span><br><span class="line">  <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">    count: t,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当点击增加按钮，控制台显示 <code>t === this.state.count</code> 为 true, 也就说明了 setState 前后的状态是统一的，所以 shallowEqual(浅比较) 返回的是 true，致使 shouldComponentUpdate 返回了 false，页面因此没有渲染。</p><p>类似的，如下写法也是达不到目标的，留给读者思考了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">click() &#123;</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">    count: <span class="keyword">this</span>.state.count++,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么如何达到我们期望的目标呢。揭秘如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">click() &#123;</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">    count: <span class="keyword">this</span>.state.count + <span class="number">1</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>感悟：小小的一行代码里蕴藏着无数的 bug。</p><h3 id="HOC-实践"><a href="#HOC-实践" class="headerlink" title="HOC 实践"></a>HOC 实践</h3><p>高阶组件(Higher Order Component) 不属于 React API 范畴，但是它在 React 中也是一种实用的技术，<code>它可以将常见任务抽象成一个可重用的部分</code>。这个小节算是番外篇，会结合 <a href="https://github.com/MuYunyun/cpreact" target="_blank" rel="noopener">cpreact</a>(前文实现的类 react 轮子) 与 HOC 进行相关的实践。</p><p>它可以用如下公式表示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">y = f(x),</span><br><span class="line"></span><br><span class="line"><span class="comment">// x：原有组件</span></span><br><span class="line"><span class="comment">// y：高阶组件</span></span><br><span class="line"><span class="comment">// f()：</span></span><br></pre></td></tr></table></figure><p><code>f()</code> 的实现有两种方法，下面进行实践。</p><h4 id="属性代理-Props-Proxy"><a href="#属性代理-Props-Proxy" class="headerlink" title="属性代理(Props Proxy)"></a>属性代理(Props Proxy)</h4><p>这类实现也是装饰器模式的一种运用，通过装饰器函数给原来函数赋能。下面例子在装饰器函数中给被装饰的组件传递了额外的属性 { a: 1, b: 2 }。</p><blockquote><p>声明：下文所展示的 demo 均已在 <a href="https://github.com/MuYunyun/cpreact" target="_blank" rel="noopener">cpreact</a> 测试通过</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ppHOC</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;WrappedComponent &#123; ...this.props &#125; &#123; ...obj &#125; /&gt;</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@ppHOC</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123; <span class="keyword">this</span>.props.a + <span class="keyword">this</span>.props.b &#125; &#123; <span class="comment">/* 输出 3 */</span> &#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>要是将 { a: 1, b: 2 } 替换成全局共享对象，那么不就是 react-redux 中的 Connect 了么?</p><p>改进上述 demo，我们就可以实现可插拔的<a href="https://reactjs.org/docs/forms.html#controlled-components" target="_blank" rel="noopener">受控组件</a>，代码示意如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ppDecorate</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">      <span class="keyword">super</span>()</span><br><span class="line">      <span class="keyword">this</span>.state = &#123;</span><br><span class="line">        value: <span class="string">''</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.onChange = <span class="keyword">this</span>.onChange.bind(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    onChange(e) &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">        value: e.target.value</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">const</span> obj = &#123;</span><br><span class="line">        onChange: <span class="keyword">this</span>.onChange,</span><br><span class="line">        value: <span class="keyword">this</span>.state.value,</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;WrappedComponent &#123; ...this.props &#125; &#123; ...obj &#125; /&gt;</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@ppDecorate</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input &#123; ...this.props &#125; /&gt;</span><br><span class="line">        &lt;div&gt;&#123; <span class="keyword">this</span>.props.value &#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下图：</p><p><img src="http://with.muyunyun.cn/hoc%E6%8E%A2%E7%B4%A2%E4%B9%8B%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6.gif" alt=""></p><p>这里有个坑点，当我们在输入框输入字符的时候，并不会立马触发 onChange 事件(我们想要让事件立即触发，然而现在要按下回车键或者点下鼠标才触发)，在 react 中有个<a href="https://reactjs.org/docs/events.html" target="_blank" rel="noopener">合成事件</a> 的知识点，下篇文章会进行探究。</p><p>顺带一提在这个 demo 中似乎看到了双向绑定的效果，但是实际中 React 并没有双向绑定的概念，但是我们可以运用 HOC 的知识点结合 setState 在 React 表单中实现伪双向绑定的效果。</p><h4 id="继承反转-Inheritance-Inversion"><a href="#继承反转-Inheritance-Inversion" class="headerlink" title="继承反转(Inheritance Inversion)"></a>继承反转(Inheritance Inversion)</h4><p>继承反转的核心是：传入 HOC 的组件会作为返回类的父类来使用。然后在 render 中调用 <code>super.render()</code> 来调用父类的 render 方法。</p><blockquote><p>在 <a href="https://github.com/MuYunyun/blog/blob/master/BasicSkill/readES6/继承.md#作为对象调用的-super" target="_blank" rel="noopener">《ES6 继承与 ES5 继承的差异》</a>中我们提到了作为对象使用的 super 指向父类的实例。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">iiHOC</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">WrappedComponent</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">const</span> parentRender = <span class="keyword">super</span>.render()</span><br><span class="line">      <span class="keyword">if</span> (parentRender.nodeName === <span class="string">'span'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">          &lt;span&gt;继承反转&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">      &#125;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">@iiHOC</span></span><br><span class="line"><span class="regexp">class B extends Component &#123;</span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">      &lt;span&gt;Inheritance Inversion&lt;/</span>span&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个 demo 中，在 HOC 内实现了渲染劫持，页面上最终显示如下：</p><p><img src="http://with.muyunyun.cn/e7dbedcefd9a61dcd12fbcff89dc19ef.jpg-200" alt=""></p><blockquote><p>可能会有疑惑，使用<code>属性代理</code>的方式貌似也能实现渲染劫持呀，但是那样做没有<code>继承反转</code>这种方式纯粹。</p></blockquote><h3 id="鸣谢"><a href="#鸣谢" class="headerlink" title="鸣谢"></a>鸣谢</h3><p>Especially thank <a href="https://github.com/hujiulong/simple-react" target="_blank" rel="noopener">simple-react</a> for the guidance function of this library. At the meantime，respect for <a href="https://github.com/developit/preact" target="_blank" rel="noopener">preact</a> and <a href="https://github.com/facebook/react" target="_blank" rel="noopener">react</a></p><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li><a href="https://github.com/facebook/react/issues/13438" target="_blank" rel="noopener">A doubt behaviour using the PureComponent</a></li><li><a href="https://juejin.im/post/59cdaaccf265da066f6ac83b" target="_blank" rel="noopener">React 的性能优化（一）当 PureComponent 遇上 ImmutableJS</a></li><li><a href="https://juejin.im/post/5b1caceb5188257d63226743" target="_blank" rel="noopener">React性能优化方案之PureComponent</a></li><li><a href="https://juejin.im/post/59818a485188255694568ff2" target="_blank" rel="noopener">带着三个问题深入浅出React高阶组件</a></li><li><a href="https://zhuanlan.zhihu.com/p/24776678?refer=FrontendMagazine" target="_blank" rel="noopener">深入理解 React 高阶组件</a></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun May 10 2020 18:57:15 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;&lt;img src=&quot;http://with.muyunyun.cn/9c461a61924ed0fecb6024a256671251.jpg-muyy&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;本系列文章在实现一个 cpreact 的同时帮助大家理顺 React 框架的核心内容(JSX/虚拟DOM/组件/生命周期/diff算法/setState/PureComponent/HOC/…) &lt;a href=&quot;https://github.com/MuYunyun/cpreact&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;项目地址&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="React" scheme="http://muyunyun.cn/categories/React/"/>
    
    
      <category term="React" scheme="http://muyunyun.cn/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>常见数据结构小结</title>
    <link href="http://muyunyun.cn/posts/ac276990/"/>
    <id>http://muyunyun.cn/posts/ac276990/</id>
    <published>2018-08-18T09:06:32.000Z</published>
    <updated>2018-11-26T14:48:20.563Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 18:57:15 GMT+0800 (China Standard Time) --><p><img src="http://with.muyunyun.cn/62245a2ed09ce8856e2eb41efe8f70f8.jpg-muyy" alt=""></p><a id="more"></a><h3 id="常见数据结构的-JS-实现"><a href="#常见数据结构的-JS-实现" class="headerlink" title="常见数据结构的 JS 实现"></a>常见数据结构的 JS 实现</h3><ul><li><a href="https://github.com/MuYunyun/blog/blob/master/BasicSkill/algorithm/栈.md" target="_blank" rel="noopener">栈</a></li><li><a href="https://github.com/MuYunyun/blog/blob/master/BasicSkill/algorithm/队列.md" target="_blank" rel="noopener">队列</a></li><li><a href="https://github.com/MuYunyun/blog/blob/master/BasicSkill/algorithm/链表.md" target="_blank" rel="noopener">链表</a></li><li><a href="https://github.com/MuYunyun/blog/blob/master/BasicSkill/algorithm/集合.md" target="_blank" rel="noopener">集合</a></li><li><a href="https://github.com/MuYunyun/blog/blob/master/BasicSkill/algorithm/字典.md" target="_blank" rel="noopener">字典</a></li><li><a href="https://github.com/MuYunyun/blog/blob/master/BasicSkill/algorithm/哈希表.md" target="_blank" rel="noopener">哈希表</a></li><li><a href="https://github.com/MuYunyun/blog/blob/master/BasicSkill/algorithm/二叉树.md" target="_blank" rel="noopener">二叉树</a></li><li><a href="https://github.com/MuYunyun/blog/blob/master/BasicSkill/algorithm/图.md" target="_blank" rel="noopener">图</a></li></ul><h3 id="前端与数据结构"><a href="#前端与数据结构" class="headerlink" title="前端与数据结构"></a>前端与数据结构</h3><p>数据结构在开发中是一种编程思想的提炼，无关于用何种语言开发或者是哪种端开发。下列将笔者涉猎到的与前端相关的数据结构案例作如下总结：</p><table><thead><tr><th align="center">数据结构</th><th align="center">案例</th></tr></thead><tbody><tr><td align="center">栈</td><td align="center">FILO: 其它数据结构的基础，redux/koa2 中间件机制</td></tr><tr><td align="center">队列</td><td align="center">FIFO：其它数据结构的基础</td></tr><tr><td align="center">链表</td><td align="center">React 16 中的 Fiber 的优化</td></tr><tr><td align="center">集合</td><td align="center">对应 JavaScript 中的 Set</td></tr><tr><td align="center">字典</td><td align="center">对应 JavaScript 中的 Map</td></tr><tr><td align="center">哈希表</td><td align="center">一种特殊的字典，可以用来存储加密数据</td></tr><tr><td align="center">树</td><td align="center">DOM TREE / HTML TREE / CSS TREE</td></tr><tr><td align="center">图</td><td align="center">暂时没遇到，不过里面的 BFS/DFS 蛮常见</td></tr></tbody></table><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun May 10 2020 18:57:15 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;&lt;img src=&quot;http://with.muyunyun.cn/62245a2ed09ce8856e2eb41efe8f70f8.jpg-muyy&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="http://muyunyun.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://muyunyun.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>从 0 到 1 实现 React 系列 —— 4.setState优化和ref的实现</title>
    <link href="http://muyunyun.cn/posts/55ccbd9e/"/>
    <id>http://muyunyun.cn/posts/55ccbd9e/</id>
    <published>2018-08-05T14:22:32.000Z</published>
    <updated>2018-11-26T14:48:20.566Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 18:57:15 GMT+0800 (China Standard Time) --><p><img src="http://with.muyunyun.cn/9c461a61924ed0fecb6024a256671251.jpg-muyy" alt=""></p><p>本系列文章在实现一个 cpreact 的同时帮助大家理顺 React 框架的核心内容(JSX/虚拟DOM/组件/生命周期/diff算法/setState/PureComponent/HOC/…) <a href="https://github.com/MuYunyun/cpreact" target="_blank" rel="noopener">项目地址</a></p><a id="more"></a><ul><li><a href="https://github.com/MuYunyun/blog/issues/24" target="_blank" rel="noopener">从 0 到 1 实现 React 系列 —— JSX 和 Virtual DOM</a></li><li><a href="https://github.com/MuYunyun/blog/issues/25" target="_blank" rel="noopener">从 0 到 1 实现 React 系列 —— 组件和 state|props</a></li><li><a href="https://github.com/MuYunyun/blog/issues/26" target="_blank" rel="noopener">从 0 到 1 实现 React 系列 —— 生命周期和 diff 算法</a></li><li><a href="https://github.com/MuYunyun/blog/issues/27" target="_blank" rel="noopener">从 0 到 1 实现 React 系列 —— 优化 setState 和 ref 的实现</a></li><li><a href="https://github.com/MuYunyun/blog/issues/29" target="_blank" rel="noopener">从 0 到 1 实现 React 系列 —— PureComponent 实现 &amp;&amp; HOC 探幽</a></li></ul><h3 id="同步-setState-的问题"><a href="#同步-setState-的问题" class="headerlink" title="同步 setState 的问题"></a>同步 setState 的问题</h3><p>而在现有 setState 逻辑实现中，每调用一次 setState 就会执行 render 一次。因此在如下代码中，每次点击增加按钮，因为 click 方法里调用了 10 次 setState 函数，页面也会被渲染 10 次。而我们希望的是每点击一次增加按钮只执行 render 函数一次。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      count: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.click = <span class="keyword">this</span>.click.bind(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  click() &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123; <span class="comment">// 在先前的逻辑中，没调用一次 setState 就会 render 一次</span></span><br><span class="line">        count: ++<span class="keyword">this</span>.state.count</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.count)</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.click&#125;&gt;增加&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div&gt;&#123;this.state.count&#125;&lt;/</span>div&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="异步调用-setState"><a href="#异步调用-setState" class="headerlink" title="异步调用 setState"></a>异步调用 setState</h3><p>查阅 setState 的 api，其形式如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setState(updater, [callback])</span><br></pre></td></tr></table></figure><p>它能接收两个参数，其中第一个参数 updater 可以为对象或者为函数 (<code>(prevState, props) =&gt; stateChange</code>)，第二个参数为回调函数；</p><p>确定优化思路为：将多次 setState 后跟着的值进行浅合并，并借助事件循环等所有值合并好之后再进行渲染界面。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> componentArr = []</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步渲染</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">asyncRender</span>(<span class="params">updater, component, cb</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (componentArr.length === <span class="number">0</span>) &#123;</span><br><span class="line">    defer(<span class="function"><span class="params">()</span> =&gt;</span> render())       <span class="comment">// 利用事件循环，延迟渲染函数的调用</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (cb) defer(cb)             <span class="comment">// 调用回调函数</span></span><br><span class="line">  <span class="keyword">if</span> (_.isFunction(updater)) &#123;  <span class="comment">// 处理 setState 后跟函数的情况</span></span><br><span class="line">    updater = updater(component.state, component.props)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 浅合并逻辑</span></span><br><span class="line">  component.state = <span class="built_in">Object</span>.assign(&#123;&#125;, component.state, updater)</span><br><span class="line">  <span class="keyword">if</span> (componentArr.includes(component)) &#123;</span><br><span class="line">    component.state = <span class="built_in">Object</span>.assign(&#123;&#125;, component.state, updater)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    componentArr.push(component)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> component</span><br><span class="line">  <span class="keyword">while</span> (component = componentArr.shift()) &#123;</span><br><span class="line">    renderComponent(component) <span class="comment">// rerender</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件循环，关于 promise 的事件循环和 setTimeout 的事件循环后续会单独写篇文章。</span></span><br><span class="line"><span class="keyword">const</span> defer = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> fn())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，每点击一次增加按钮 render 函数只执行一次了。</p><h3 id="ref-的实现"><a href="#ref-的实现" class="headerlink" title="ref 的实现"></a>ref 的实现</h3><p>在 react 中并不建议使用 ref 属性，而应该尽量使用<a href="https://doc.react-china.org/docs/lifting-state-up.html" target="_blank" rel="noopener">状态提升</a>，但是 react 还是提供了 ref 属性赋予了开发者操作 dom 的能力，react 的 ref 有 <code>string</code>、<code>callback</code>、<code>createRef</code> 三种形式，分别如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// string 这种写法未来会被抛弃</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">this</span>.refs.myRef.focus()</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">"myRef"</span> /&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// callback(比较通用)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">this</span>.myRef.focus()</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;(ele)</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="xml">      this.myRef = ele</span></span><br><span class="line"><span class="xml">    &#125;&#125; /&gt;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// react 16.3 增加，其它 react-like 框架还没有同步</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>() &#123;</span><br><span class="line">      <span class="keyword">this</span>.myRef = React.createRef()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">this</span>.myRef.current.focus()</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;this.myRef&#125;</span> /&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://zhuanlan.zhihu.com/p/40462264" target="_blank" rel="noopener">React ref 的前世今生</a> 罗列了三种写法的差异，下面对上述例子中的第二种写法(比较通用)进行实现。</p><p>首先在 setAttribute 方法内补充上对 ref 的属性进行特殊处理，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setAttribute</span>(<span class="params">dom, attr, value</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (attr === <span class="string">'ref'</span>) &#123;          <span class="comment">// 处理 ref 属性</span></span><br><span class="line">    <span class="keyword">if</span> (_.isFunction(value)) &#123;</span><br><span class="line">      value(dom)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对这个例子中 <code>this.myRef.focus()</code> 的 focus 属性需要异步处理，因为调用 componentDidMount 的时候，界面上还未添加 dom 元素。处理 renderComponent 函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">renderComponent</span>(<span class="params">component</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (component &amp;&amp; component.componentDidMount) &#123;</span><br><span class="line">    defer(component.componentDidMount.bind(component))</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>刷新页面，可以发现 input 框已为选中状态。</p><p><img src="http://with.muyunyun.cn/d35589fbbff45a2437c6c13e24ba8058.jpg-200" alt=""></p><p>处理完普通元素的 ref 后，再来处理下自定义组件的 ref 的情况。之前默认自定义组件上是没属性的，现在只要针对自定义组件的 ref 属性做相应处理即可。稍微修改 vdomToDom 函数如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">vdomToDom</span>(<span class="params">vdom</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (_.isFunction(vdom.nodeName)) &#123; <span class="comment">// 此时是自定义组件</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> attr <span class="keyword">in</span> vdom.attributes) &#123; <span class="comment">// 处理自定义组件的 ref 属性</span></span><br><span class="line">      <span class="keyword">if</span> (attr === <span class="string">'ref'</span> &amp;&amp; _.isFunction(vdom.attributes[attr])) &#123;</span><br><span class="line">        vdom.attributes[attr](component)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跑如下测试用例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>()</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      count: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.click = <span class="keyword">this</span>.click.bind(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  click() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      count: ++<span class="keyword">this</span>.state.count</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.state.count&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>()</span><br><span class="line">    <span class="keyword">this</span>.click = <span class="keyword">this</span>.click.bind(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  click() &#123;</span><br><span class="line">    <span class="keyword">this</span>.A.click()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.click&#125;&gt;加<span class="number">1</span>&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;A ref=&#123;(e) =&gt; &#123; this.A = e &#125;&#125; /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="http://with.muyunyun.cn/reactref%E6%B5%8B%E8%AF%951" alt=""></p><h3 id="鸣谢"><a href="#鸣谢" class="headerlink" title="鸣谢"></a>鸣谢</h3><p>Especially thank <a href="https://github.com/hujiulong/simple-react" target="_blank" rel="noopener">simple-react</a> for the guidance function of this library. At the meantime，respect for <a href="https://github.com/developit/preact" target="_blank" rel="noopener">preact</a> and <a href="https://github.com/facebook/react" target="_blank" rel="noopener">react</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun May 10 2020 18:57:15 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;&lt;img src=&quot;http://with.muyunyun.cn/9c461a61924ed0fecb6024a256671251.jpg-muyy&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;本系列文章在实现一个 cpreact 的同时帮助大家理顺 React 框架的核心内容(JSX/虚拟DOM/组件/生命周期/diff算法/setState/PureComponent/HOC/…) &lt;a href=&quot;https://github.com/MuYunyun/cpreact&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;项目地址&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="React" scheme="http://muyunyun.cn/categories/React/"/>
    
    
      <category term="React" scheme="http://muyunyun.cn/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>从 0 到 1 实现 React 系列 —— 3.生命周期和 diff 算法</title>
    <link href="http://muyunyun.cn/posts/dc5976f1/"/>
    <id>http://muyunyun.cn/posts/dc5976f1/</id>
    <published>2018-07-27T00:13:02.000Z</published>
    <updated>2018-11-26T14:48:20.565Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun May 10 2020 18:57:15 GMT+0800 (China Standard Time) --><p><img src="http://with.muyunyun.cn/9c461a61924ed0fecb6024a256671251.jpg-muyy" alt=""></p><p>本系列文章在实现一个 cpreact 的同时帮助大家理顺 React 框架的核心内容(JSX/虚拟DOM/组件/生命周期/diff算法/setState/PureComponent/HOC/…) <a href="https://github.com/MuYunyun/cpreact" target="_blank" rel="noopener">项目地址</a></p><a id="more"></a><ul><li><a href="https://github.com/MuYunyun/blog/issues/24" target="_blank" rel="noopener">从 0 到 1 实现 React 系列 —— JSX 和 Virtual DOM</a></li><li><a href="https://github.com/MuYunyun/blog/issues/25" target="_blank" rel="noopener">从 0 到 1 实现 React 系列 —— 组件和 state|props</a></li><li><a href="https://github.com/MuYunyun/blog/issues/26" target="_blank" rel="noopener">从 0 到 1 实现 React 系列 —— 生命周期和 diff 算法</a></li><li><a href="https://github.com/MuYunyun/blog/issues/27" target="_blank" rel="noopener">从 0 到 1 实现 React 系列 —— 优化 setState 和 ref 的实现</a></li><li><a href="https://github.com/MuYunyun/blog/issues/29" target="_blank" rel="noopener">从 0 到 1 实现 React 系列 —— PureComponent 实现 &amp;&amp; HOC 探幽</a></li></ul><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>先来回顾 React 的生命周期，用流程图表示如下：</p><p><img src="http://with.muyunyun.cn/77e8b5ceaa1d697f280053be91a87bb3.jpg" alt=""></p><p>该流程图比较清晰地呈现了 react 的生命周期。其分为 3 个阶段 —— 生成期，存在期，销毁期。</p><p>因为生命周期钩子函数存在于自定义组件中，将之前 _render 函数作些调整如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原来的 _render 函数，为了将职责拆分得更细，将 virtual dom 转为 real dom 的函数单独抽离出来</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">vdomToDom</span>(<span class="params">vdom</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (_.isFunction(vdom.nodeName)) &#123;        <span class="comment">// 为了更加方便地书写生命周期逻辑，将解析自定义组件逻辑和一般 html 标签的逻辑分离开</span></span><br><span class="line">    <span class="keyword">const</span> component = createComponent(vdom) <span class="comment">// 构造组件</span></span><br><span class="line">    setProps(component)                     <span class="comment">// 更改组件 props</span></span><br><span class="line">    renderComponent(component)              <span class="comment">// 渲染组件，将 dom 节点赋值到 component</span></span><br><span class="line">    <span class="keyword">return</span> component.base                   <span class="comment">// 返回真实 dom</span></span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以在 setProps 函数内（渲染前）加入 <code>componentWillMount</code>，<code>componentWillReceiveProps</code> 方法，setProps 函数如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setProps</span>(<span class="params">component</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (component &amp;&amp; component.componentWillMount) &#123;</span><br><span class="line">    component.componentWillMount()</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (component.base &amp;&amp; component.componentWillReceiveProps) &#123;</span><br><span class="line">    component.componentWillReceiveProps(component.props) <span class="comment">// 后面待实现</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而后我们在 renderComponent 函数内加入 <code>componentDidMount</code>、<code>shouldComponentUpdate</code>、<code>componentWillUpdate</code>、<code>componentDidUpdate</code> 方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">renderComponent</span>(<span class="params">component</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (component.base &amp;&amp; component.shouldComponentUpdate) &#123;</span><br><span class="line">    <span class="keyword">const</span> bool = component.shouldComponentUpdate(component.props, component.state)</span><br><span class="line">    <span class="keyword">if</span> (!bool &amp;&amp; bool !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span> <span class="comment">// shouldComponentUpdate() 返回 false，则生命周期终止</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (component.base &amp;&amp; component.componentWillUpdate) &#123;</span><br><span class="line">    component.componentWillUpdate()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> rendered = component.render()</span><br><span class="line">  <span class="keyword">const</span> base = vdomToDom(rendered)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (component.base &amp;&amp; component.componentDidUpdate) &#123;</span><br><span class="line">    component.componentDidUpdate()</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (component &amp;&amp; component.componentDidMount) &#123;</span><br><span class="line">    component.componentDidMount()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (component.base &amp;&amp; component.base.parentNode) &#123; <span class="comment">// setState 进入此逻辑</span></span><br><span class="line">    component.base.parentNode.replaceChild(base, component.base)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  component.base = base  <span class="comment">// 标志符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试生命周期"><a href="#测试生命周期" class="headerlink" title="测试生命周期"></a>测试生命周期</h4><p>测试如下用例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  componentWillReceiveProps(props) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'componentWillReceiveProps'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;&#123;<span class="keyword">this</span>.props.count&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">class B extends Component &#123;</span></span><br><span class="line"><span class="regexp">  constructor(props) &#123;</span></span><br><span class="line"><span class="regexp">    super(props)</span></span><br><span class="line"><span class="regexp">    this.state = &#123;</span></span><br><span class="line"><span class="regexp">      count: 1</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  componentWillMount() &#123;</span></span><br><span class="line"><span class="regexp">    console.log('componentWillMount')</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  componentDidMount() &#123;</span></span><br><span class="line"><span class="regexp">    console.log('componentDidMount')</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  shouldComponentUpdate(nextProps, nextState) &#123;</span></span><br><span class="line"><span class="regexp">    console.log('shouldComponentUpdate', nextProps, nextState)</span></span><br><span class="line"><span class="regexp">    return true</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  componentWillUpdate() &#123;</span></span><br><span class="line"><span class="regexp">    console.log('componentWillUpdate')</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  componentDidUpdate() &#123;</span></span><br><span class="line"><span class="regexp">    console.log('componentDidUpdate')</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  click() &#123;</span></span><br><span class="line"><span class="regexp">    this.setState(&#123;</span></span><br><span class="line"><span class="regexp">      count: ++this.state.count</span></span><br><span class="line"><span class="regexp">    &#125;)</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    console.log('render')</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;this.click.bind(this)&#125;&gt;Click Me!&lt;/</span>button&gt;</span><br><span class="line">        &lt;A count=&#123;<span class="keyword">this</span>.state.count&#125; /&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(</span></span><br><span class="line"><span class="regexp">  &lt;B /</span>&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>页面加载时输出结果如下：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">componentWillMount</span></span><br><span class="line"><span class="attribute">render</span></span><br><span class="line"><span class="attribute">componentDidMount</span></span><br></pre></td></tr></table></figure><p>点击按钮时输出结果如下：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">shouldComponentUpdate</span></span><br><span class="line"><span class="attribute">componentWillUpdate</span></span><br><span class="line"><span class="attribute">render</span></span><br><span class="line"><span class="attribute">componentDidUpdate</span></span><br></pre></td></tr></table></figure><h3 id="diff-的实现"><a href="#diff-的实现" class="headerlink" title="diff 的实现"></a>diff 的实现</h3><p>在 react 中，diff 实现的思路是将新老 virtual dom 进行比较，将比较后的 patch（补丁）渲染到页面上，从而实现局部刷新；本文借鉴了 <a href="https://github.com/developit/preact" target="_blank" rel="noopener">preact</a> 和 <a href="https://github.com/hujiulong/simple-react" target="_blank" rel="noopener">simple-react</a> 中的 diff 实现，总体思路是将旧的 dom 节点和新的 virtual dom 节点进行了比较，根据不同的比较类型（文本节点、非文本节点、自定义组件）调用相应的逻辑，从而实现页面的局部渲染。代码总体结构如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 比较旧的 dom 节点和新的 virtual dom 节点：</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>oldDom  旧的 dom 节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>newVdom 新的 virtual dom 节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diff</span>(<span class="params">oldDom, newVdom</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (_.isString(newVdom)) &#123;</span><br><span class="line">    <span class="keyword">return</span> diffTextDom(oldDom, newVdom)   <span class="comment">// 对比文本 dom 节点</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (oldDom.nodeName.toLowerCase() !== newVdom.nodeName) &#123;</span><br><span class="line">    diffNotTextDom(oldDom, newVdom)       <span class="comment">// 对比非文本 dom 节点</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (_.isFunction(newVdom.nodeName)) &#123;</span><br><span class="line">    <span class="keyword">return</span> diffComponent(oldDom, newVdom) <span class="comment">// 对比自定义组件</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  diffAttribute(oldDom, newVdom)          <span class="comment">// 对比属性</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (newVdom.children.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    diffChild(oldDom, newVdom)            <span class="comment">// 遍历对比子节点</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> oldDom</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面根据不同比较类型实现相应逻辑。</p><h4 id="对比文本节点"><a href="#对比文本节点" class="headerlink" title="对比文本节点"></a>对比文本节点</h4><p>首先进行较为简单的文本节点的比较，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对比文本节点</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diffTextDom</span>(<span class="params">oldDom, newVdom</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> dom = oldDom</span><br><span class="line">  <span class="keyword">if</span> (oldDom &amp;&amp; oldDom.nodeType === <span class="number">3</span>) &#123;  <span class="comment">// 如果老节点是文本节点</span></span><br><span class="line">    <span class="keyword">if</span> (oldDom.textContent !== newVdom) &#123; <span class="comment">// 这里一个细节：textContent/innerHTML/innerText 的区别</span></span><br><span class="line">      oldDom.textContent = newVdom</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;                                <span class="comment">// 如果旧 dom 元素不为文本节点</span></span><br><span class="line">    dom = <span class="built_in">document</span>.createTextNode(newVdom)</span><br><span class="line">    <span class="keyword">if</span> (oldDom &amp;&amp; oldDom.parentNode) &#123;</span><br><span class="line">      oldDom.parentNode.replaceChild(dom, oldDom)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dom</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="对比非文本节点"><a href="#对比非文本节点" class="headerlink" title="对比非文本节点"></a>对比非文本节点</h4><p>对比非文本节点，其思路为将同层级的旧节点替换为新节点，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对比非文本节点</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diffNotTextDom</span>(<span class="params">oldDom, newVdom</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> newDom = <span class="built_in">document</span>.createElement(newVdom.nodeName);</span><br><span class="line">  [...oldDom.childNodes].map(newDom.appendChild) <span class="comment">// 将旧节点下的元素添加到新节点下</span></span><br><span class="line">  <span class="keyword">if</span> (oldDom &amp;&amp; oldDom.parentNode) &#123;</span><br><span class="line">    oldDom.parentNode.replaceChild(oldDom, newDom)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="对比自定义组件"><a href="#对比自定义组件" class="headerlink" title="对比自定义组件"></a>对比自定义组件</h4><p>对比自定义组件的思路为：如果新老组件不同，则直接将新组件替换老组件；如果新老组件相同，则将新组件的 props 赋到老组件上，然后再对获得新 props 前后的老组件做 diff 比较。代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对比自定义组件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diffComponent</span>(<span class="params">oldDom, newVdom</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (oldDom._component &amp;&amp; (oldDom._component.constructor !== newVdom.nodeName)) &#123; <span class="comment">// 如果新老组件不同，则直接将新组件替换老组件</span></span><br><span class="line">    <span class="keyword">const</span> newDom = vdomToDom(newVdom)</span><br><span class="line">    oldDom._component.parentNode.insertBefore(newDom, oldDom._component)</span><br><span class="line">    oldDom._component.parentNode.removeChild(oldDom._component)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    setProps(oldDom._component, newVdom.attributes) <span class="comment">// 如果新老组件相同，则将新组件的 props 赋到老组件上</span></span><br><span class="line">    renderComponent(oldDom._component)              <span class="comment">// 对获得新 props 前后的老组件做 diff 比较（renderComponent 中调用了 diff）</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="遍历对比子节点"><a href="#遍历对比子节点" class="headerlink" title="遍历对比子节点"></a>遍历对比子节点</h4><p>遍历对比子节点的策略有两个：一是只比较同层级的节点，二是给节点加上 key 属性。它们的目的都是降低空间复杂度。代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对比子节点</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diffChild</span>(<span class="params">oldDom, newVdom</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> keyed = &#123;&#125;</span><br><span class="line">  <span class="keyword">const</span> children = []</span><br><span class="line">  <span class="keyword">const</span> oldChildNodes = oldDom.childNodes</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; oldChildNodes.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (oldChildNodes[i].key) &#123; <span class="comment">// 将含有 key 的节点存进对象 keyed</span></span><br><span class="line">      keyed[oldChildNodes[i].key] = oldChildNodes[i]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;                    <span class="comment">// 将不含有 key 的节点存进数组 children</span></span><br><span class="line">      children.push(oldChildNodes[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> newChildNodes = newVdom.children</span><br><span class="line">  <span class="keyword">let</span> child</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; newChildNodes.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (keyed[newChildNodes[i].key]) &#123;  <span class="comment">// 对应上面存在 key 的情形</span></span><br><span class="line">      child = keyed[newChildNodes[i].key]</span><br><span class="line">      keyed[newChildNodes[i].key] = <span class="literal">undefined</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;                            <span class="comment">// 对应上面不存在 key 的情形</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; children.length; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isSameNodeType(children[i], newChildNodes[i])) &#123; <span class="comment">// 如果不存在 key，则优先找到节点类型相同的元素</span></span><br><span class="line">          child = children[i]</span><br><span class="line">          children[i] = <span class="literal">undefined</span></span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    diff(child, newChildNodes[i]) <span class="comment">// 递归比较</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>在生命周期的小节中，componentWillReceiveProps 方法还未跑通，稍加修改 setProps 函数即可：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 更改属性，componentWillMount 和 componentWillReceiveProps 方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setProps</span>(<span class="params">component, attributes</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (attributes) &#123;</span><br><span class="line">    component.props = attributes <span class="comment">// 这段逻辑对应上文自定义组件比较中新老组件相同时 setProps 的逻辑</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (component &amp;&amp; component.base &amp;&amp; component.componentWillReceiveProps) &#123;</span><br><span class="line">    component.componentWillReceiveProps(component.props)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (component &amp;&amp; component.componentWillMount) &#123;</span><br><span class="line">    component.componentWillMount()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来测试下生命周期小节中最后的测试用例：</p><ul><li>生命周期测试</li></ul><p><img src="http://with.muyunyun.cn/react%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%B5%8B%E8%AF%951.gif" alt=""></p><ul><li>diff 测试</li></ul><p><img src="http://with.muyunyun.cn/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9Fdiff%E6%B5%8B%E8%AF%951.gif" alt=""></p><h3 id="鸣谢"><a href="#鸣谢" class="headerlink" title="鸣谢"></a>鸣谢</h3><p>Especially thank <a href="https://github.com/hujiulong/simple-react" target="_blank" rel="noopener">simple-react</a> for the guidance function of this library. At the meantime，respect for <a href="https://github.com/developit/preact" target="_blank" rel="noopener">preact</a> and <a href="https://github.com/facebook/react" target="_blank" rel="noopener">react</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun May 10 2020 18:57:15 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;&lt;img src=&quot;http://with.muyunyun.cn/9c461a61924ed0fecb6024a256671251.jpg-muyy&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;p&gt;本系列文章在实现一个 cpreact 的同时帮助大家理顺 React 框架的核心内容(JSX/虚拟DOM/组件/生命周期/diff算法/setState/PureComponent/HOC/…) &lt;a href=&quot;https://github.com/MuYunyun/cpreact&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;项目地址&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="React" scheme="http://muyunyun.cn/categories/React/"/>
    
    
      <category term="React" scheme="http://muyunyun.cn/tags/React/"/>
    
  </entry>
  
</feed>
