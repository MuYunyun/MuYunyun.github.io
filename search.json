[{"title":"探索 React Fiber 数据结构","url":"/posts/9f41fc98/","content":"<p><img src=\"http://with.muyunyun.cn/dd8ac42021e3a5913a5c5d51437ade02.jpg-muyy\" alt=\"\"></p>\n<p>此章节会通过两个 <code>demo</code> 来展示 <code>Stack Reconciler</code> 以及 <code>Fiber Reconciler</code> 的数据结构。</p>\n<a id=\"more\"></a>\n\n<p><img src=\"http://with.muyunyun.cn/7621091ae74df1bbd8b00586128a7d44.jpg-300v\" alt=\"\"></p>\n<p>首先用代码表示上图节点间的关系。比如 <code>a1 节点</code>下有 <code>b1、b2、b3 节点</code>, 就可以把它们间的关系写成 <code>a1.render = () =&gt; [b1, b2, b3]</code>;</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a1 = &#123; <span class=\"attr\">name</span>: <span class=\"string\">'a1'</span>, render = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> [b1, b2, b3] &#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b1 = &#123; <span class=\"attr\">name</span>: <span class=\"string\">'b1'</span>, render = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> [c1] &#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b2 = &#123; <span class=\"attr\">name</span>: <span class=\"string\">'b2'</span>, render = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> [c2] &#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b3 = &#123; <span class=\"attr\">name</span>: <span class=\"string\">'b3'</span>, render = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> [] &#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> c1 = &#123; <span class=\"attr\">name</span>: <span class=\"string\">'c1'</span>, render = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> [d1] &#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> c2 = &#123; <span class=\"attr\">name</span>: <span class=\"string\">'c2'</span>, render = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> [] &#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> d1 = &#123; <span class=\"attr\">name</span>: <span class=\"string\">'d1'</span>, render = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> [d2] &#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> d2 = &#123; <span class=\"attr\">name</span>: <span class=\"string\">'d2'</span>, render = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> [] &#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Stack-Reconciler\"><a href=\"#Stack-Reconciler\" class=\"headerlink\" title=\"Stack Reconciler\"></a>Stack Reconciler</h4><p>在 <code>React 16</code> 之前，节点之间的关系可以用数据结构中<code>树的深度遍历</code>来表示。</p>\n<p>如下实现 <code>walk</code> 函数, 将深度遍历的节点打印出来。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">walk(a1)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">walk</span>(<span class=\"params\">instance</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!instance) <span class=\"keyword\">return</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(instance.name)</span><br><span class=\"line\">  instance.render().map(walk)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出结果为: <code>a1 b1 c1 d1 d2 b2 c2 b3</code></p>\n<h4 id=\"Fiber-Reconciler\"><a href=\"#Fiber-Reconciler\" class=\"headerlink\" title=\"Fiber Reconciler\"></a>Fiber Reconciler</h4><p>在 <code>React 16</code> 中，节点之间的关系可以用数据结构中的<code>链表</code>来表示。</p>\n<p>节点之间的链表有三种情形, 用图表示如下:</p>\n<p><img src=\"http://with.muyunyun.cn/d7378495a2f16e9058c80326705465f4.jpg-300v\" alt=\"\"></p>\n<ol>\n<li>父节点到子节点(红色虚线)</li>\n<li>同层节点(黄色虚线)</li>\n<li>子节点到父节点(蓝色虚线)</li>\n</ol>\n<blockquote>\n<p>父节点指向第一个子节点, 每个子节点都指向父节点，同层节点间是单向链表。</p>\n</blockquote>\n<p>首先, 构建节点的数据结构, 如下所示:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> FiberNode = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">instance</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.instance = instance</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.parent = <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.sibling = <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.child = <span class=\"literal\">null</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后创建一个将节点串联起来的 <code>connect</code> 函数:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> connect = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">parent, childList</span>) </span>&#123;</span><br><span class=\"line\">  parent.child = childList.reduceRight(<span class=\"function\">(<span class=\"params\">prev, current</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> fiberNode = <span class=\"keyword\">new</span> FiberNode(current)</span><br><span class=\"line\">    fiberNode.parent = parent</span><br><span class=\"line\">    fiberNode.sibling = prev</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fiberNode</span><br><span class=\"line\">  &#125;, <span class=\"literal\">null</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> parent.child</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>在 JavaScript 中实现链表的数据结构可以巧用 reduceRight</p>\n</blockquote>\n<p><code>connect</code> 函数中实现了上述链表关系。可以像这样使用它:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> parent = <span class=\"keyword\">new</span> FiberNode(a1)</span><br><span class=\"line\"><span class=\"keyword\">var</span> childFirst = connect(parent, a1.render())</span><br></pre></td></tr></table></figure>\n\n<p>这样子便完成了 <code>a1 节点</code>指向 <code>b1 节点</code>的链表、<code>b1、b2、b3 节点间</code>的单向链表以及 <code>b1、b2、b3 节点</code>指向 <code>a1 节点</code>的链表。</p>\n<p>最后剩下 <code>goWalk</code> 函数将全部节点给遍历完。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 打印日志以及添加列表</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> walk = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">node</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(node.instance.name)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> childLists = node.instance.render()</span><br><span class=\"line\">  <span class=\"keyword\">let</span> child = <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (childLists.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    child = connect(node, childLists)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> child</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> goWalk = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">root</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> currentNode = root</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> child = walk(currentNode)</span><br><span class=\"line\">    <span class=\"comment\">// 如果有子节点</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (child) &#123;</span><br><span class=\"line\">      currentNode = child</span><br><span class=\"line\">      <span class=\"keyword\">continue</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 如果没有相邻节点, 则返回到父节点</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!currentNode.sibling) &#123;</span><br><span class=\"line\">      currentNode = currentNode.parent</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (currentNode === root) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 相邻节点</span></span><br><span class=\"line\">    currentNode = currentNode.sibling</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 调用</span></span><br><span class=\"line\">goWalk(<span class=\"keyword\">new</span> FiberNode(a1))</span><br></pre></td></tr></table></figure>\n\n<p>打印结果为 <code>a1 b1 c1 d1 d2 b2 c2 b3</code></p>\n<h3 id=\"Fiber-Reconciler-的优势\"><a href=\"#Fiber-Reconciler-的优势\" class=\"headerlink\" title=\"Fiber Reconciler 的优势\"></a>Fiber Reconciler 的优势</h3><p>通过分析上述两种数据结构实现的代码，可以得出下面结论:</p>\n<ul>\n<li>基于树的深度遍历实现的 Reconciler: 一旦进入调用栈便无法暂停;</li>\n<li>基于链表实现的 Reconciler: 在 <code>while(true) {}</code> 的循环中, 可以通过 <code>currentNode</code> 的赋值重新得到需要操作的节点，而在赋值之前便可以’暂停’来执行其它逻辑, 这也是 <code>requestIdleCallback</code> 能得以在 <code>Fiber Reconciler</code> 的原因。</li>\n</ul>\n<h3 id=\"相关链接\"><a href=\"#相关链接\" class=\"headerlink\" title=\"相关链接\"></a>相关链接</h3><ul>\n<li><a href=\"https://medium.com/react-in-depth/the-how-and-why-on-reacts-usage-of-linked-list-in-fiber-67f1014d0eb7\" target=\"_blank\" rel=\"noopener\">The how and why on React’s usage of linked list in Fiber to walk the component’s tree</a></li>\n</ul>\n","categories":["React"],"tags":["React"]},{"title":"INHERITED AND NON-INHERITED IN CSS","url":"/posts/33fba87f/","content":"<p><img src=\"http://with.muyunyun.cn/b22bcdb94d354d3f301cae7997d9cd17.jpg\" alt=\"\"></p>\n<p>When I look up css properties in MDN’s specifications section, there are some properties in it and it seems unfamiliar to me. So I try to find out some of them today.</p>\n<a id=\"more\"></a>\n\n<p>The follow list try to give one word to specify the meaning of them.</p>\n<ul>\n<li>Initial value: Specify the CSS property’s default value;</li>\n<li>Applies to: Specify which elements to apply to;</li>\n<li>Inherited: Specify the CSS property is inherited or non-inherited;</li>\n<li><a href=\"https://www.w3.org/TR/css3-mediaqueries/\" target=\"_blank\" rel=\"noopener\">Media</a>: Specify how a document is to be presented on different media;</li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/computed_value\" target=\"_blank\" rel=\"noopener\">Computed value</a>: The CSS property that is transferred from parent to child;</li>\n<li><a href=\"https://drafts.csswg.org/web-animations/#animation-type\" target=\"_blank\" rel=\"noopener\">Animation type</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Canonical_order\" target=\"_blank\" rel=\"noopener\">Canonical order</a>: Some CSS properties(font、background…) have their own CSS property value order.</li>\n</ul>\n<p>And this article is to discuss the topic about the knowledge of inherited and non-inherited.</p>\n<h3 id=\"Initial-value-between-inherited-and-non-inherited\"><a href=\"#Initial-value-between-inherited-and-non-inherited\" class=\"headerlink\" title=\"Initial value between inherited and non-inherited\"></a>Initial value between inherited and non-inherited</h3><p>The initial value of a CSS property is its default value.</p>\n<p>The Initial value has two different behavior between <code>inherited properties</code> and <code>non-inherited properties</code>.</p>\n<p>For <code>inherited properties</code>, the initial value is <code>used on the root element only</code>.</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">style</span>=<span class=\"string\">\"color: red\"</span>&gt;</span></span><br><span class=\"line\">  hello, <span class=\"tag\">&lt;<span class=\"name\">em</span>&gt;</span>CSS<span class=\"tag\">&lt;/<span class=\"name\">em</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>The result is the color of both <code>span</code> and <code>em</code> element are red. Because the color is an inherited property, the element will get the color property from the parent recursively until to document.</p>\n<p>For <code>non-inherited properties</code>, the initial value is <code>used on every element</code>. When no value for a non-inherited property has been specified on an element, the element gets the initial value directly.</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">style</span>=<span class=\"string\">\"border: 1px solid black\"</span>&gt;</span></span><br><span class=\"line\">  hello, <span class=\"tag\">&lt;<span class=\"name\">em</span>&gt;</span>CSS<span class=\"tag\">&lt;/<span class=\"name\">em</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>The result is the border is only effected on <code>span</code> element, not <code>em</code>. Because the border is a non-inherited property, and there is no border property specified on the em, so the em get the border’s initial value <code>none</code>.</p>\n<p>It mentioned much times about inherited value and non-inherited value above, and now we sort out css properties.</p>\n<h3 id=\"Inherited-Type\"><a href=\"#Inherited-Type\" class=\"headerlink\" title=\"Inherited Type\"></a>Inherited Type</h3><p>I’ve collected some inherited types in css, they are listed as follow:</p>\n<ul>\n<li><code>Font Type</code>: font-style、font-variant、font-weight、font-stretch、font-size、font-family、color、line-height;</li>\n<li><code>Space Type</code>: letter-spacing、word-spacing、white-space;</li>\n<li><code>Letter Type</code>: text-align、text-indent、text-shadow、text-transform;</li>\n<li><code>List Type</code>: list-style、list-style-type、list-style-position;</li>\n<li><code>Others</code>: visibility、cursor;</li>\n</ul>\n<h3 id=\"Non-Inherited-Type\"><a href=\"#Non-Inherited-Type\" class=\"headerlink\" title=\"Non-Inherited Type\"></a>Non-Inherited Type</h3><p>In the opposite of inherited type, the non-inherited types are listed as follow:</p>\n<ul>\n<li><code>Layout Type</code>: float、position、left、right、top、bottom、z-index、display</li>\n<li><code>Box Type</code>: width、max-width、min-width、height、max-height、min-height、margin、padding、border;</li>\n<li><code>Background Type</code>: background-size、background-image、background-clip、background-color、background-origin、background-position、background-repeat;</li>\n<li><code>Others</code>: overflow、text-overflow、vertical-align;</li>\n</ul>\n<h3 id=\"Recap\"><a href=\"#Recap\" class=\"headerlink\" title=\"Recap\"></a>Recap</h3><p>These section introduces the inherited concept in CSS, and distinguish some inherited type and some non-inherited type from css properties. Hope it’s helpful for you.</p>\n","categories":["CSS"],"tags":["CSS"]},{"title":"JS 异步系列 —— Promise 札记","url":"/posts/690a449f/","content":"<p><img src=\"http://with.muyunyun.cn/60f4b6024c6dd00425a7fdc9f8067254.jpg-muyy\" alt=\"\"></p>\n<p>实践了一个符合 Promise/A+ 规范的 <a href=\"https://github.com/MuYunyun/repromise\" target=\"_blank\" rel=\"noopener\">repromise</a></p>\n<a id=\"more\"></a>\n\n<h3 id=\"Promise-札记\"><a href=\"#Promise-札记\" class=\"headerlink\" title=\"Promise 札记\"></a>Promise 札记</h3><p>研究 Promise 的动机大体有以下几点：</p>\n<ul>\n<li><p>对其 api 的不熟悉以及对实现机制的好奇;</p>\n</li>\n<li><p>很多库(比如 fetch)是基于 Promise 封装的，那么要了解这些库的前置条件得先熟悉 Promise;</p>\n</li>\n<li><p>要了解其它更为高级的异步操作得先熟悉 Promise;</p>\n</li>\n</ul>\n<p>基于这些目的，实践了一个符合 Promise/A+ 规范的 <a href=\"https://github.com/MuYunyun/repromise\" target=\"_blank\" rel=\"noopener\">repromise</a></p>\n<p>本札记系列总共三篇文章，作为之前的文章 <a href=\"https://github.com/MuYunyun/blog/issues/7\" target=\"_blank\" rel=\"noopener\">Node.js 异步异闻录</a> 的拆分和矫正。</p>\n<ul>\n<li><a href=\"https://github.com/MuYunyun/blog/blob/master/BasicSkill/readES6/Promise札记.md\" target=\"_blank\" rel=\"noopener\">Promise札记</a></li>\n<li><a href=\"https://github.com/MuYunyun/blog/blob/master/BasicSkill/readES6/Generator札记.md\" target=\"_blank\" rel=\"noopener\">Generator札记</a></li>\n<li><a href=\"https://github.com/MuYunyun/blog/blob/master/BasicSkill/readES6/Async札记.md\" target=\"_blank\" rel=\"noopener\">Async札记</a></li>\n</ul>\n<h3 id=\"Promise-A-核心\"><a href=\"#Promise-A-核心\" class=\"headerlink\" title=\"Promise/A+ 核心\"></a>Promise/A+ 核心</h3><p><img src=\"http://with.muyunyun.cn/e1a0c15c44f9b014aa78d7b7620db474.jpg-200\" alt=\"\"></p>\n<p>在实现一个符合 Promise/A+ 规范的 promise 之前，先了解下 Promise/A+ 核心，想更全面地了解可以阅读 <a href=\"https://segmentfault.com/a/1190000002452115\" target=\"_blank\" rel=\"noopener\">Promise/A+规范</a></p>\n<ul>\n<li>Promise 操作只会处在 3 种状态的一种：未完成态(pending)、完成态(resolved) 和失败态(rejected);</li>\n<li>Promise 的状态只会出现从未完成态向完成态或失败态转化;</li>\n<li>Promise 的状态一旦转化，将不能被更改;</li>\n</ul>\n<h3 id=\"repromise-api-食用手册\"><a href=\"#repromise-api-食用手册\" class=\"headerlink\" title=\"repromise api 食用手册\"></a>repromise api 食用手册</h3><h4 id=\"Promise-resolve\"><a href=\"#Promise-resolve\" class=\"headerlink\" title=\"Promise.resolve()\"></a>Promise.resolve()</h4><p>Promise.resolve() 括号内有 4 种情况</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 跟 Promise 对象 */</span></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.resolve(<span class=\"built_in\">Promise</span>.resolve(<span class=\"number\">1</span>))</span><br><span class=\"line\"><span class=\"comment\">// Promise &#123;state: \"resolved\", data: 1, callbackQueue: Array(0)&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 跟 thenable 对象 */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> thenable = &#123;</span><br><span class=\"line\">  then: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    resolve(<span class=\"number\">1</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.resolve(thenable)</span><br><span class=\"line\"><span class=\"comment\">// Promise &#123;state: \"resolved\", data: 1, callbackQueue: Array(0)&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 普通参数 */</span></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.resolve(<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"comment\">// Promise &#123;state: \"resolved\", data: 1, callbackQueue: Array(0)&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 不跟参数 */</span></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.resolve()</span><br><span class=\"line\"><span class=\"comment\">// Promise &#123;state: \"resolved\", data: undefined, callbackQueue: Array(0)&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Promise-reject\"><a href=\"#Promise-reject\" class=\"headerlink\" title=\"Promise.reject()\"></a>Promise.reject()</h4><p>相较于 Promise.resolve()，Promise.reject() 原封不动地返回参数值</p>\n<h4 id=\"Promise-all-arr\"><a href=\"#Promise-all-arr\" class=\"headerlink\" title=\"Promise.all(arr)\"></a>Promise.all(arr)</h4><p>对于 Promise.all(arr) 来说，在参数数组中所有元素都变为决定态后，然后才返回新的 promise。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 以下 demo，请求两个 url，当两个异步请求返还结果后，再请求第三个 url</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> p1 = request(<span class=\"string\">`http://some.url.1`</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> p2 = request(<span class=\"string\">`http://some.url.2`</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.all([p1, p2])</span><br><span class=\"line\">  .then(<span class=\"function\">(<span class=\"params\">datas</span>) =&gt;</span> &#123; <span class=\"comment\">// 此处 datas 为调用 p1, p2 后的结果的数组</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> request(<span class=\"string\">`http://some.url.3?a=<span class=\"subst\">$&#123;datas[<span class=\"number\">0</span>]&#125;</span>&amp;b=<span class=\"subst\">$&#123;datas[<span class=\"number\">1</span>]&#125;</span>`</span>)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .then(<span class=\"function\">(<span class=\"params\">data</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(msg)</span><br><span class=\"line\">  &#125;)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Promise-race-arr\"><a href=\"#Promise-race-arr\" class=\"headerlink\" title=\"Promise.race(arr)\"></a>Promise.race(arr)</h4><p>对于 Promise.race(arr) 来说，只要参数数组有一个元素变为决定态，便返回新的 promise。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// race 译为竞争，同样是请求两个 url，当且仅当一个请求返还结果后，就请求第三个 url</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> p1 = request(<span class=\"string\">`http://some.url.1`</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> p2 = request(<span class=\"string\">`http://some.url.2`</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.race([p1, p2])</span><br><span class=\"line\">  .then(<span class=\"function\">(<span class=\"params\">data</span>) =&gt;</span> &#123; <span class=\"comment\">// 此处 data 取调用 p1, p2 后优先返回的结果</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> request(<span class=\"string\">`http://some.url.3?value=<span class=\"subst\">$&#123;data&#125;</span>`</span>)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .then(<span class=\"function\">(<span class=\"params\">data</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(data)</span><br><span class=\"line\">  &#125;)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Promise-wrap-fn-——-回调函数转-Promise\"><a href=\"#Promise-wrap-fn-——-回调函数转-Promise\" class=\"headerlink\" title=\"Promise.wrap(fn) —— 回调函数转 Promise\"></a>Promise.wrap(fn) —— 回调函数转 Promise</h4><p>通过下面这个案例，提供回调函数 Promise 化的思路。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">a, b, cb</span>) </span>&#123;</span><br><span class=\"line\">  ajax(</span><br><span class=\"line\">    <span class=\"string\">`http://some.url?a=<span class=\"subst\">$&#123;a&#125;</span>&amp;b=<span class=\"subst\">$&#123;b&#125;</span>`</span>,</span><br><span class=\"line\">    cb</span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">foo(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, data</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(err)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(data)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>如上是一个传统回调函数使用案例，只要使用 Promise.wrap() 包裹 foo 函数就对其完成了 promise 化，使用如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> promiseFoo = <span class=\"built_in\">Promise</span>.wrap(foo)</span><br><span class=\"line\"></span><br><span class=\"line\">promiseFoo(<span class=\"number\">1</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\">  .then(<span class=\"function\">(<span class=\"params\">data</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(data)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch(<span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(err)</span><br><span class=\"line\">  &#125;)</span><br></pre></td></tr></table></figure>\n\n<p>Promise.wrap 的实现逻辑也顺带列出来了：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Promise</span>.wrap = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> funtion() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> args = [].slice.call(<span class=\"built_in\">arguments</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      fn.apply(<span class=\"literal\">null</span>, args.concat(<span class=\"function\">(<span class=\"params\">err, data</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">          reject(err)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          resolve(data)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;))</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"then-catch-done\"><a href=\"#then-catch-done\" class=\"headerlink\" title=\"then/catch/done\"></a>then/catch/done</h4><p>这几个 api 比较简单，合起来一起带过</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Promise</span>.resolve(<span class=\"number\">1</span>)</span><br><span class=\"line\">  .then(<span class=\"function\">(<span class=\"params\">data</span>) =&gt;</span> &#123;<span class=\"built_in\">console</span>.log(data)&#125;, (err) =&gt; &#123;<span class=\"built_in\">console</span>.log(err)&#125;) <span class=\"comment\">// 链式调用，可以传一个参数(推荐)，也可以传两个参数</span></span><br><span class=\"line\">  .catch(<span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> &#123;<span class=\"built_in\">console</span>.log(err)&#125;) <span class=\"comment\">// 捕获链式调用中抛出的错误 || 捕获变为失败态的值</span></span><br><span class=\"line\">  .done()                             <span class=\"comment\">// 能捕获前面链式调用的错误(包括 catch 中)，可以传两个参数也可不传</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"实践过程总结\"><a href=\"#实践过程总结\" class=\"headerlink\" title=\"实践过程总结\"></a>实践过程总结</h3><h4 id=\"坑点-1：事件循环\"><a href=\"#坑点-1：事件循环\" class=\"headerlink\" title=\"坑点 1：事件循环\"></a>坑点 1：事件循环</h4><blockquote>\n<p>事件循环：同步队列执行完后，在指定时间后再执行异步队列的内容。</p>\n</blockquote>\n<p>之所以要单列事件循环，因为代码的执行顺序与其息息相关，此处用 setTimeout 来模拟事件循环；</p>\n<p>下面代码片段中，① 处执行完并不会马上执行 setTimeout() 中的代码(③)，而是此时有多少次 then 的调用，就会重新进入 ② 处多少次后，再进入 ③</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">excuteAsyncCallback(callback, value) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> that = <span class=\"keyword\">this</span></span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> res = callback(value) <span class=\"comment\">// ③</span></span><br><span class=\"line\">    that.excuteCallback(<span class=\"string\">'fulfilled'</span>, res)</span><br><span class=\"line\">  &#125;, <span class=\"number\">4</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">then(onResolved, onRejected) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> promise = <span class=\"keyword\">new</span> <span class=\"keyword\">this</span>.constructor()</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.state !== <span class=\"string\">'PENDING'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> callback = <span class=\"keyword\">this</span>.state === <span class=\"string\">'fulfilled'</span> ? onResolved : onRejected</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.excuteAsyncCallback.call(promise, callback, <span class=\"keyword\">this</span>.data)              <span class=\"comment\">// ①</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.callbackArr.push(<span class=\"keyword\">new</span> CallbackItem(promise, onResolved, onRejected)) <span class=\"comment\">// ②</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> promise</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"坑点-2：this-的指向问题\"><a href=\"#坑点-2：this-的指向问题\" class=\"headerlink\" title=\"坑点 2：this 的指向问题\"></a>坑点 2：this 的指向问题</h4><p>this.callbackArr.push() 中的 this 指向的是 ‘上一个’ promise，所以类 CallbackItem 中，this.promise 存储的是’下一个’ promise(then 对象)。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Promise</span> </span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  then(onResolved, onRejected) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> promise = <span class=\"keyword\">new</span> <span class=\"keyword\">this</span>.constructor()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.state !== <span class=\"string\">'PENDING'</span>) &#123;        <span class=\"comment\">// 第一次进入 then，状态是 RESOLVED 或者是 REJECTED</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> callback = <span class=\"keyword\">this</span>.state === <span class=\"string\">'fulfilled'</span> ? onResolved : onRejected</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.excuteAsyncCallback.call(promise, callback, <span class=\"keyword\">this</span>.data)  <span class=\"comment\">// 绑定 this 到 promise</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;                               <span class=\"comment\">// 从第二次开始以后，进入 then，状态是 PENDING</span></span><br><span class=\"line\">      <span class=\"keyword\">this</span>.callbackArr.push(<span class=\"keyword\">new</span> CallbackItem(promise, onResolved, onRejected)) <span class=\"comment\">// 这里的 this 也是指向‘上一个’ promise</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> promise</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CallbackItem</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(promise, onResolve, onReject) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.promise = promise <span class=\"comment\">// 相应地，这里存储的 promise 是来自下一个 then 的</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.onResolve = <span class=\"keyword\">typeof</span>(onResolve) === <span class=\"string\">'function'</span> ? onResolve : <span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.onReject = <span class=\"keyword\">typeof</span>(onRejected) === <span class=\"string\">'function'</span> ? onRejected : <span class=\"function\">(<span class=\"params\">rejected</span>) =&gt;</span> &#123;&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"more\"><a href=\"#more\" class=\"headerlink\" title=\"more\"></a>more</h3><p>实践的更多过程可以参考<a href=\"https://github.com/MuYunyun/repromise/tree/master/test\" target=\"_blank\" rel=\"noopener\">测试用例</a>。有好的意见欢迎交流。</p>\n","categories":["Promise"],"tags":["Promise"]},{"title":"React16.x特性剪辑","url":"/posts/b7beaf79/","content":"<p><img src=\"http://with.muyunyun.cn/5fcc4e9364e64a6ab9e082c5d5ab06e8.jpg-muyy\" alt=\"\"></p>\n<p>本文整理了 React 16.x 出现的耳目一新的概念与 api 以及应用场景。</p>\n<blockquote>\n<p>更多 React 系列文章可以订阅<a href=\"https://github.com/MuYunyun/blog\" target=\"_blank\" rel=\"noopener\">blog</a></p>\n</blockquote>\n<a id=\"more\"></a>\n\n<h3 id=\"16-0-Fiber\"><a href=\"#16-0-Fiber\" class=\"headerlink\" title=\"16.0 Fiber\"></a>16.0 Fiber</h3><p>he<br>在 16 之前的版本的渲染过程可以想象成一次性潜水 30 米，在这期间做不了其它事情(Stack Reconciler);</p>\n<p><img src=\"http://with.muyunyun.cn/39db8e34ec1ce048695c3bde132a739e.jpg-200\" alt=\"\"></p>\n<p>痛点概括:</p>\n<ul>\n<li>一次性渲染到底</li>\n<li>中途遇到优先级更高的事件无法调整相应的顺序</li>\n</ul>\n<p>在 16 版本上, React 带来了 Fiber 的架构, 接着拿上面的潜水例子为例，现在变为可以每次潜 10 米，分 3 个 chunk 进行; chunk 和 chunk 之间通过链表连接; chunk 间插入优先级更高的任务, 先前的任务被抛弃。</p>\n<p><img src=\"http://with.muyunyun.cn/02a6b5ac36b12b3c676157ef3985fe4a.jpg-200\" alt=\"\"></p>\n<blockquote>\n<p>开启 Fiber 后，获取异步数据的方法应放到 render 后面的生命周期钩子里(phase 2 阶段)进行, 因为 render 前面的生命周期钩子(phase 1阶段)会被执行多次</p>\n</blockquote>\n<blockquote>\n<p>注意: 并没有缩短原先组件的渲染时间(甚至还加长了)，但用户却能感觉操作变流畅了。</p>\n</blockquote>\n<h3 id=\"render\"><a href=\"#render\" class=\"headerlink\" title=\"render()\"></a>render()</h3><p>在 React16 版本中 render() 增加了一些返回类型，到目前为止支持的返回类型如下：</p>\n<ul>\n<li>React elements.</li>\n<li>Arrays and fragments.</li>\n<li>Portals.</li>\n<li>String and numbers.</li>\n<li>Booleans or null.</li>\n</ul>\n<blockquote>\n<p>[render](<a href=\"https://reactjs.org/docs/react-component.html#render]\" target=\"_blank\" rel=\"noopener\">https://reactjs.org/docs/react-component.html#render]</a></p>\n</blockquote>\n<p>其中 render() 支持返回 Arrays 能让我们少写一个父节点, 如下所示:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> renderArray = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> [</span><br><span class=\"line\">  &lt;div&gt;A&lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  &lt;div&gt;B&lt;/</span>div&gt;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>个人认为 render() 支持返回数组完全可以取代 <a href=\"https://reactjs.org/docs/fragments.html\" target=\"_blank\" rel=\"noopener\">Fragments</a></p>\n</blockquote>\n<h3 id=\"Portals-传送门\"><a href=\"#Portals-传送门\" class=\"headerlink\" title=\"Portals(传送门)\"></a>Portals(传送门)</h3><p>将 react 子节点渲染到指定的节点上</p>\n<p>案例：实现一个 Modal 组件，<a href=\"https://codepen.io/gaearon/pen/yzMaBd\" target=\"_blank\" rel=\"noopener\">demo</a></p>\n<p>另外关于 Portals 做到冒泡到父节点的兄弟节点这个现象, <a href=\"https://codepen.io/gaearon/pen/jGBWpE\" target=\"_blank\" rel=\"noopener\">demo</a>, 我想可以这样子实现：如果组件返回是 Portal 对象，则将该组件的父组件的上的事件 copy 到该组件上。其实并不是真的冒泡到了父节点的兄弟节点上。</p>\n<h3 id=\"Error-Boundaries\"><a href=\"#Error-Boundaries\" class=\"headerlink\" title=\"Error Boundaries\"></a>Error Boundaries</h3><p>React 16 提供了一个新的错误捕获钩子 <code>componentDidCatch(error, errorInfo)</code>, 它能将子组件生命周期里所抛出的错误捕获, 防止页面全局崩溃。<a href=\"https://codepen.io/gaearon/pen/wqvxGa?editors=0010\" target=\"_blank\" rel=\"noopener\">demo</a></p>\n<p>componentDidCatch 并不会捕获以下几种错误</p>\n<ul>\n<li>事件机制抛出的错误(事件里的错误并不会影响渲染)</li>\n<li>Error Boundaries 自身抛出的错误</li>\n<li>异步产生的错误</li>\n<li>服务端渲染</li>\n</ul>\n<h3 id=\"服务端渲染\"><a href=\"#服务端渲染\" class=\"headerlink\" title=\"服务端渲染\"></a>服务端渲染</h3><p>服务端渲染一般是作为最后的优化手段, 这里浅显(缺乏经验)谈下 React 16 在其上的优化。</p>\n<p>在 React 16 版本中引入了 <code>React.hydrate()</code>, 它的作用主要是将相关的事件<code>注水</code>进 <code>html</code> 页面中, 同时会比较前端生成的 <code>html</code> 和服务端传到前端的 <code>html</code> 的文本内容的差异, 如果两者不一致将前端产生的文本内容替换服务端生成的(忽略属性)。</p>\n<h3 id=\"支持自定义属性\"><a href=\"#支持自定义属性\" class=\"headerlink\" title=\"支持自定义属性\"></a>支持自定义属性</h3><p>在 React 16 版本中, 支持自定义属性(推荐 <code>data-xxx</code>), 因而 React 可以少维护一份 attribute 白名单, 这也是 React 16 体积减少的一个重要因素。</p>\n<h3 id=\"life-cycle\"><a href=\"#life-cycle\" class=\"headerlink\" title=\"life cycle\"></a>life cycle</h3><p>在 React 16.3 的版本中，新加入了两个生命周期：</p>\n<ul>\n<li><p><code>getDerivedStateFromProps(nextProps, prevState)</code>: 更加语义化, 用来替代 componentWillMount、componentWillReceiveProps(nextProps);</p>\n</li>\n<li><p><code>getSnapshotBeforeUpdate(prevProps, prevState)</code>: 可以将结果传入 componentDidUpdate 里, 从而达到 dom 数据统一。用来替代 componentWillUpdate()（缺点是 React 开启异步渲染后，componentWillUpdate() 与 componentDidUpdate() 间获取的 dom 会不统一;</p>\n</li>\n</ul>\n<h3 id=\"16-7-Hooks\"><a href=\"#16-7-Hooks\" class=\"headerlink\" title=\"16.7 Hooks\"></a>16.7 Hooks</h3><p>在 React 16.7 之前，React 有两种形式的组件，有状态组件(类)和无状态组件(函数)。Hooks 的意义就是赋能先前的无状态组件，让之变为有状态。这样一来更加契合了 React 所推崇的函数式编程。</p>\n<p>接下来梳理 Hooks 中最核心的 2 个 api, <code>useState</code> 和 <code>useEffect</code></p>\n<h4 id=\"useState\"><a href=\"#useState\" class=\"headerlink\" title=\"useState\"></a>useState</h4><p>useState 返回状态和一个更新状态的函数</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> [count, setCount] = useState(initialState)</span><br></pre></td></tr></table></figure>\n\n<p>使用 Hooks 相比之前用 class 的写法最直观的感受是更为简洁</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">App</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [count, setCount] = useState(<span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        Click me</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>button&gt;</span><br><span class=\"line\">    &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  )</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"useEffect-fn\"><a href=\"#useEffect-fn\" class=\"headerlink\" title=\"useEffect(fn)\"></a>useEffect(fn)</h4><p>在每次 render 后都会执行这个钩子。可以将它当成是 <code>componentDidMount</code>、<code>componentDidUpdate</code>、<code>componentWillUnmount</code> 的合集。因此使用 useEffect 比之前优越的地方在于：</p>\n<ol>\n<li>可以避免在 <code>componentDidMount、componentDidUpdate</code> 书写重复的代码;</li>\n<li>可以将关联逻辑写进一个 <code>useEffect</code>;(在以前得写进不同生命周期里);</li>\n</ol>\n<blockquote>\n<p>在上述提到的生命周期钩子之外，其它的钩子是否在 hooks 也有对应的方案或者舍弃了其它生命周期钩子, 后续进行观望。</p>\n</blockquote>\n","categories":["React"],"tags":["React"]},{"title":"React 现代化测试","url":"/posts/76ba81e7/","content":"<p><img src=\"http://with.muyunyun.cn/0bfbc9fe9777a4878ca19a1f80393bdf.jpg-muyy\" alt=\"\"></p>\n<a id=\"more\"></a>\n\n<h3 id=\"测试的动机\"><a href=\"#测试的动机\" class=\"headerlink\" title=\"测试的动机\"></a>测试的动机</h3><p>测试用例的书写是一个风险驱动的行为, 每当收到 Bug 报告时, 先写一个单元测试来暴露这个 Bug, 在日后的代码提交中, 若该测试用例是通过的, 开发者就能更为自信地确保程序不会再次出现此 bug。</p>\n<blockquote>\n<p>测试的动机是有效地提高开发者的自信心。</p>\n</blockquote>\n<h3 id=\"前端现代化测试模型\"><a href=\"#前端现代化测试模型\" class=\"headerlink\" title=\"前端现代化测试模型\"></a>前端现代化测试模型</h3><p>前端测试中有两种模型, <code>金字塔模型</code>与<code>奖杯模型</code>。</p>\n<p>金字塔模型摘自 <a href=\"https://martinfowler.com/bliki/TestPyramid.html\" target=\"_blank\" rel=\"noopener\">Martin Fowler’s blog</a>, 模型示意图如下:</p>\n<p><img src=\"http://with.muyunyun.cn/d97821c98ca86b161ac650198e6b44fd.jpg-300\" alt=\"\"></p>\n<p>金字塔模型自下而上分为单元测试、集成测试、UI 测试, 之所以是金字塔结构是因为单元测试的成本最低, 与之相对, UI 测试的成本最高。所以单元测试写的数量最多, UI 测试写的数量最少。同时需注意的是越是上层的测试, 其通过率给开发者带来的信心是越大的。</p>\n<p>奖杯模型摘自 Kent C. Dots 提出的 <a href=\"https://twitter.com/kentcdodds/status/960723172591992832?ref_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E960723172591992832&ref_url=https%3A%2F%2Fkentcdodds.com%2Fblog%2Fwrite-tests\" target=\"_blank\" rel=\"noopener\">The Testing Trophy</a>, 该模型是笔者比较认可的前端现代化测试模型, 模型示意图如下:</p>\n<p><img src=\"http://with.muyunyun.cn/0453d50194dfa1cbf7a4aeb70252c438.jpg-300\" alt=\"\"></p>\n<p>奖杯模型中自下而上分为静态测试、单元测试、集成测试、e2e 测试, 它们的职责大致如下:</p>\n<ul>\n<li><code>静态测试</code>: 在编写代码逻辑阶段时进行报错提示。(代表库: eslint、flow、TypeScript)</li>\n<li><code>单元测试</code>: 在奖杯模型中, 单元测试的职责是对一些边界情况或者特定的算法进行测试。(代表库: <a href=\"https://github.com/facebook/jest\" target=\"_blank\" rel=\"noopener\">jest</a>、<a href=\"https://github.com/mochajs/mocha\" target=\"_blank\" rel=\"noopener\">mocha</a>)</li>\n<li><code>集成测试</code>: 模拟用户的行为进行测试, 对网络请求、获取数据库的数据等依赖第三方环境的行为进行 mock。(代表库: <a href=\"https://github.com/facebook/jest\" target=\"_blank\" rel=\"noopener\">jest</a>、<a href=\"https://github.com/testing-library/react-testing-library\" target=\"_blank\" rel=\"noopener\">react-testing-library</a>)</li>\n<li><code>e2e 测试</code>: 模拟用户在真实环境上操作行为(包括网络请求、获取数据库数据等)的测试。(代表库: <a href=\"https://github.com/cypress-io/cypress\" target=\"_blank\" rel=\"noopener\">cypress</a>)</li>\n</ul>\n<p>越是上层的测试给开发者带来的自信是越大的, 与此同时, 越是下层的测试测试的效率是越高的。奖杯模型综合考虑了这两点因素, 可以看到其在集成测试中的占比是最高的。</p>\n<h3 id=\"基于用户行为去测试\"><a href=\"#基于用户行为去测试\" class=\"headerlink\" title=\"基于用户行为去测试\"></a>基于用户行为去测试</h3><p>书写测试用例是为了提高开发者对程序的自信心的, 但是很多时候书写测试用例给开发者带来了觉得在做无用功的沮丧。导致沮丧的感觉出现往往是因为开发者对组件的具体实现细节进行了测试, 如果换个角度站在用户的行为上进行测试则能极大提高测试效率。</p>\n<p>测试组件的具体细节会带来的两个问题:</p>\n<ol>\n<li>测试用例对代码<code>错误否定</code>;</li>\n<li>测试用例对代码<code>错误肯定</code>;</li>\n</ol>\n<p>以<code>轮播图组件</code>为例, 依次来看上述问题。轮播图组件伪代码如下:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Carousel</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  state = &#123;</span><br><span class=\"line\">    index: <span class=\"number\">0</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/* 跳转到指定的页数 */</span></span><br><span class=\"line\">  jump = <span class=\"function\">(<span class=\"params\">to: number</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">      index: to</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; index &#125; = <span class=\"keyword\">this</span>.state</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">      <span class=\"tag\">&lt;<span class=\"name\">Swipe</span> <span class=\"attr\">currentPage</span>=<span class=\"string\">&#123;index&#125;</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">      <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;()</span> =&gt;</span> this.jump(index + 1)&#125;&gt;下一页<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">      <span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>`当前位于第$&#123;index&#125;页`<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;/&gt;</span></span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如下是基于 <code>enzyme</code> 的 api 写的测试用例:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; mount &#125; <span class=\"keyword\">from</span> <span class=\"string\">'enzyme'</span></span><br><span class=\"line\"></span><br><span class=\"line\">describe(<span class=\"string\">'Carousel Test'</span>, () =&gt; &#123;</span><br><span class=\"line\">  it(<span class=\"string\">'test jump'</span>, () =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> wrapper = mount(<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Carousel</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">      <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>第一页<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">      <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>第二页<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">      <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>第三页<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;/<span class=\"name\">Carousel</span>&gt;</span></span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    expect(wrapper.state(<span class=\"string\">'index'</span>)).toBe(<span class=\"number\">0</span>)</span><br><span class=\"line\">    wrapper.instance().jump(<span class=\"number\">2</span>)</span><br><span class=\"line\">    expect((wrapper.state(<span class=\"string\">'index'</span>)).toBe(<span class=\"number\">2</span>)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>恭喜, 测试通过✅。某一天开发者觉得 <code>index</code> 的命名不妥, 对其重构将 <code>index</code> 更名为 <code>currentPage</code>, 此时代码如下:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Carousel</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  state = &#123;</span><br><span class=\"line\">    currentPage: <span class=\"number\">0</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/* 跳转到指定的页数 */</span></span><br><span class=\"line\">  jump = <span class=\"function\">(<span class=\"params\">to: number</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">      currentPage: to</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; currentPage &#125; = <span class=\"keyword\">this</span>.state</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">      <span class=\"tag\">&lt;<span class=\"name\">Swipe</span> <span class=\"attr\">currentPage</span>=<span class=\"string\">&#123;currentPage&#125;</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">      <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;()</span> =&gt;</span> this.jump(currentPage + 1)&#125;&gt;下一页<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">      <span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>`当前位于第$&#123;currentPage&#125;页`<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;/&gt;</span></span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>再次跑测试用例, 此时在 <code>expect(wrapper.state(&#39;index&#39;)).toBe(0)</code> 的地方抛出了错误❌, 这就是所谓的测试用例对代码进行了<code>错误否定</code>。因为这段代码对于使用方来说是不存在问题的, 但是测试用例却抛出错误, 此时开发者不得不做’无用功’来调整测试用例适配新代码。调整后的测试用例如下:</p>\n<figure class=\"highlight diff\"><table><tr><td class=\"code\"><pre><span class=\"line\">describe('Carousel Test', () =&gt; &#123;</span><br><span class=\"line\">  it('test jump', () =&gt; &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"deletion\">-   expect(wrapper.state('index')).toBe(0)</span></span><br><span class=\"line\"><span class=\"addition\">+   expect(wrapper.state('currentPage')).toBe(0)</span></span><br><span class=\"line\">    wrapper.instance().jump(2)</span><br><span class=\"line\"><span class=\"deletion\">-   expect((wrapper.state('index')).toBe(2)</span></span><br><span class=\"line\"><span class=\"addition\">+   expect((wrapper.state('currentPage')).toBe(2)</span></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>然后在某一天粗心的小明同学对代码做了以下改动:</p>\n<figure class=\"highlight diff\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Carousel extends React.Component &#123;</span><br><span class=\"line\">  state = &#123;</span><br><span class=\"line\">    currentPage: 0</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  /* 跳转到指定的页数 */</span><br><span class=\"line\">  jump = (to: number) =&gt; &#123;</span><br><span class=\"line\">    this.setState(&#123;</span><br><span class=\"line\">      currentPage: to</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    const &#123; currentPage &#125; = this.state</span><br><span class=\"line\">    return &lt;&gt;</span><br><span class=\"line\">      &lt;Swipe currentPage=&#123;currentPage&#125; /&gt;</span><br><span class=\"line\"><span class=\"deletion\">-     &lt;button onClick=&#123;() =&gt; this.jump(currentPage + 1)&#125;&gt;下一页&lt;/button&gt;</span></span><br><span class=\"line\"><span class=\"addition\">+     &lt;button onClick=&#123;this.jump(currentPage + 1)&#125;&gt;下一页&lt;/button&gt;</span></span><br><span class=\"line\">      &lt;span&gt;`当前位于第$&#123;index&#125;页`&lt;/span&gt;</span><br><span class=\"line\">    &lt;/&gt;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>小明同学跑了上述单测, 测试通过✅, 于是开心地提交了代码。结果上线后线上出现了问题! 这就是所谓测试用例对代码进行了<code>错误肯定</code>。因为测试用例测试了组件内部细节(此处为 <code>jump</code> 函数), 让小明误以为已经覆盖了全部场景。</p>\n<p>测试用例<code>错误否定</code>以及<code>错误肯定</code>都给开发者带来了挫败感与困扰, 究其原因是测试了组件内部的具体细节所至。而一个稳定可靠的测试用例应该脱离组件内部的实现细节, 越接近用户行为的测试用例能给开发者带来越充足的自信。相较于 enzyme, <a href=\"https://github.com/testing-library/react-testing-library\" target=\"_blank\" rel=\"noopener\">react-testing-library</a> 所提供的 api 更加贴近用户的使用行为, 使用其对上述测试用例进行重构:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; render, fireEvent &#125; <span class=\"keyword\">from</span> <span class=\"string\">'@testing-library/react'</span></span><br><span class=\"line\"></span><br><span class=\"line\">describe(<span class=\"string\">'Carousel Test'</span>, () =&gt; &#123;</span><br><span class=\"line\">  it(<span class=\"string\">'test jump'</span>, () =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; getByText &#125; = render(<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Carousel</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">      <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>第一页<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">      <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>第二页<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">      <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>第三页<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;/<span class=\"name\">Carousel</span>&gt;</span></span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    expect(getByText(<span class=\"regexp\">/当前位于第一页/</span>)).toBeInTheDocument()</span><br><span class=\"line\">    fireEvent.click(getByText(<span class=\"regexp\">/下一页/</span>))</span><br><span class=\"line\">    expect(getByText(<span class=\"regexp\">/当前位于第一页/</span>)).not.toBeInTheDocument()</span><br><span class=\"line\">    expect(getByText(<span class=\"regexp\">/当前位于第二页/</span>)).toBeInTheDocument()</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>关于 <code>react-testing-Library</code> 的用法总结将在下一章节 <a href=\"https://github.com/MuYunyun/blog/blob/master/React/测试/Jest与ReactTestingLibrary.md\" target=\"_blank\" rel=\"noopener\">Jest 与 react-testing-Library</a> 具体介绍。如果对 React 技术栈感兴趣, 欢迎关注<a href=\"https://github.com/MuYunyun/blog\" target=\"_blank\" rel=\"noopener\">个人博客</a>。</p>\n<h3 id=\"相关链接\"><a href=\"#相关链接\" class=\"headerlink\" title=\"相关链接\"></a>相关链接</h3><ul>\n<li><a href=\"https://kentcdodds.com/blog/write-tests\" target=\"_blank\" rel=\"noopener\">write-tests</a></li>\n<li><a href=\"https://reactjs.org/docs/testing-recipes.html\" target=\"_blank\" rel=\"noopener\">Testing</a></li>\n<li><a href=\"https://kentcdodds.com/blog/testing-implementation-details\" target=\"_blank\" rel=\"noopener\">Testing Implementation Details</a></li>\n<li><a href=\"https://kentcdodds.com/blog/why-i-never-use-shallow-rendering\" target=\"_blank\" rel=\"noopener\">why-i-never-use-shallow-rendering</a></li>\n<li><a href=\"https://blog.sapegin.me/all/react-testing-1-best-practices/\" target=\"_blank\" rel=\"noopener\">react-testing-1-best-practices</a></li>\n</ul>\n","categories":["React","测试"],"tags":["React"]},{"title":"redux middleware 源码分析","url":"/posts/7f9a92dc/","content":"<p><img src=\"http://with.muyunyun.cn/39bbe72c55363dedf1f69673a58e01cb.jpg-muyy\" alt=\"\"></p>\n<a id=\"more\"></a>\n\n<h3 id=\"middleware-的由来\"><a href=\"#middleware-的由来\" class=\"headerlink\" title=\"middleware 的由来\"></a>middleware 的由来</h3><p>在业务中需要打印每一个 action 信息来调试，又或者希望 dispatch 或 reducer 拥有异步请求的功能。面对这些场景时，一个个修改 dispatch 或 reducer 代码有些乏力，我们需要一个可组合的、自由增减的插件机制，Redux 借鉴了 Koa 中 middleware 的思想，利用它我们可以在前端应用中便捷地实现如日志打印、异步请求等功能。</p>\n<p><img src=\"http://with.muyunyun.cn/4ab33429ea461ba24367cc062039836c.jpg-200\" alt=\"\"></p>\n<p>比如在<a href=\"https://github.com/MuYunyun/reactSPA/blob/274c00870853638fb0f77df8497f911eb560b617/src/client/store/configureStore.dev.js#L14\" target=\"_blank\" rel=\"noopener\">项目</a>中，进行了如下调用后，redux 就集成了 thunk 函数调用以及打印日志的功能。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> thunk <span class=\"keyword\">from</span> <span class=\"string\">'redux-thunk'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> logger <span class=\"keyword\">from</span> <span class=\"string\">'../middleware/logger'</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> enhancer = applyMiddleware(thunk, logger),  <span class=\"comment\">// 以 redux-thunk、logger 中间件为例介绍中间件的使用</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> store = createStore(rootReducer, enhancer)</span><br></pre></td></tr></table></figure>\n\n<p>下面追本溯源，来分析下源码。</p>\n<h3 id=\"applyMiddleware-调用入口\"><a href=\"#applyMiddleware-调用入口\" class=\"headerlink\" title=\"applyMiddleware 调用入口\"></a>applyMiddleware 调用入口</h3><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createStore</span>(<span class=\"params\">reducer, preloadedState, enhancer</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 通过下面代码可以发现，如果 createStore 传入 2 个参数，第二个参数相当于就是 enhancer</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> preloadedState === <span class=\"string\">'function'</span> &amp;&amp; <span class=\"keyword\">typeof</span> enhancer === <span class=\"string\">'undefined'</span>) &#123;</span><br><span class=\"line\">    enhancer = preloadedState</span><br><span class=\"line\">    preloadedState = <span class=\"literal\">undefined</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> enhancer !== <span class=\"string\">'undefined'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> enhancer(createStore)(reducer, preloadedState)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>由上述 <a href=\"https://github.com/reactjs/redux/blob/55e77e88c98723f1883929458bb0144430108143/src/createStore.js#L33\" target=\"_blank\" rel=\"noopener\">createStore 源码</a>发现，applyMiddleware 会进行 <code>applyMiddleware(thunk, logger)(createStore)(reducer, preloadedState)</code> 的调用。</p>\n<p><a href=\"https://github.com/reactjs/redux/blob/55e77e88c98723f1883929458bb0144430108143/src/applyMiddleware.js#L20\" target=\"_blank\" rel=\"noopener\">applyMiddleware 源码</a>如下</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">applyMiddleware</span>(<span class=\"params\">...middlewares</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">createStore</span> =&gt;</span> <span class=\"function\">(<span class=\"params\">...args</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> store = createStore(...args)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> dispatch = store.dispatch</span><br><span class=\"line\">    <span class=\"keyword\">let</span> chain = []</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> middlewareAPI = &#123;</span><br><span class=\"line\">      getState: store.getState,                <span class=\"comment\">// 调用 redux 原生方法，获取状态</span></span><br><span class=\"line\">      dispatch: <span class=\"function\">(<span class=\"params\">...args</span>) =&gt;</span> dispatch(...args) <span class=\"comment\">// 调用 redux 原生 dispatch 方法</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 串行 middleware</span></span><br><span class=\"line\">    chain = middlewares.map(<span class=\"function\"><span class=\"params\">middleware</span> =&gt;</span> middleware(middlewareAPI))</span><br><span class=\"line\">    dispatch = compose(...chain)(store.dispatch)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      ...store,</span><br><span class=\"line\">      dispatch <span class=\"comment\">// 返回加工过的 dispatch</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以发现 applyMiddleware 的作用其实就是返回加工过的 dispatch，下面会着重分析 middlewares 是如何串行起来的以及 dispatch 是如何被加工的。</p>\n<h3 id=\"串行-middleware\"><a href=\"#串行-middleware\" class=\"headerlink\" title=\"串行 middleware\"></a>串行 middleware</h3><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> middlewareAPI = &#123;</span><br><span class=\"line\">  getState: store.getState,</span><br><span class=\"line\">  dispatch: <span class=\"function\">(<span class=\"params\">...args</span>) =&gt;</span> dispatch(...args)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">chain = middlewares.map(<span class=\"function\"><span class=\"params\">middleware</span> =&gt;</span> middleware(middlewareAPI))</span><br><span class=\"line\">dispatch = compose(...chain)(store.dispatch)</span><br></pre></td></tr></table></figure>\n\n<p>观察上述代码后发现每个 middleware 都会传入参数 middlewareAPI，来看下中间件 <a href=\"https://github.com/MuYunyun/reactSPA/blob/274c00870853638fb0f77df8497f911eb560b617/src/client/middleware/logger.js#L1\" target=\"_blank\" rel=\"noopener\">logger 的源码</a> 以及 <a href=\"https://github.com/gaearon/redux-thunk/blob/master/src/index.js\" target=\"_blank\" rel=\"noopener\">redux-thunk 的源码</a>, 发现中间件接受的第一个参数正是 ({ dispatch, getState })</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// logger 源码</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> (&#123; dispatch, getState &#125;) =&gt; <span class=\"function\"><span class=\"params\">next</span> =&gt;</span> <span class=\"function\"><span class=\"params\">action</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(action)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> next(action) <span class=\"comment\">// 经 compose 源码分析，此处 next 为 Store.dispatch</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// redux-thunk 源码</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> (&#123; dispatch, getState &#125;) =&gt; <span class=\"function\"><span class=\"params\">next</span> =&gt;</span> <span class=\"function\"><span class=\"params\">action</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> action === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> action(dispatch)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> next(action) <span class=\"comment\">// 此处 next 为 logger 中间件返回的 (action） =&gt; &#123;&#125; 函数</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"dispatch-是如何被加工的\"><a href=\"#dispatch-是如何被加工的\" class=\"headerlink\" title=\"dispatch 是如何被加工的\"></a>dispatch 是如何被加工的</h3><p>接着上个小节，在 <code>dispatch = compose(...chain)(store.dispatch)</code> 中发现了 compose 函数，来看下 <a href=\"https://github.com/reactjs/redux/blob/55e77e88c98723f1883929458bb0144430108143/src/compose.js#L12\" target=\"_blank\" rel=\"noopener\">compose 的源码</a></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">compose</span>(<span class=\"params\">...funcs</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> funcs.reduce(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> <span class=\"function\">(<span class=\"params\">...args</span>) =&gt;</span> a(b(...args)))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>compose 源码中的 <code>funcs.reduce((a, b) =&gt; (...args) =&gt; a(b(...args)))</code> 算是比较重要的一句，它的作用是返回组合参数后的函数，比如 compose(f, g, h) 等价于 (…args) =&gt; f(g(h(…args)))，效果图如下所示，调用 this.props.dispatch() 后，会调用相应的中间件，最终会调用 redux 原生的 store.dispatch()，并且可以看到中间件调用的形式类似数据结构中的栈(先进后出)。</p>\n<p><img src=\"http://with.muyunyun.cn/201a9431b32d9d9ac2ad5f6712206b3a.jpg-300\" alt=\"\"></p>\n<p>拿上个小节提到的 logger、redux-thunk 中间件为例，其 middleware 的内部串行调用方式如下，从而完成了 dispatch 功能的增强(支持如 <code>this.props.dispatch(func)</code> 的调用以及日志功能)。具体可以看 <a href=\"https://github.com/MuYunyun/reactSPA/blob/274c00870853638fb0f77df8497f911eb560b617/src/common/pages/music/index.js#L35\" target=\"_blank\" rel=\"noopener\">项目中的运用</a></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">action =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> action === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> action(dispatch)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (<span class=\"function\"><span class=\"params\">action</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(action)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> store.dispatch(action)</span><br><span class=\"line\">  &#125;)(action)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h3><p>深入React技术栈</p>\n","categories":["redux"],"tags":["redux","redux-middleware","redux-thunk"]},{"title":"2017 年终总结 —— 在路上","url":"/posts/b9cd3f63/","content":"<p><img src=\"http://with.muyunyun.cn/6114931ddce0b5e56ade13b45e2b3ec6.jpg-muyy\" alt=\"\"></p>\n<blockquote>\n<p>不久前年会主题征集活动中，我提交的主题是《在路上》，和骑手们一样，我们亦不是在路上呢？</p>\n</blockquote>\n<a id=\"more\"></a>\n\n<p>恰逢踏入社会一年之际写下第一篇年终总结，百感交集，有初融入团队的喜悦、有独自完成需求的兴奋、有一次次团建的畅饮也有过为自己能力不足的懊恼以及与好友离别的感伤。</p>\n<p>通过这篇总结，希望能记录些琐事，并给 2018 年的自己定下 promise。</p>\n<h3 id=\"启程\"><a href=\"#启程\" class=\"headerlink\" title=\"启程\"></a>启程</h3><p>按捺不住走出校园的兴奋，走入我达新世界的大门。当时未进公司的时候，在朋友圈中看到的小伙伴们的照片，当时心中一阵惊叹，”这么帅！！要拖后腿了”，不曾想到后来几个月和每个人发生的故事，已然成为生命中不可或缺的色彩了。时隔一年当再次回味这张照片时，似乎里面藏着初心。</p>\n<p><img src=\"http://with.muyunyun.cn/dd07286ed73f1c2f6091521254b9abf5.jpg-300\" alt=\"\"></p>\n<p>春节结束后公司如期举行了年会，我在倒数第二个节目中独奏了二胡~，前端部门的年会中奖率也是全公司最高的，一度让其他部门的人说是改了脚本o(╯□╰)o。运气也是实力的一部分吧，不过我没有中奖。再接着是为期 15 天的小黑屋封闭式开发快递模块，这也是我第一次感觉到了挫败感，让<a href=\"http://blog.5udou.cn/\" target=\"_blank\" rel=\"noopener\">林师傅</a>帮填了好多坑。期间李开复老师来参观我们公司，我也跑去趁了张合照。同时迎来了陪我渡过短暂岁月的小伙伴虾球。一只可爱的猫咪。现在在新主人家过得很好。</p>\n<h3 id=\"batman-amp-amp-hawkeye\"><a href=\"#batman-amp-amp-hawkeye\" class=\"headerlink\" title=\"batman &amp;&amp; hawkeye\"></a>batman &amp;&amp; hawkeye</h3><p>在往后的一段时间，前端部门内部进行了更细致的分工划分，我被划分到了直营业务组，主要负责 batman(客服关系系统) 以及 hawkeye(运维系统)的开发与维护，期间经历了并参与了 batman、hawkeye 的技术栈迭代，从老鹰眼的 reflux 到 redux，以及 batman 网关独立抽离成一个 ts 项目。为了更好的熟悉 react 全家桶的工作流程，五月份的时候在仿照 batman 和 hawkeye 写了个 <a href=\"https://github.com/MuYunyun/reactSPA\" target=\"_blank\" rel=\"noopener\">demo</a>，现在收获了几百的 Star，也算今年的一大收获吧。o(╯□╰)o</p>\n<p>下面谈谈今年在做项目的收获和成长：</p>\n<ul>\n<li>首先是带我进入了奇妙的 React 技术栈 和 ES6 世界，对相关的知识点进行了实践；</li>\n<li>能合理对组件进行拆分；</li>\n<li>对 JS 异步流程有了一定认知；</li>\n<li>对底层组件的设计有了一定的认知；</li>\n<li>对 git 多人合作的流程有了一定的实践；</li>\n<li>在遇到不懂的知识时学会进行翻相关文档以及阅读源码；</li>\n<li>最后在 npm 上尝试发布了<a href=\"https://github.com/MuYunyun/diana\" target=\"_blank\" rel=\"noopener\">第一个包</a>，并用到了 batman 中;</li>\n</ul>\n<p>谈完收获再来谈谈不足：</p>\n<ul>\n<li>知识点体系没有梳理成网，比较零散；</li>\n<li>知识面广度和深度都还欠缺;</li>\n<li>在项目优化的层面没有特别上心;</li>\n<li>在和别人交谈时，抓重点能力以及逻辑整合能力有待加强；</li>\n<li>效率不足，容易被琐事影响；</li>\n</ul>\n<h3 id=\"高山仰止\"><a href=\"#高山仰止\" class=\"headerlink\" title=\"高山仰止\"></a>高山仰止</h3><p>分享一位同行的博客中让我感慨良多的话：<code>行远自迩，登高自卑</code>。在写这篇总结前我曾以为这句话是说当你登高的途中看到比你站在更高更远处的人的时候会产生自卑感，现在不经莞尔一笑，<code>风起于青萍之末，浪成于微澜之间</code>，那些让我高高仰望的人不正是有着一颗常人难能企及的大毅力和大心脏吗？而我呢，希望能离那群人能近一点是一点吧。想到现在负责的项目名为 batman，突然谐音想到了 better-man。新年计划做一个让别人靠得住的 better-man。</p>\n<h3 id=\"番外随笔\"><a href=\"#番外随笔\" class=\"headerlink\" title=\"番外随笔\"></a>番外随笔</h3><p>今年刷了好多动漫，整体偏热血、玄幻类型，也入了 B 站刷了几部小清新动漫，如四月是你的谎言、宝石之国<del>，和朋友一起刷了几部有意义的电影，比如爱乐之城、寻梦环游记</del>；另外从 4 月份开始使用网易云音乐来，累计听了七八千首歌吧，基本码代码的时候都会带着耳机~，以英文歌、民谣为主，<a href=\"https://music.163.com/#/user/home?id=472504060\" target=\"_blank\" rel=\"noopener\">我的歌单如下</a>；</p>\n<p>在游戏方面发挥稳定，王者荣耀上了最强王者以及为团队拿下个冠军，不过感觉花了太多时间在上面，浪费了不少原定的计划~，不过也算是青春的成长吧。公司年假即将会去曼巴玩上一段时间，也将算是我第一次出国。</p>\n<p>看书方面主要是技术类的，大概阅读了 6、7 本，这个比较尴尬了，看书看得慢而且看过的知识点也不是完全吃透了，新年期待改善。个人产出方面也比较低产，翻译文章和原创文章加起来十几篇~，我把它们集合在了 <a href=\"https://github.com/MuYunyun/blog\" target=\"_blank\" rel=\"noopener\">blog</a>这个项目里。不过也有值得高兴的事，搭建了自己的博客，并且写文章的深度自己感觉有所提高(虽然依然菜)。然后很遗憾的是今年的技术交流会一场也没参加成，怪自己的消息不灵通加上水平的不足。</p>\n<h3 id=\"总结展望篇\"><a href=\"#总结展望篇\" class=\"headerlink\" title=\"总结展望篇\"></a>总结展望篇</h3><p>这部分是对自己打算要成为一个 better-man 的一个 promise 吧。就结合文章中提到的不足点进行相应的改善(自己想到解决方案的先记下来了)，也就是新年的计划。望监督。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">problen</th>\n<th align=\"center\">flag</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">知识点碎片化</td>\n<td align=\"center\">对已有的知识点进行思维脑图的整理，对将来的知识点也采取思维脑图的方式进行学习</td>\n</tr>\n<tr>\n<td align=\"center\">知识面广度和深度欠缺</td>\n<td align=\"center\">参与到一个千星 Star 的开源项目的改善，提高阅读源码的能力，阅读 6 本技术书籍，阅读 1 本非技术书籍</td>\n</tr>\n<tr>\n<td align=\"center\">项目优化方面没有用心</td>\n<td align=\"center\">课外学习积累相关方面知识并尝试用到公司项目中</td>\n</tr>\n<tr>\n<td align=\"center\">没去成技术交流会</td>\n<td align=\"center\">带有目的性地参加 1 到 2 场前端技术交流会</td>\n</tr>\n<tr>\n<td align=\"center\">沟通能力不足</td>\n<td align=\"center\">避免讲话结巴，加强语言组织能力和逻辑能力，没想清楚问题之前不要轻易回答</td>\n</tr>\n<tr>\n<td align=\"center\">效率不足</td>\n<td align=\"center\">加强自控能力，规定的时间做规定的事情，做到按时起睡，不晚于 8 点半起床</td>\n</tr>\n</tbody></table>\n","categories":["Annual Summary"],"tags":["Annual Summary"]},{"title":"2018 年度总结 —— 缘见","url":"/posts/24141498/","content":"<p><img src=\"http://with.muyunyun.cn/19d9a998a632b464fed6d929326b0271.jpg-muyy\" alt=\"\"></p>\n<blockquote>\n<p>度过在点我达两年欢快的时光，开启在拼多多的新的旅程。</p>\n</blockquote>\n<a id=\"more\"></a>\n\n<h3 id=\"life\"><a href=\"#life\" class=\"headerlink\" title=\"life\"></a>life</h3><p><img src=\"http://with.muyunyun.cn/cbc85e6d794d9e52b0f60aa6fa18950b.jpg-400\" alt=\"\"></p>\n<ul>\n<li>2 月: 在老家的方岩山上跨了年；</li>\n<li>3 月: 和 w 做了过山车；</li>\n<li>4 月：面基了 <a href=\"https://juejin.im/user/584d7a3e2f301e00572fb7fc\" target=\"_blank\" rel=\"noopener\">小小倩</a>; 参加了杭州的草莓音乐节；</li>\n<li>5 月：参加了掘金在杭的线下交流会, 初识<a href=\"https://juejin.im/user/58f87ae844d9040069ca7507\" target=\"_blank\" rel=\"noopener\">染陌</a>、<a href=\"https://juejin.im/user/58f876dc5c497d0058e38ae1\" target=\"_blank\" rel=\"noopener\">阿相</a>、静霞等掘金小伙伴，缘起；</li>\n<li>6 月：和小伙伴们游玩崇明岛，逛了魔都夜景；参加了 GraphQL 的专题技术分享, 和带我入门前端的 scott 老师握了手;</li>\n<li>9 月: 和小伙伴们在浙大玉泉校区参加 nodeparty;</li>\n<li>11 月：面基了刃捷兄，参加了 VueConf；加入<a href=\"https://github.com/frontend9\" target=\"_blank\" rel=\"noopener\">前端九部</a>；期间用脚本叫 r 起床并播报天气预报，脚本坚持了两周;</li>\n<li>12 月：去黄山山顶吃到了热腾腾的泡面; 在 nodeparty 上, 贺老对语言特性的深刻见解只有敬佩。</li>\n<li>1 月：接连两天的 SEE`、d2 大会除了干货满满，俨然成为了追星大会。见到了玉伯、张秋怡等大大的真容，和情封前辈进行了深度交流, 同时和九部的小伙伴也进行了线下聚餐。</li>\n</ul>\n<h3 id=\"Siren\"><a href=\"#Siren\" class=\"headerlink\" title=\"Siren\"></a>Siren</h3><p><code>Siren</code> 是星巴克 <code>Logo</code> 上双尾女海妖的名字。本意是希望星巴克的咖啡就像 <code>Siren</code> 的歌声那样美妙, 除此之外它还有个引申意 —— 克制欲望。</p>\n<p><img src=\"http://with.muyunyun.cn/aafa6d3e872bb6f9bef26b5ef6d228e5.jpg-400\" alt=\"\"></p>\n<p>18 年下半年的周末大多待在下城区金逸影城(也就是 18 年 <code>VueConf</code> 的举办地)的星巴克里看看书之类, 这家星巴克在喧嚣和安静之间保持了恰当好处, 坐在周围的可能是谈论艺术的大学教授，或者是带小朋友做作业的家长，又或者是看书的同学。自由、温馨，时间在这里可快可慢。</p>\n<p><img src=\"http://with.muyunyun.cn/f9b9be1e727cb817fc78668cc31b3191.jpg-400\" alt=\"\"></p>\n<h3 id=\"18-年-——-见闻色\"><a href=\"#18-年-——-见闻色\" class=\"headerlink\" title=\"18 年 —— 见闻色\"></a>18 年 —— 见闻色</h3><p>以下是对 <a href=\"http://muyunyun.cn/posts/b9cd3f63/\">18 年计划</a>的 review</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">flag</th>\n<th align=\"center\">完成情况</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">对知识点采取思维脑图的方式进行学习</td>\n<td align=\"center\">创建了 <a href=\"https://github.com/MuYunyun/blog\" target=\"_blank\" rel=\"noopener\">blog</a> 项目进行了知识点的整理输出</td>\n</tr>\n<tr>\n<td align=\"center\">参与到一个千星 Star 的开源项目的改善，提高阅读源码的能力，阅读 6 本技术书籍，1 本非技术书籍</td>\n<td align=\"center\">在开源项目的参与深度上有所欠缺, 书籍阅读指标基本达成</td>\n</tr>\n<tr>\n<td align=\"center\">课外学习积累相关方面知识并尝试用到公司项目中</td>\n<td align=\"center\">指标达成</td>\n</tr>\n<tr>\n<td align=\"center\">避免讲话结巴，加强语言组织能力和逻辑能力，没想清楚问题之前不要轻易回答</td>\n<td align=\"center\">沟通交流能力需持续加强</td>\n</tr>\n<tr>\n<td align=\"center\">加强自控能力, 规定的时间做规定的事情，做到按时起睡，不晚于 8 点半起床</td>\n<td align=\"center\">自控能力有所提高，按时起睡指标未达成</td>\n</tr>\n</tbody></table>\n<h3 id=\"19-年-——-武装色\"><a href=\"#19-年-——-武装色\" class=\"headerlink\" title=\"19 年 —— 武装色\"></a>19 年 —— 武装色</h3><ul>\n<li>阅读 5 本技术书籍，1 本非技术书籍，学习函数式编程</li>\n<li>落地一个有价值的项目</li>\n<li>深入 <code>React.js</code> 社区，提一次 pr</li>\n<li>研读 <code>node.js</code> 文档</li>\n<li>提升沟通交流能力, 做一次 party 分享</li>\n<li>请挚友喝星巴克(保底 12 杯)</li>\n</ul>\n<h3 id=\"感谢\"><a href=\"#感谢\" class=\"headerlink\" title=\"感谢\"></a>感谢</h3><p>感恩亦师亦友的愚安 boss, 以及给我帮助的点我达小伙伴们; 感激对我给予肯定的刃捷、明江前辈; 感激与我聊到凌晨的兵长兄; 感谢给我提供前行指引的死月、芙兰姐; 感谢掘金社区让我结识了小小倩、染陌、相学长等好友。感谢所有内推、面试过我的前辈, 让我认识到自己的不足。最后感谢所有杭州的朋友们，期待下次更好的遇见！</p>\n","categories":["Annual Summary"],"tags":["Annual Summary"]},{"title":"The Annual Summary Of 2019","url":"/posts/7837c1ae/","content":"<p>Time is flying, it arrives at the end of year again. This is my first year working in PinDuoDuo inc and it seems I arrive in the company yesterday. This point is a good chance to talk with(recognize) myself again. I try to conclude from <code>work</code>, <code>output</code>, <code>life</code> and <code>destination</code>.</p>\n<a id=\"more\"></a>\n\n<h3 id=\"Learn-from-work\"><a href=\"#Learn-from-work\" class=\"headerlink\" title=\"Learn from work\"></a>Learn from work</h3><p>The first course I learn from my team is about <code>starting with the end</code>. It means everything we do today is prepared for the tomorrow. In the other word, we should realize which period the thing we’re doing is in, and our team write summary every week to make sure the established goals become closer and closer.</p>\n<p>The second course I learn from the work is to try to <code>use English more</code>. There are so much rich resource in Medium, MDN, Frontend Masters and even in twitter. It’s the first time I met with so many foreigners engineer in the JSConf but I can’t talk with them fluently. It’s obviously using English skillfully will open your eyes and improve efficiency looking for some information.</p>\n<p>The last but most important is <code>how to communicate</code>. It’s artistic to describe something easily to make others understand. When arriving at our team at first, one of my leader’s advice is the best way to join in the team is to share —— sharing ideas, knowledge and feeling. My colleagues are so excellent I learn a lot from them in these technical sharing parties every week. At the meanwhile I also share some ideas in it.</p>\n<h3 id=\"Output-of-the-article\"><a href=\"#Output-of-the-article\" class=\"headerlink\" title=\"Output of the article\"></a>Output of the article</h3><p>There are ten new articles added to <a href=\"https://github.com/MuYunyun/blog\" target=\"_blank\" rel=\"noopener\">my blog</a>, the direction is to talk about React, JavaScript, CSS and so on. If there are mistakes in it, welcome <a href=\"https://github.com/MuYunyun/blog/issues/new\" target=\"_blank\" rel=\"noopener\">point out</a>.</p>\n<ul>\n<li><a href=\"http://muyunyun.cn/posts/8b09c168/\">Introduction To Functional Programming</a></li>\n<li><a href=\"http://muyunyun.cn/posts/9f41fc98/\">Do Search In Data Structure Of React Fiber</a></li>\n<li><a href=\"http://muyunyun.cn/posts/44b01006/\">Understand React Suspense deeply</a></li>\n<li><a href=\"http://muyunyun.cn/posts/ba7c84ae/\">You don’t know requestIdleCallback</a></li>\n<li><a href=\"http://muyunyun.cn/posts/290a4219/\">Deep into React Hooks</a></li>\n<li><a href=\"http://muyunyun.cn/posts/a1be1d41/\">How to make page run smoothly</a></li>\n<li><a href=\"http://muyunyun.cn/posts/32fb0f08/\">Deep into React Hooks —— Design Pattern</a></li>\n<li><a href=\"http://muyunyun.cn/posts/76ba81e7/\">Modern React test</a></li>\n<li><a href=\"http://muyunyun.cn/posts/8bdf2cdf/\">Learn Controlled Component and Uncontrolled Component Again</a></li>\n<li><a href=\"http://muyunyun.cn/posts/33fba87f/\">INHERITED AND NON-INHERITED IN CSS</a></li>\n</ul>\n<p>There will be more creative articles to add in the future. Let’s grow up together.</p>\n<h3 id=\"Life\"><a href=\"#Life\" class=\"headerlink\" title=\"Life\"></a>Life</h3><p>I enjoy the quiet time sitting in the Cafe the whole day in Saturday and it’s also nice to chat with friends or family there.</p>\n<p><img src=\"http://with.muyunyun.cn/65758e96048af8ff1fd619ba1abc834a.jpg-400\" alt=\"\"></p>\n<p>And in other some weekend days, I take part in some FE conferences this year —— <code>FDConf</code>, <code>VUE Conf</code>, <code>D2</code>, <code>SEE Conf</code> and so on. From these activities I learn some some new knowledge. For example, the article <a href=\"http://muyunyun.cn/posts/a1be1d41/\">How to make page run smoothly</a> is written after listening the sharing of Liu Bowen in FDConf. And luckily, I get the chance to take photo with <a href=\"https://twitter.com/youyuxi\" target=\"_blank\" rel=\"noopener\">Evan You</a> and get the<br>signature from him.</p>\n<p><img src=\"http://with.muyunyun.cn/27a9372dcab28c9c15e1b273096b2680.jpg-300\" alt=\"\"></p>\n<p>At the same time, it’s happy to meet with old friends and make with new friends in these activities.</p>\n<h3 id=\"Checklist-amp-amp-Destination\"><a href=\"#Checklist-amp-amp-Destination\" class=\"headerlink\" title=\"Checklist &amp;&amp; Destination\"></a>Checklist &amp;&amp; Destination</h3><p>Checking the plan of last year before making plans in new year.</p>\n<ul>\n<li>Reading <code>five</code> technical books and a not technical book, <del>learn Functional Programming</del>: It is a shame not achieve this target. Instead of reading the whole books, I read more single posts or chapters partly in the last year.</li>\n<li>Finishing <del>a valuable project</del>: There are some valuable projects in my daily work, they’re still in progress.</li>\n<li><del>Deep into <code>React</code> community</del>, submit a pr: There is some deep analyze in React this year, however it still needs making extra effort for making a pr;</li>\n<li>Deep <del>into the document of <code>Node.Js</code></del>: the work of this year is connected with UI and component more closely, so the document of Node.Js has no much chance reading in practice;</li>\n<li><del>Improving the skill of communication, do a sharing in a party</del>: The communication skill gets some improved, however it still needs be strengthened;</li>\n<li><del>Invite friends fro coffee(at least 12)</del></li>\n</ul>\n<p>Keeping going on in the new year. Here lists some direction.</p>\n<ul>\n<li>Keeping reading and writing. Creating more personal thoughts;</li>\n<li>Improving listening/writing skill in English continually;<ul>\n<li>Way: watching ten+ english movies and try to write some english posts.</li>\n</ul>\n</li>\n<li>Improving the basic skills in data structure and composition principle continually;</li>\n</ul>\n","categories":["Annual Summary"],"tags":["Annual Summary"]},{"title":"从 0 到 1 实现 React 系列 —— 1.JSX 和 Virtual DOM","url":"/posts/e9e32d3a/","content":"<p><img src=\"http://with.muyunyun.cn/9c461a61924ed0fecb6024a256671251.jpg-muyy\" alt=\"\"></p>\n<p>本系列文章在实现一个 cpreact 的同时帮助大家理顺 React 框架的核心内容(JSX/虚拟DOM/组件/生命周期/diff算法/setState/PureComponent/HOC/…) <a href=\"https://github.com/MuYunyun/cpreact\" target=\"_blank\" rel=\"noopener\">项目地址</a></p>\n<a id=\"more\"></a>\n\n<ul>\n<li><a href=\"https://github.com/MuYunyun/blog/issues/24\" target=\"_blank\" rel=\"noopener\">从 0 到 1 实现 React 系列 —— JSX 和 Virtual DOM</a></li>\n<li><a href=\"https://github.com/MuYunyun/blog/issues/25\" target=\"_blank\" rel=\"noopener\">从 0 到 1 实现 React 系列 —— 组件和 state|props</a></li>\n<li><a href=\"https://github.com/MuYunyun/blog/issues/26\" target=\"_blank\" rel=\"noopener\">从 0 到 1 实现 React 系列 —— 生命周期和 diff 算法</a></li>\n<li><a href=\"https://github.com/MuYunyun/blog/issues/27\" target=\"_blank\" rel=\"noopener\">从 0 到 1 实现 React 系列 —— 优化 setState 和 ref 的实现</a></li>\n<li><a href=\"https://github.com/MuYunyun/blog/issues/29\" target=\"_blank\" rel=\"noopener\">从 0 到 1 实现 React 系列 —— PureComponent 实现 &amp;&amp; HOC 探幽</a></li>\n</ul>\n<h3 id=\"环境准备\"><a href=\"#环境准备\" class=\"headerlink\" title=\"环境准备\"></a>环境准备</h3><p>项目打包工具选择了 parcel，使用其可以快速地进入项目开发的状态。<a href=\"https://parceljs.org/getting_started.html\" target=\"_blank\" rel=\"noopener\">快速开始</a></p>\n<p>此外需要安装以下 babel 插件：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"@babel/core\"</span>: <span class=\"string\">\"^7.0.0\"</span>,</span><br><span class=\"line\"><span class=\"string\">\"@babel/preset-env\"</span>: <span class=\"string\">\"^7.0.0\"</span>,</span><br><span class=\"line\"><span class=\"string\">\"@babel/preset-react\"</span>: <span class=\"string\">\"^7.0.0\"</span>,</span><br><span class=\"line\"><span class=\"string\">\"babel-loader\"</span>: <span class=\"string\">\"v8.0.0-beta.0\"</span>,</span><br></pre></td></tr></table></figure>\n\n<p>同时 <code>.babelrc</code> 配置如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"string\">\"presets\"</span>: [</span><br><span class=\"line\">\t\t[</span><br><span class=\"line\">\t\t\t<span class=\"string\">\"@babel/preset-env\"</span>,</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"string\">\"targets\"</span>: <span class=\"string\">\"&gt; 0.25%, not dead\"</span>,</span><br><span class=\"line\">\t\t\t\t<span class=\"string\">\"useBuiltIns\"</span>: <span class=\"string\">\"entry\"</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t],</span><br><span class=\"line\">\t\t[</span><br><span class=\"line\">\t\t\t<span class=\"string\">\"@babel/preset-react\"</span>, &#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"string\">\"pragma\"</span>: <span class=\"string\">\"cpreact.createElement\"</span> <span class=\"comment\">// 该参数传向 transform-react-jsx 插件，是前置的一个核心，后文有解释为什么使用 cpreact.createElement</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t]</span><br><span class=\"line\">\t]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>配置好 babel 后，接着提供两套打包工具的配置方案，读者可以自行选择。</p>\n<h4 id=\"方案-1：使用-webpack\"><a href=\"#方案-1：使用-webpack\" class=\"headerlink\" title=\"方案 1：使用 webpack\"></a>方案 1：使用 webpack</h4><p>webpack 拥有一个活跃的社区，提供了更为丰富的打包能力。</p>\n<p>首先安装以下模块：</p>\n<figure class=\"highlight 1c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"webpack\"</span>: <span class=\"string\">\"^4.17.2\"</span>,</span><br><span class=\"line\"><span class=\"string\">\"webpack-cli\"</span>: <span class=\"string\">\"^3.1.0\"</span>,</span><br><span class=\"line\"><span class=\"string\">\"webpack-dev-server\"</span>: <span class=\"string\">\"^3.1.8\"</span></span><br></pre></td></tr></table></figure>\n\n<p>在根目录的 <code>webpack.config.js</code> 配置如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> rootPath = path.resolve(__dirname)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  entry: path.resolve(rootPath, <span class=\"string\">'test'</span>, <span class=\"string\">'index.js'</span>),</span><br><span class=\"line\">  mode: <span class=\"string\">'development'</span>,</span><br><span class=\"line\">  devtool: <span class=\"string\">'inline-source-map'</span>,</span><br><span class=\"line\">  devServer: &#123;</span><br><span class=\"line\">    contentBase: <span class=\"string\">'./dist'</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  output: &#123;</span><br><span class=\"line\">    filename: <span class=\"string\">'cpreact.js'</span>,</span><br><span class=\"line\">    path: path.resolve(rootPath, <span class=\"string\">'dist'</span>),</span><br><span class=\"line\">    libraryTarget: <span class=\"string\">'umd'</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">    rules: [&#123;</span><br><span class=\"line\">      test: <span class=\"regexp\">/\\.js$/</span>,</span><br><span class=\"line\">      loader: <span class=\"string\">\"babel-loader\"</span>,</span><br><span class=\"line\">    &#125;]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后在 <code>package.json</code> 里加上如下配置：</p>\n<figure class=\"highlight 1c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"scripts\"</span>: &#123;</span><br><span class=\"line\">  <span class=\"string\">\"start\"</span>: <span class=\"string\">\"webpack-dev-server --open\"</span>,</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n\n<p>具体可以参照 <a href=\"https://github.com/MuYunyun/cpreact/blob/master/webpack.config.js\" target=\"_blank\" rel=\"noopener\">0.4.3 版本</a></p>\n<h4 id=\"方案-2：使用-parcel\"><a href=\"#方案-2：使用-parcel\" class=\"headerlink\" title=\"方案 2：使用 parcel\"></a>方案 2：使用 parcel</h4><p><a href=\"https://parceljs.org/getting_started.html\" target=\"_blank\" rel=\"noopener\">parcel</a> 是一款上手极快的打包工具，使用其可以快速地进入项目开发的状态。在 <code>package.json</code> 加上如下配置，具体可以参照 <a href=\"https://github.com/MuYunyun/cpreact/blob/0.1/package.json\" target=\"_blank\" rel=\"noopener\">0.1 版本</a></p>\n<figure class=\"highlight 1c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"scripts\"</span>: &#123;</span><br><span class=\"line\">  <span class=\"string\">\"start\"</span>: <span class=\"string\">\"parcel ./index.html --open -p 8080 --no-cache\"</span></span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"JSX-和-虚拟-DOM\"><a href=\"#JSX-和-虚拟-DOM\" class=\"headerlink\" title=\"JSX 和 虚拟 DOM\"></a>JSX 和 虚拟 DOM</h3><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> element = (</span><br><span class=\"line\">  &lt;div className=<span class=\"string\">\"title\"</span>&gt;</span><br><span class=\"line\">    hello&lt;span className=<span class=\"string\">\"content\"</span>&gt;world!&lt;<span class=\"regexp\">/span&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  &lt;/</span>div&gt;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p>JSX 是一种语法糖，经过 <a href=\"https://babeljs.io/en/repl\" target=\"_blank\" rel=\"noopener\">babel</a> 转换结果如下，可以发现实际上转化成 <code>React.createElement()</code> 的形式：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> element = React.createElement(</span><br><span class=\"line\">  <span class=\"string\">\"div\"</span>,</span><br><span class=\"line\">  &#123; <span class=\"attr\">className</span>: <span class=\"string\">\"title\"</span> &#125;,</span><br><span class=\"line\">  <span class=\"string\">\"hello\"</span>,</span><br><span class=\"line\">  React.createElement(</span><br><span class=\"line\">    <span class=\"string\">\"span\"</span>,</span><br><span class=\"line\">    &#123; <span class=\"attr\">className</span>: <span class=\"string\">\"content\"</span> &#125;,</span><br><span class=\"line\">    <span class=\"string\">\"world!\"</span></span><br><span class=\"line\">  )</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://preactjs.com/repl\" target=\"_blank\" rel=\"noopener\">打印</a> element, 结果如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  attributes: &#123;<span class=\"attr\">className</span>: <span class=\"string\">\"title\"</span>&#125;</span><br><span class=\"line\">  children: [<span class=\"string\">\"hello\"</span>, t] <span class=\"comment\">// t 和外层对象相同</span></span><br><span class=\"line\">  key: <span class=\"literal\">undefined</span></span><br><span class=\"line\">  nodeName: <span class=\"string\">\"div\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因此，我们得出结论：JSX 语法糖经过 Babel 编译后转换成一种对象，该对象即所谓的<code>虚拟 DOM</code>，使用虚拟 DOM 能让页面进行更为高效的渲染。</p>\n<p>我们按照这种思路进行函数的构造：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> React = &#123;</span><br><span class=\"line\">  createElement</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createElement</span>(<span class=\"params\">tag, attr, ...child</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    attributes: attr,</span><br><span class=\"line\">    children: child,</span><br><span class=\"line\">    key: <span class=\"literal\">undefined</span>,</span><br><span class=\"line\">    nodeName: tag,</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 测试</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> element = (</span><br><span class=\"line\">  &lt;div className=<span class=\"string\">\"title\"</span>&gt;</span><br><span class=\"line\">    hello&lt;span className=<span class=\"string\">\"content\"</span>&gt;world!&lt;<span class=\"regexp\">/span&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  &lt;/</span>div&gt;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(element) <span class=\"comment\">// 打印结果符合预期</span></span><br><span class=\"line\"><span class=\"comment\">// &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//   attributes: &#123;className: \"title\"&#125;</span></span><br><span class=\"line\"><span class=\"comment\">//   children: [\"hello\", t] // t 和外层对象相同</span></span><br><span class=\"line\"><span class=\"comment\">//   key: undefined</span></span><br><span class=\"line\"><span class=\"comment\">//   nodeName: \"div\"</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"虚拟-DOM-转化为真实-DOM\"><a href=\"#虚拟-DOM-转化为真实-DOM\" class=\"headerlink\" title=\"虚拟 DOM 转化为真实 DOM\"></a>虚拟 DOM 转化为真实 DOM</h3><p>上个小节介绍了 JSX 转化为虚拟 DOM 的过程，这个小节接着来实现将虚拟 DOM 转化为真实 DOM (页面上渲染的是真实 DOM)。</p>\n<p>我们知道在 React 中，将虚拟 DOM 转化为真实 DOM 是使用 <code>ReactDOM.render</code> 实现的，使用如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> ReactDOM <span class=\"keyword\">from</span> <span class=\"string\">'react-dom'</span></span><br><span class=\"line\"></span><br><span class=\"line\">ReactDOM.render(</span><br><span class=\"line\">  element, <span class=\"comment\">// 上文的 element，即虚拟 dom</span></span><br><span class=\"line\">  <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'root'</span>)</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p>接着来实现 <code>ReactDOM.render</code> 的逻辑:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> ReactDOM = &#123;</span><br><span class=\"line\">  render</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 将虚拟 DOM 转化为真实 DOM</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;*&#125;</span> </span>vdom      虚拟 DOM</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;*&#125;</span> </span>container 需要插入的位置</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">render</span>(<span class=\"params\">vdom, container</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (_.isString(vdom) || _.isNumber(vdom)) &#123;</span><br><span class=\"line\">    container.innerText = container.innerText + vdom <span class=\"comment\">// fix &lt;div&gt;I'm &#123;this.props.name&#125;&lt;/div&gt;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> dom = <span class=\"built_in\">document</span>.createElement(vdom.nodeName)</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> attr <span class=\"keyword\">in</span> vdom.attributes) &#123;</span><br><span class=\"line\">    setAttribute(dom, attr, vdom.attributes[attr])</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  vdom.children.forEach(<span class=\"function\"><span class=\"params\">vdomChild</span> =&gt;</span> render(vdomChild, dom))</span><br><span class=\"line\">  container.appendChild(dom)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 给节点设置属性</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;*&#125;</span> </span>dom   操作元素</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;*&#125;</span> </span>attr  操作元素属性</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;*&#125;</span> </span>value 操作元素值</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">setAttribute</span>(<span class=\"params\">dom, attr, value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (attr === <span class=\"string\">'className'</span>) &#123;</span><br><span class=\"line\">    attr = <span class=\"string\">'class'</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (attr.match(<span class=\"string\">'/on\\w+/'</span>)) &#123;   <span class=\"comment\">// 处理事件的属性:</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> eventName = attr.toLowerCase().substr(<span class=\"number\">2</span>)</span><br><span class=\"line\">    dom.addEventListener(eventName, value)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (attr === <span class=\"string\">'style'</span>) &#123; <span class=\"comment\">// 处理样式的属性:</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> styleStr = <span class=\"string\">''</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> standardCss</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> klass <span class=\"keyword\">in</span> value) &#123;</span><br><span class=\"line\">      standardCss = humpToStandard(klass) <span class=\"comment\">// 处理驼峰样式为标准样式</span></span><br><span class=\"line\">      value[klass] = _.isNumber(+value[klass]) ? value[klass] + <span class=\"string\">'px'</span> : value[klass] <span class=\"comment\">// style=&#123;&#123; className: '20' || '20px' &#125;&#125;&gt;</span></span><br><span class=\"line\">      styleStr += <span class=\"string\">`<span class=\"subst\">$&#123;standardCss&#125;</span>: <span class=\"subst\">$&#123;value[klass]&#125;</span>;`</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    dom.setAttribute(attr, styleStr)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;                       <span class=\"comment\">// 其它属性</span></span><br><span class=\"line\">    dom.setAttribute(attr, value)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>至此，我们成功将虚拟 DOM 复原为真实 DOM，展示如下：</p>\n<p><img src=\"http://with.muyunyun.cn/a898514bd3d08df4366e5ceb7843cddf.jpg-400\" alt=\"\"></p>\n<p>另外配合热更新，在热更新的时候清空之前的 dom 元素，改动如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> ReactDOM = &#123;</span><br><span class=\"line\">  render(vdom, container) &#123;</span><br><span class=\"line\">    container.innerHTML = <span class=\"literal\">null</span></span><br><span class=\"line\">    render(vdom, container)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p><code>JSX</code> 经过 babel 编译为 React.createElement() 的形式，其返回结果就是 <code>Virtual DOM</code>，最后通过 ReactDOM.render() 将 Virtual DOM 转化为真实的 DOM 展现在界面上。流程图如下：</p>\n<p><img src=\"http://with.muyunyun.cn/5e451855ccc9017708b57164f9e221c6.jpg-400\" alt=\"\"></p>\n<h3 id=\"思考题\"><a href=\"#思考题\" class=\"headerlink\" title=\"思考题\"></a>思考题</h3><p>如下是一个 react/preact 的常用组件的写法，那么为什么要 import 一个 React 或者 h 呢？</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span> <span class=\"comment\">// react</span></span><br><span class=\"line\"><span class=\"comment\">// import &#123; h, Component &#125; from 'preact' // preact</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>I'm componentA<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">render(<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">A</span> /&gt;</span></span>, <span class=\"built_in\">document</span>.body) <span class=\"comment\">// 组件的挂载</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"项目说明\"><a href=\"#项目说明\" class=\"headerlink\" title=\"项目说明\"></a>项目说明</h3><p>该系列文章会尽可能的分析项目细节，具体的还是以项目实际代码为准。</p>\n<h3 id=\"鸣谢\"><a href=\"#鸣谢\" class=\"headerlink\" title=\"鸣谢\"></a>鸣谢</h3><p>Especially thank <a href=\"https://github.com/hujiulong/simple-react\" target=\"_blank\" rel=\"noopener\">simple-react</a> for the guidance function of this library. At the meantime，respect for <a href=\"https://github.com/developit/preact\" target=\"_blank\" rel=\"noopener\">preact</a> and <a href=\"https://github.com/facebook/react\" target=\"_blank\" rel=\"noopener\">react</a></p>\n","categories":["React"],"tags":["React"]},{"title":"从 0 到 1 实现 React 系列 —— 4.setState优化和ref的实现","url":"/posts/55ccbd9e/","content":"<p><img src=\"http://with.muyunyun.cn/9c461a61924ed0fecb6024a256671251.jpg-muyy\" alt=\"\"></p>\n<p>本系列文章在实现一个 cpreact 的同时帮助大家理顺 React 框架的核心内容(JSX/虚拟DOM/组件/生命周期/diff算法/setState/PureComponent/HOC/…) <a href=\"https://github.com/MuYunyun/cpreact\" target=\"_blank\" rel=\"noopener\">项目地址</a></p>\n<a id=\"more\"></a>\n\n<ul>\n<li><a href=\"https://github.com/MuYunyun/blog/issues/24\" target=\"_blank\" rel=\"noopener\">从 0 到 1 实现 React 系列 —— JSX 和 Virtual DOM</a></li>\n<li><a href=\"https://github.com/MuYunyun/blog/issues/25\" target=\"_blank\" rel=\"noopener\">从 0 到 1 实现 React 系列 —— 组件和 state|props</a></li>\n<li><a href=\"https://github.com/MuYunyun/blog/issues/26\" target=\"_blank\" rel=\"noopener\">从 0 到 1 实现 React 系列 —— 生命周期和 diff 算法</a></li>\n<li><a href=\"https://github.com/MuYunyun/blog/issues/27\" target=\"_blank\" rel=\"noopener\">从 0 到 1 实现 React 系列 —— 优化 setState 和 ref 的实现</a></li>\n<li><a href=\"https://github.com/MuYunyun/blog/issues/29\" target=\"_blank\" rel=\"noopener\">从 0 到 1 实现 React 系列 —— PureComponent 实现 &amp;&amp; HOC 探幽</a></li>\n</ul>\n<h3 id=\"同步-setState-的问题\"><a href=\"#同步-setState-的问题\" class=\"headerlink\" title=\"同步 setState 的问题\"></a>同步 setState 的问题</h3><p>而在现有 setState 逻辑实现中，每调用一次 setState 就会执行 render 一次。因此在如下代码中，每次点击增加按钮，因为 click 方法里调用了 10 次 setState 函数，页面也会被渲染 10 次。而我们希望的是每点击一次增加按钮只执行 render 函数一次。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(props)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;</span><br><span class=\"line\">      count: <span class=\"number\">0</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.click = <span class=\"keyword\">this</span>.click.bind(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  click() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.setState(&#123; <span class=\"comment\">// 在先前的逻辑中，没调用一次 setState 就会 render 一次</span></span><br><span class=\"line\">        count: ++<span class=\"keyword\">this</span>.state.count</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.state.count)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;button onClick=&#123;<span class=\"keyword\">this</span>.click&#125;&gt;增加&lt;<span class=\"regexp\">/button&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;div&gt;&#123;this.state.count&#125;&lt;/</span>div&gt;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    )</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"异步调用-setState\"><a href=\"#异步调用-setState\" class=\"headerlink\" title=\"异步调用 setState\"></a>异步调用 setState</h3><p>查阅 setState 的 api，其形式如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">setState(updater, [callback])</span><br></pre></td></tr></table></figure>\n\n<p>它能接收两个参数，其中第一个参数 updater 可以为对象或者为函数 (<code>(prevState, props) =&gt; stateChange</code>)，第二个参数为回调函数；</p>\n<p>确定优化思路为：将多次 setState 后跟着的值进行浅合并，并借助事件循环等所有值合并好之后再进行渲染界面。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> componentArr = []</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 异步渲染</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">asyncRender</span>(<span class=\"params\">updater, component, cb</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (componentArr.length === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    defer(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> render())       <span class=\"comment\">// 利用事件循环，延迟渲染函数的调用</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (cb) defer(cb)             <span class=\"comment\">// 调用回调函数</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (_.isFunction(updater)) &#123;  <span class=\"comment\">// 处理 setState 后跟函数的情况</span></span><br><span class=\"line\">    updater = updater(component.state, component.props)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 浅合并逻辑</span></span><br><span class=\"line\">  component.state = <span class=\"built_in\">Object</span>.assign(&#123;&#125;, component.state, updater)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (componentArr.includes(component)) &#123;</span><br><span class=\"line\">    component.state = <span class=\"built_in\">Object</span>.assign(&#123;&#125;, component.state, updater)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    componentArr.push(component)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">render</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> component</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (component = componentArr.shift()) &#123;</span><br><span class=\"line\">    renderComponent(component) <span class=\"comment\">// rerender</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 事件循环，关于 promise 的事件循环和 setTimeout 的事件循环后续会单独写篇文章。</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> defer = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.resolve().then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> fn())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>此时，每点击一次增加按钮 render 函数只执行一次了。</p>\n<h3 id=\"ref-的实现\"><a href=\"#ref-的实现\" class=\"headerlink\" title=\"ref 的实现\"></a>ref 的实现</h3><p>在 react 中并不建议使用 ref 属性，而应该尽量使用<a href=\"https://doc.react-china.org/docs/lifting-state-up.html\" target=\"_blank\" rel=\"noopener\">状态提升</a>，但是 react 还是提供了 ref 属性赋予了开发者操作 dom 的能力，react 的 ref 有 <code>string</code>、<code>callback</code>、<code>createRef</code> 三种形式，分别如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// string 这种写法未来会被抛弃</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyComponent</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  componentDidMount() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.refs.myRef.focus()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"myRef\"</span> /&gt;</span></span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// callback(比较通用)</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyComponent</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  componentDidMount() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.myRef.focus()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">ref</span>=<span class=\"string\">&#123;(ele)</span> =&gt;</span> &#123;</span></span><br><span class=\"line\"><span class=\"xml\">      this.myRef = ele</span></span><br><span class=\"line\"><span class=\"xml\">    &#125;&#125; /&gt;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// react 16.3 增加，其它 react-like 框架还没有同步</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyComponent</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.myRef = React.createRef()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  componentDidMount() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.myRef.current.focus()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">ref</span>=<span class=\"string\">&#123;this.myRef&#125;</span> /&gt;</span></span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"https://zhuanlan.zhihu.com/p/40462264\" target=\"_blank\" rel=\"noopener\">React ref 的前世今生</a> 罗列了三种写法的差异，下面对上述例子中的第二种写法(比较通用)进行实现。</p>\n<p>首先在 setAttribute 方法内补充上对 ref 的属性进行特殊处理，</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">setAttribute</span>(<span class=\"params\">dom, attr, value</span>) </span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (attr === <span class=\"string\">'ref'</span>) &#123;          <span class=\"comment\">// 处理 ref 属性</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_.isFunction(value)) &#123;</span><br><span class=\"line\">      value(dom)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>针对这个例子中 <code>this.myRef.focus()</code> 的 focus 属性需要异步处理，因为调用 componentDidMount 的时候，界面上还未添加 dom 元素。处理 renderComponent 函数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">renderComponent</span>(<span class=\"params\">component</span>) </span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (component &amp;&amp; component.componentDidMount) &#123;</span><br><span class=\"line\">    defer(component.componentDidMount.bind(component))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>刷新页面，可以发现 input 框已为选中状态。</p>\n<p><img src=\"http://with.muyunyun.cn/d35589fbbff45a2437c6c13e24ba8058.jpg-200\" alt=\"\"></p>\n<p>处理完普通元素的 ref 后，再来处理下自定义组件的 ref 的情况。之前默认自定义组件上是没属性的，现在只要针对自定义组件的 ref 属性做相应处理即可。稍微修改 vdomToDom 函数如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">vdomToDom</span>(<span class=\"params\">vdom</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (_.isFunction(vdom.nodeName)) &#123; <span class=\"comment\">// 此时是自定义组件</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> attr <span class=\"keyword\">in</span> vdom.attributes) &#123; <span class=\"comment\">// 处理自定义组件的 ref 属性</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (attr === <span class=\"string\">'ref'</span> &amp;&amp; _.isFunction(vdom.attributes[attr])) &#123;</span><br><span class=\"line\">        vdom.attributes[attr](component)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>跑如下测试用例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>()</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;</span><br><span class=\"line\">      count: <span class=\"number\">0</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.click = <span class=\"keyword\">this</span>.click.bind(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  click() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">      count: ++<span class=\"keyword\">this</span>.state.count</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123;this.state.count&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>()</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.click = <span class=\"keyword\">this</span>.click.bind(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  click() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.A.click()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;button onClick=&#123;<span class=\"keyword\">this</span>.click&#125;&gt;加<span class=\"number\">1</span>&lt;<span class=\"regexp\">/button&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;A ref=&#123;(e) =&gt; &#123; this.A = e &#125;&#125; /</span>&gt;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    )</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>效果如下：</p>\n<p><img src=\"http://with.muyunyun.cn/reactref%E6%B5%8B%E8%AF%951\" alt=\"\"></p>\n<h3 id=\"鸣谢\"><a href=\"#鸣谢\" class=\"headerlink\" title=\"鸣谢\"></a>鸣谢</h3><p>Especially thank <a href=\"https://github.com/hujiulong/simple-react\" target=\"_blank\" rel=\"noopener\">simple-react</a> for the guidance function of this library. At the meantime，respect for <a href=\"https://github.com/developit/preact\" target=\"_blank\" rel=\"noopener\">preact</a> and <a href=\"https://github.com/facebook/react\" target=\"_blank\" rel=\"noopener\">react</a></p>\n","categories":["React"],"tags":["React"]},{"title":"从 0 到 1 实现 React 系列 —— 6.onChange 事件以及受控组件","url":"/posts/da72b66c/","content":"<p><img src=\"http://with.muyunyun.cn/9c461a61924ed0fecb6024a256671251.jpg-muyy\" alt=\"\"></p>\n<p>本系列文章在实现一个 cpreact 的同时帮助大家理顺 React 框架的核心内容(JSX/虚拟DOM/组件/生命周期/diff算法/setState/PureComponent/HOC/…) <a href=\"https://github.com/MuYunyun/cpreact\" target=\"_blank\" rel=\"noopener\">项目地址</a></p>\n<a id=\"more\"></a>\n\n<h3 id=\"从一个疑问点开始\"><a href=\"#从一个疑问点开始\" class=\"headerlink\" title=\"从一个疑问点开始\"></a>从一个疑问点开始</h3><p>接上一章 <a href=\"https://github.com/MuYunyun/blog/blob/master/从0到1实现React/8.HOC探索.md#属性代理props-proxy\" target=\"_blank\" rel=\"noopener\">HOC 探索</a> 抛出的问题 ———— react 中的 onChange 事件和原生 DOM 事件中的 onchange 表现不一致，举例说明如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// React 中的 onChange 事件</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(props)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.onChange = <span class=\"keyword\">this</span>.onChange.bind(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  onChange(e) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'键盘松开立刻执行'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;input onChange=&#123;<span class=\"keyword\">this</span>.onChange&#125; /&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*--------------分割线---------------*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 原生 DOM 事件中的 onchange 事件：&lt;input id='test'&gt;</span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'test'</span>).addEventListener(<span class=\"string\">'change'</span>, (e) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'键盘松开以后还需按下回车键或者点下鼠标才会触发'</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"拨云见雾\"><a href=\"#拨云见雾\" class=\"headerlink\" title=\"拨云见雾\"></a>拨云见雾</h3><p>我们来看下 React 的一个 issue <a href=\"https://github.com/facebook/react/issues/13525\" target=\"_blank\" rel=\"noopener\">React Fire: Modernizing React DOM</a>。有两点信息和这篇文章的话题相关。</p>\n<ul>\n<li>Drastically simplify the event system</li>\n<li>Migrate from onChange to onInput and don’t polyfill it for uncontrolled components</li>\n</ul>\n<p>从这两点内容我们可以得知下面的信息：</p>\n<p>React 实现了一套<a href=\"https://reactjs.org/docs/events.html#event-pooling\" target=\"_blank\" rel=\"noopener\">合成事件机制</a>，也就是它的事件机制和原生事件间会有不同。比如它目前 onChange 事件其实对应着原生事件中的 input 事件。在这个 issue 中明确了未来会使用 onInput 事件替代 onChange 事件，并且会大幅度地简化合成事件。</p>\n<p>有了以上信息后，我们对 onChange 事件(将来的 onInput 事件)的代码作如下更改：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">setAttribute</span>(<span class=\"params\">dom, attr, value</span>) </span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (attr.match(<span class=\"regexp\">/on\\w+/</span>)) &#123;        <span class=\"comment\">// 处理事件的属性:</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> eventName = attr.toLowerCase().substr(<span class=\"number\">2</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (eventName === <span class=\"string\">'change'</span>) &#123; eventName = <span class=\"string\">'input'</span> &#125; <span class=\"comment\">// 和现阶段的 react 统一</span></span><br><span class=\"line\">    dom.addEventListener(eventName, value)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"自由组件以及受控组件\"><a href=\"#自由组件以及受控组件\" class=\"headerlink\" title=\"自由组件以及受控组件\"></a>自由组件以及受控组件</h3><p>区分自由组件以及受控组件在于表单的值是否由 <code>value</code> 这个属性控制，比较如下代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> case1 = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">input</span> /&gt;</span></span>                    <span class=\"comment\">// 此时输入框内可以随意增减任意值</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> case2 = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">defaultValue</span>=<span class=\"string\">&#123;123&#125;</span> /&gt;</span></span> <span class=\"comment\">// 此时输入框内显示 123，能随意增减值</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> case3 = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">value</span>=<span class=\"string\">&#123;123&#125;</span> /&gt;</span></span>        <span class=\"comment\">// 此时输入框内显示 123，并且不能随意增减值</span></span><br></pre></td></tr></table></figure>\n\n<p><code>case3</code> 的情形即为简化版的受控组件。</p>\n<h3 id=\"受控组件的实现\"><a href=\"#受控组件的实现\" class=\"headerlink\" title=\"受控组件的实现\"></a>受控组件的实现</h3><p>题目可以换个问法：当 <code>input</code> 的传入属性为 <code>value</code> 时(且没有 onChange 属性)，如何禁用用户的输入事件的同时又能获取焦点?</p>\n<p><img src=\"http://with.muyunyun.cn/0fa301946b3f4bf315d742735c333562.jpg-200\" alt=\"\"></p>\n<p>首先想到了 html 自带属性 readonly、disable，它们都能禁止用户的输入，但是它们不能满足获取焦点这个条件。结合前文 <code>onChange</code> 的实现是监听 <code>input</code> 事件，代码分为以下两种情况：</p>\n<p>1.dom 节点包含 <code>value</code> 属性、<code>onChange</code> 属性<br>2.dom 节点包含 <code>value</code> 属性，不包含 <code>onChange</code> 属性</p>\n<p>代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">vdomToDom</span>(<span class=\"params\">vdom</span>) </span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (vdom.attributes</span><br><span class=\"line\">    &amp;&amp; vdom.attributes.hasOwnProperty(<span class=\"string\">'onChange'</span>)</span><br><span class=\"line\">    &amp;&amp; vdom.attributes.hasOwnProperty(<span class=\"string\">'value'</span>)) &#123; <span class=\"comment\">// 受控组件逻辑</span></span><br><span class=\"line\">      ...</span><br><span class=\"line\">      dom.addEventListener(<span class=\"string\">'input'</span>, (e) =&gt; &#123;</span><br><span class=\"line\">        changeCb.call(<span class=\"keyword\">this</span>, e)</span><br><span class=\"line\">        dom.value = oldValue</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">      ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (vdom.attributes</span><br><span class=\"line\">    &amp;&amp; !vdom.attributes.hasOwnProperty(<span class=\"string\">'onChange'</span>)</span><br><span class=\"line\">    &amp;&amp; vdom.attributes.hasOwnProperty(<span class=\"string\">'value'</span>)) &#123; <span class=\"comment\">// 受控组件逻辑</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">    dom.addEventListener(<span class=\"string\">'input'</span>, (e) =&gt; &#123;</span><br><span class=\"line\">      dom.value = oldValue</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以发现它们的核心都在这段代码上：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">dom.addEventListener(<span class=\"string\">'input'</span>, (e) =&gt; &#123;</span><br><span class=\"line\">  changeCb.call(<span class=\"keyword\">this</span>, e)</span><br><span class=\"line\">  dom.value = oldValue</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>区别是当有 <code>onChange 属性</code> 时，能提供相应的回调函数 <code>changeCb</code> 通过事件循环机制改变表单的值。看如下两个例子的比较：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> App = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">value</span>=<span class=\"string\">&#123;123&#125;</span> /&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<p>效果如下：</p>\n<p><img src=\"http://with.muyunyun.cn/353c8119b3c60a7f8f7696633c97ad28.jpg-200\" alt=\"\"></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>()</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = &#123; <span class=\"attr\">num</span>: <span class=\"number\">123</span> &#125;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.change = <span class=\"keyword\">this</span>.change.bind(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  change(e) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">      num: e.target.value</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;input value=&#123;<span class=\"keyword\">this</span>.state.num&#125; onChange=&#123;<span class=\"keyword\">this</span>.change&#125; /&gt;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    )</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>这段代码中的 <code>change</code> 函数即上个段落所谓的 <code>changeCb</code> 函数，通过 <code>setState</code> 的事件循环机制改变表单的值。</p>\n<p>效果如下：</p>\n<p><img src=\"http://with.muyunyun.cn/aec70ef0cebf603a0871d61f21e93532.gif\" alt=\"\"></p>\n<p>至此，模拟了受控组件的实现。</p>\n","categories":["React"],"tags":["React"]},{"title":"用 Node.js 把玩一番 Alfred Workflow","url":"/posts/4c23be51/","content":"<p><img src=\"http://with.muyunyun.cn/f27594afeda6b513ffec98c3e60ccbb0.jpg-muyy\" alt=\"\"></p>\n<blockquote>\n<p> <a href=\"https://github.com/MuYunyun/commonSearch\" target=\"_blank\" rel=\"noopener\">插件地址</a>(集成Github、掘金、知乎、淘宝等搜索)</p>\n</blockquote>\n<p>作为 Mac 上常年位居神器榜第一位的软件来说，Alfred 给我们带来的便利是不言而喻的，其中 workflow(工作流) 功不可没，在它上面可以轻松地查找任何 api；可以快速在豆瓣上搜到自己喜欢的电影、图书、音乐；可以快速把图片上传到图床 等等。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"一些安利\"><a href=\"#一些安利\" class=\"headerlink\" title=\"一些安利\"></a>一些安利</h2><p><img src=\"http://with.muyunyun.cn/482ccbbbcfb8f302851617a86dd6a5de.jpg-400\" alt=\"\"></p>\n<p>附上一张个人装着的插件的截图。Caffeinate 插件能在指定时间使电脑不黑屏；在 Dash 插件上能轻松查任何文档；Youdao Translate 插件比系统自带的翻译方便许多。插件也是因人而异，大家可以在 <a href=\"http://alfredworkflow.com/\" target=\"_blank\" rel=\"noopener\">Workflow List</a> 上逛逛，各取所需。</p>\n<p>在用了别人的插件感觉高大上后，便萌发了也写一个插件的想法，计划把自己常逛的网站集合成一个插件，使用特定的缩略词便可快速进行搜索数据，又看了官方称可以使用 bash, zsh, PHP, Ruby, Python, Perl, Apple Script 开发 Alfred Workflow。于是我选择了 Node.js 作为开发语言，开发了一款 <a href=\"https://github.com/MuYunyun/commonSearch\" target=\"_blank\" rel=\"noopener\">commonSearch</a>, 开发完效果如下(集成了Github、掘金、知乎、淘宝等搜索)。</p>\n<p><img src=\"http://with.muyunyun.cn/40a83edf9552b4a071dd2ff5093a445b.gif\" alt=\"\"></p>\n<h2 id=\"开发阶段\"><a href=\"#开发阶段\" class=\"headerlink\" title=\"开发阶段\"></a>开发阶段</h2><p>在开发前，得先对一些特定的操作步骤和知识点有一定的认知，这样开发时就基本上没有大碍了。</p>\n<h3 id=\"前置步骤\"><a href=\"#前置步骤\" class=\"headerlink\" title=\"前置步骤\"></a>前置步骤</h3><p>可以先参考 <a href=\"http://allenwu.itscoder.com/how-to-write-a-workflow-for-mac\" target=\"_blank\" rel=\"noopener\">如何去写一个第三方的 workflow</a> 的开始部分, 完成基本工作流的搭建，如下图是我搭建好的基本工作流连线。</p>\n<p><img src=\"http://with.muyunyun.cn/f27594afeda6b513ffec98c3e60ccbb0.jpg-400\" alt=\"\"></p>\n<p>在 Script 中，可以看到 <code>/usr/local/bin/node common_search.js</code> 相当于就是在调用该插件的时候起了一个 node 服务，后面的 <code>1</code> 是为了区分当前调用的是哪个搜索手动传入 <code>common_search.js</code> 的，<code>{query}</code> 则是用户查询的名称。</p>\n<p><img src=\"http://with.muyunyun.cn/39ab06f7fbd80e5723e9abc4b595b930.jpg-400\" alt=\"\"></p>\n<h3 id=\"使用-Node-js-调用-JSON-API\"><a href=\"#使用-Node-js-调用-JSON-API\" class=\"headerlink\" title=\"使用 Node.js 调用 JSON API\"></a>使用 Node.js 调用 JSON API</h3><p>最初开发参考了 <a href=\"https://github.com/RebeccaHanjw/zhihu_search_alfred_workflow\" target=\"_blank\" rel=\"noopener\">知乎搜索</a> 这个项目，它是基于 <a href=\"https://github.com/cheeriojs/cheerio\" target=\"_blank\" rel=\"noopener\">cheerio</a> 这个模块对请求到的网页数据进行分析爬取，但是引入了 cheerio 后，插件体积多了 2M 多，这对于一个插件来说太不友好了，所以这可能是 python 之类的语言更适合开发类似插件的原因吧(猜想:python 不需要引人第三方库就能进行爬虫)，于是我开始选择提供 JSON API 的接口，比如找寻掘金返回数据的接口。首先打开 chrome 控制台，这可能对前端工程师比较熟悉了。</p>\n<p><img src=\"http://with.muyunyun.cn/6151c3ab055e196ac43e63377940bfdb.jpg-muyy\" alt=\"\"></p>\n<p>从而找到了掘金返回搜索数据的接口是  <code>https://search-merger-ms.juejin.im/v1/search?query={query}&amp;page=0&amp;raw_result=false&amp;src=web</code></p>\n<p>接着愉快地使用 node 提供的 https 模块，这里有一个注意点，http.get() 回调中的 res 参数不是正文，而是 http.ClientResponse 对象，所以我们需要组装内容。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> options = &#123;</span><br><span class=\"line\">    host: <span class=\"string\">'search-merger-ms.juejin.im'</span>,</span><br><span class=\"line\">    path: <span class=\"string\">'/v1/search?query='</span> + <span class=\"built_in\">encodeURI</span>(keyword) + <span class=\"string\">'&amp;page=0&amp;raw_result=false&amp;src=web'</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  https.get(options, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">res</span>) </span>&#123;</span><br><span class=\"line\">    res.on(<span class=\"string\">'data'</span>, (chunk) =&gt; &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> content += chunk</span><br><span class=\"line\">    &#125;).on(<span class=\"string\">'end'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> jsonContent = <span class=\"built_in\">JSON</span>.parse(content) &amp;&amp; <span class=\"built_in\">JSON</span>.parse(content).d</span><br><span class=\"line\">      <span class=\"keyword\">var</span> result_array = []</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; jsonContent.length; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (jsonContent[i].user.jobTitle === <span class=\"string\">''</span>) &#123;</span><br><span class=\"line\">          result_array.push(&#123;</span><br><span class=\"line\">            title:</span><br><span class=\"line\">            subtitle:</span><br><span class=\"line\">            arg:</span><br><span class=\"line\">            icon: &#123;</span><br><span class=\"line\">              path: join(__dirname, <span class=\"string\">'xx.png'</span>),</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            mods: &#123;</span><br><span class=\"line\">              cmd: &#123;&#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      content = <span class=\"string\">''</span></span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"built_in\">JSON</span>.stringify(&#123;</span><br><span class=\"line\">        items: result_array</span><br><span class=\"line\">      &#125;))</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;)</span><br></pre></td></tr></table></figure>\n\n<p>这种方法应该是最直接的调用 JSON API 的方案了，当然也可以引人第三方模块 request 后解析 JSON，示例如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> request = <span class=\"built_in\">require</span>(<span class=\"string\">'request'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"string\">'search-merger-ms.juejin.im/v1/search?query='</span> + <span class=\"built_in\">encodeURI</span>(keyword) + <span class=\"string\">'&amp;page=0&amp;raw_result=false&amp;src=web'</span></span><br><span class=\"line\"></span><br><span class=\"line\">request.get(&#123;</span><br><span class=\"line\">    url: url,</span><br><span class=\"line\">    json: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    headers: &#123;<span class=\"string\">'User-Agent'</span>: <span class=\"string\">'request'</span>&#125;</span><br><span class=\"line\">  &#125;, (err, res, data) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'Error:'</span>, err);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (res.statusCode !== <span class=\"number\">200</span>) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'Status:'</span>, res.statusCode);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// data is already parsed as JSON:</span></span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(data.html_url);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>还有一点要注意的是返回值的字段是固定的，具体可以参考它的<a href=\"https://www.alfredapp.com/help/workflows/inputs/script-filter/xml/\" target=\"_blank\" rel=\"noopener\">官方解释</a>，琢磨了好久才把 JS 中的 Icon 自定义的格式找出来。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">title: 主标题</span><br><span class=\"line\">subtitle: 内容行</span><br><span class=\"line\">arg: 跳转链接</span><br><span class=\"line\">icons: 图标</span><br><span class=\"line\">mods：定制键盘按键的方法</span><br></pre></td></tr></table></figure>\n\n<p>对于 Github、掘金、知乎、淘宝的搜索都是基于以上思路进行开发的，就是对于具体返回的 JSON 数据进行了不同处理，虽然粗糙，但也算完成了第一个 Alfred Workflow 插件的开发。</p>\n<h2 id=\"尾声\"><a href=\"#尾声\" class=\"headerlink\" title=\"尾声\"></a>尾声</h2><p>本文的知识点写的不是特别丰满，一是就是对开发这个插件的小结，另外就是抛砖引玉了，能让更多的小伙伴了解开发一个插件并不是难事，同时让更多的朋友开发出更多有意义，有趣的 alfred-workflow 插件也算是本文分享的一个初衷了。</p>\n","categories":["Node.js"],"tags":["Node.js","alfred workflow"]},{"title":"原生 JS 实现一个瀑布流插件","url":"/posts/16b9cce7/","content":"<p><img src=\"http://with.muyunyun.cn/74f00b858ebdc430e780aa1da6ca0ce1.jpg-muyy\" alt=\"\"></p>\n<p>瀑布流布局中的图片有一个核心特点 —— 等宽不定等高，瀑布流布局在国内外网站都有一定规模的使用，比如<a href=\"https://www.pinterest.com/\" target=\"_blank\" rel=\"noopener\">pinterest</a>、<a href=\"http://huaban.com/\" target=\"_blank\" rel=\"noopener\">花瓣网</a>等等。那么接下来就基于这个特点开始瀑布流探索之旅。</p>\n<a id=\"more\"></a>\n\n<h3 id=\"基础功能实现\"><a href=\"#基础功能实现\" class=\"headerlink\" title=\"基础功能实现\"></a>基础功能实现</h3><p>首先我们定义好一个有 20 张图片的容器，</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\"><span class=\"css\">    <span class=\"selector-id\">#waterfall</span> &#123;</span></span><br><span class=\"line\">      position: relative;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"css\">    <span class=\"selector-class\">.waterfall-box</span> &#123;</span></span><br><span class=\"line\">      float: left;</span><br><span class=\"line\">      width: 200px;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"waterfall\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"images/1.png\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"waterfall-box\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"images/2.png\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"waterfall-box\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"images/3.png\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"waterfall-box\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"images/4.png\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"waterfall-box\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"images/5.png\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"waterfall-box\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"images/6.png\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"waterfall-box\"</span>&gt;</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"http://with.muyunyun.cn/88935550542f9cc012151460095d9579.jpg-300\" alt=\"\"></p>\n<p>由于未知的 css 知识点，丝袜最长的妹子把下面的空间都占用掉了。。。</p>\n<p>接着正文，假如如上图，每排有 5 列，那第 6 张图片应该出现前 5 张图片哪张的下面呢？当然是绝对定位到前 5 张图片高度最小的图片下方。</p>\n<p>那第 7 张图片呢？这时候把第 6 张图片和在它上面的图片当作是一个整体后，思路和上述是一致的。代码实现如下:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">Waterfall.prototype.init = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"keyword\">const</span> perNum = <span class=\"keyword\">this</span>.getPerNum() <span class=\"comment\">// 获取每排图片数</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> perList = []              <span class=\"comment\">// 存储第一列的各图片的高度</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; perNum; i++) &#123;</span><br><span class=\"line\">    perList.push(imgList[i].offsetHeight)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> pointer = <span class=\"keyword\">this</span>.getMinPointer(perList) <span class=\"comment\">// 求出当前最小高度的数组下标</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = perNum; i &lt; imgList.length; i++) &#123;</span><br><span class=\"line\">    imgList[i].style.position = <span class=\"string\">'absolute'</span> <span class=\"comment\">// 核心语句</span></span><br><span class=\"line\">    imgList[i].style.left = <span class=\"string\">`<span class=\"subst\">$&#123;imgList[pointer].offsetLeft&#125;</span>px`</span></span><br><span class=\"line\">    imgList[i].style.top = <span class=\"string\">`<span class=\"subst\">$&#123;perList[pointer]&#125;</span>px`</span></span><br><span class=\"line\"></span><br><span class=\"line\">    perList[pointer] = perList[pointer] + imgList[i].offsetHeight <span class=\"comment\">// 数组最小的值加上相应图片的高度</span></span><br><span class=\"line\">    pointer = <span class=\"keyword\">this</span>.getMinPointer(perList)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>细心的朋友也许发现了代码中获取图片的高度用到了 <code>offsetHeight</code> 这个属性，这个属性的高度之和等于<code>图片高度 + 内边距 + 边框</code>，正因为此，我们用了 padding 而不是 margin 来设置图片与图片之间的距离。此外除了<code>offsetHeight</code> 属性，此外还要理解 <code>offsetHeight</code>、<code>clientHeight</code>、<code>offsetTop</code>、<code>scrollTop</code> 等属性的区别，才能比较好的理解这个项目。css 代码简单如下：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.waterfall-box</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">float</span>: left;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">padding-left</span>: <span class=\"number\">10px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">padding-bottom</span>: <span class=\"number\">10px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>至此完成了瀑布流的基本布局，效果图如下：</p>\n<p><img src=\"http://with.muyunyun.cn/74f00b858ebdc430e780aa1da6ca0ce1.jpg-300\" alt=\"\"></p>\n<h3 id=\"scroll、resize-事件监听的实现\"><a href=\"#scroll、resize-事件监听的实现\" class=\"headerlink\" title=\"scroll、resize 事件监听的实现\"></a>scroll、resize 事件监听的实现</h3><p>实现了初始化函数 init 以后，下一步就要实现对 scroll 滚动事件进行监听，从而实现当滚到父节点的底部有源源不断的图片被加载出来的效果。这时候要考虑一个点，是滚动到什么位置时触发加载函数呢？这个因人而异，我的做法是当满足 <code>父容器高度 + 滚动距离 &gt; 最后一张图片的 offsetTop</code> 这个条件，即橙色线条 + 紫色线条 &gt; 蓝色线条时触发加载函数，代码如下：</p>\n<p><img src=\"http://with.muyunyun.cn/c8cda4bb070a7739eeec0fc968e91a1b.jpg-300\" alt=\"\"></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.onscroll = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (scrollPX + bsHeight &gt; imgList[imgList.length - <span class=\"number\">1</span>].offsetTop) &#123;<span class=\"comment\">// 浏览器高度 + 滚动距离 &gt; 最后一张图片的 offsetTop</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> fragment = <span class=\"built_in\">document</span>.createDocumentFragment()</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">20</span>; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> img = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'img'</span>)</span><br><span class=\"line\">      img.setAttribute(<span class=\"string\">'src'</span>, <span class=\"string\">`images/<span class=\"subst\">$&#123;i+<span class=\"number\">1</span>&#125;</span>.png`</span>)</span><br><span class=\"line\">      img.setAttribute(<span class=\"string\">'class'</span>, <span class=\"string\">'waterfall-box'</span>)</span><br><span class=\"line\">      fragment.appendChild(img)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    $waterfall.appendChild(fragment)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因为父节点可能自定义节点，所以提供了对监听 scroll 函数的封装，代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">proto.bind = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> bindScrollElem = <span class=\"built_in\">document</span>.getElementById(<span class=\"keyword\">this</span>.opts.scrollElem)</span><br><span class=\"line\">  util.addEventListener(bindScrollElem || <span class=\"built_in\">window</span>, <span class=\"string\">'scroll'</span>, scroll.bind(<span class=\"keyword\">this</span>))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> util = &#123;</span><br><span class=\"line\">  addEventListener: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">elem, evName, func</span>) </span>&#123;</span><br><span class=\"line\">    elem.addEventListener(evName, func, <span class=\"literal\">false</span>)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>resize 事件的监听与 scroll 事件监听大同小异，当触发了 resize 函数，调用 init 函数进行重置就行。</p>\n<h3 id=\"使用发布-订阅模式和继承实现监听绑定\"><a href=\"#使用发布-订阅模式和继承实现监听绑定\" class=\"headerlink\" title=\"使用发布-订阅模式和继承实现监听绑定\"></a>使用发布-订阅模式和继承实现监听绑定</h3><p>既然以开发插件为目标，不能仅仅满足于功能的实现，还要留出相应的操作空间给开发者自行处理。联想到业务场景中瀑布流中下拉加载的图片一般都来自 Ajax 异步获取，那么加载的数据必然不能写死在库里，期望能实现如下调用(此处借鉴了 <a href=\"https://github.com/mqyqingfeng/waterfall\" target=\"_blank\" rel=\"noopener\">waterfall</a> 的使用方式)，</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> waterfall = <span class=\"keyword\">new</span> Waterfall(&#123;options&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">waterfall.on(<span class=\"string\">\"load\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 此处进行 ajax 同步/异步添加图片</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>观察调用方式，不难联想到使用发布/订阅模式来实现它，关于发布/订阅模式，之前在 <a href=\"https://github.com/MuYunyun/fe_cloud/issues/7\" target=\"_blank\" rel=\"noopener\">Node.js 异步异闻录</a> 有介绍它。其核心思想即通过订阅函数将函数添加到缓存中，然后通过发布函数实现异步调用，下面给出其代码实现:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">eventEmitter</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.sub = &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">eventEmitter.prototype.on = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">eventName, func</span>) </span>&#123; <span class=\"comment\">// 订阅函数</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!<span class=\"keyword\">this</span>.sub[eventName]) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.sub[eventName] = []</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.sub[eventName].push(func) <span class=\"comment\">// 添加事件监听器</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">eventEmitter.prototype.emit = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">eventName</span>) </span>&#123; <span class=\"comment\">// 发布函数</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> argsList = <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>, length = <span class=\"keyword\">this</span>.sub[eventName].length; i &lt; length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.sub[eventName][i].apply(<span class=\"keyword\">this</span>, argsList) <span class=\"comment\">// 调用事件监听器</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接着，要让 Waterfall 能使用发布/订阅模式，只需让 Waterfall 继承 eventEmitter 函数，代码实现如下:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Waterfall</span>(<span class=\"params\">options = &#123;&#125;</span>) </span>&#123;</span><br><span class=\"line\">  eventEmitter.call(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.init(options) <span class=\"comment\">// 这个 this 是 new 的时候，绑上去的</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Waterfall.prototype = <span class=\"built_in\">Object</span>.create(eventEmitter.prototype)</span><br><span class=\"line\">Waterfall.prototype.constructor = Waterfall</span><br></pre></td></tr></table></figure>\n\n<p>继承方式的写法吸收了基于构造函数继承和基于原型链继承两种写法的优点，以及使用 <code>Object.create</code> 隔离了子类和父类，关于继承更多方面的细节，可以另写一篇文章了，此处点到为止。</p>\n<h3 id=\"小优化\"><a href=\"#小优化\" class=\"headerlink\" title=\"小优化\"></a>小优化</h3><p>为了防止 scroll 事件触发多次加载图片，可以考虑用函数防抖与节流实现。在基于发布-订阅模式的基础上，定义了个 isLoading 参数表示是否在加载中，并根据其布尔值决定是否加载，代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> isLoading = <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> scroll = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (isLoading) <span class=\"keyword\">return</span> <span class=\"literal\">false</span> <span class=\"comment\">// 避免一次触发事件多次</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (scrollPX + bsHeight &gt; imgList[imgList.length - <span class=\"number\">1</span>].offsetTop) &#123; <span class=\"comment\">// 浏览器高度 + 滚动距离 &gt; 最后一张图片的 offsetTop</span></span><br><span class=\"line\">    isLoading = <span class=\"literal\">true</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.emit(<span class=\"string\">'load'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">proto.done = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.on(<span class=\"string\">'done'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    isLoading = <span class=\"literal\">false</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.emit(<span class=\"string\">'done'</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这时候需要在调用的地方加上 <code>waterfall.done</code>, 从而告知当前图片已经加载完毕，代码如下:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> waterfall = <span class=\"keyword\">new</span> Waterfall(&#123;&#125;)</span><br><span class=\"line\">waterfall.on(<span class=\"string\">\"load\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 异步/同步加载图片</span></span><br><span class=\"line\">  waterfall.done()</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"项目地址\"><a href=\"#项目地址\" class=\"headerlink\" title=\"项目地址\"></a>项目地址</h3><p><a href=\"https://github.com/MuYunyun/waterfall\" target=\"_blank\" rel=\"noopener\">项目地址</a></p>\n<p><a href=\"https://github.com/MuYunyun/reactSPA/blob/master/src/common/pages/waterfall/index.js\" target=\"_blank\" rel=\"noopener\">此插件在 React 项目中的运用</a></p>\n<p>项目简陋，不足之处在所难免，欢迎留下你们宝贵的意见。</p>\n","categories":["轮子"],"tags":["JavaScript","瀑布流","轮子"]},{"title":"如何使页面交互更流畅","url":"/posts/a1be1d41/","content":"<p><img src=\"http://with.muyunyun.cn/7f0c7b0e28fbeccf363daf5ee47d7105.jpg-muyy\" alt=\"\"></p>\n<p>本篇是对 FDCon2019 上《让你的网页更丝滑》课题的复盘文。该课题也是博主感兴趣的领域, 后续对该文的细节进行进一步补充。</p>\n<a id=\"more\"></a>\n\n<h3 id=\"流畅性\"><a href=\"#流畅性\" class=\"headerlink\" title=\"流畅性\"></a>流畅性</h3><ul>\n<li>被动交互: animation</li>\n<li>主动交互: 鼠标、键盘</li>\n</ul>\n<h3 id=\"被动交互\"><a href=\"#被动交互\" class=\"headerlink\" title=\"被动交互\"></a>被动交互</h3><p><img src=\"http://with.muyunyun.cn/23b109b73c8296e2c0d9178d214f33f0.jpg-400\" alt=\"\"></p>\n<p>当前市面上的设备频率在 60 HZ 以上。</p>\n<h3 id=\"主动交互\"><a href=\"#主动交互\" class=\"headerlink\" title=\"主动交互\"></a>主动交互</h3><p>跑如下界面 <a href=\"https://code.h5jun.com/pojob\" target=\"_blank\" rel=\"noopener\">https://code.h5jun.com/pojob</a></p>\n<p>结合如下代码块, 可以看到 100ms 以下的点击是顺畅的, 而超过 100ms 的点击就会有卡顿现象。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> observer = <span class=\"keyword\">new</span> PerformanceObserver(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">list</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> perfEntries = list.getEntries()</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(perfEntries)</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">observer.observe(&#123;<span class=\"attr\">entryTypes</span>: [<span class=\"string\">\"longtask\"</span>]&#125;);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"让用户感觉到流畅\"><a href=\"#让用户感觉到流畅\" class=\"headerlink\" title=\"让用户感觉到流畅\"></a>让用户感觉到流畅</h4><p>衡量一个网页/App 是否流畅有个比较好用的 <a href=\"https://developers.google.com/web/fundamentals/performance/rail\" target=\"_blank\" rel=\"noopener\">Rail 模型</a>, 它大概有以下几个评判标准值。</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"code\"><pre><span class=\"line\">Response —— <span class=\"number\">100</span>ms</span><br><span class=\"line\">Animation —— <span class=\"number\">16.7</span>ms</span><br><span class=\"line\">Idle —— <span class=\"number\">50</span>ms</span><br><span class=\"line\">Load —— <span class=\"number\">1000</span>ms</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"像素管道\"><a href=\"#像素管道\" class=\"headerlink\" title=\"像素管道\"></a>像素管道</h3><p>像素管道一般由 5 个部分组成。JavaScript、样式、布局、绘制、合成。如下图所示:</p>\n<p><img src=\"http://with.muyunyun.cn/a4498ef249fafc3d47f1443df4108256.jpg\" alt=\"\"></p>\n<blockquote>\n<p><a href=\"https://developers.google.com/web/fundamentals/performance/rendering/?hl=zh-cn\" target=\"_blank\" rel=\"noopener\">渲染性能</a></p>\n</blockquote>\n<h3 id=\"保证主动交互让用户感觉流畅\"><a href=\"#保证主动交互让用户感觉流畅\" class=\"headerlink\" title=\"保证主动交互让用户感觉流畅\"></a>保证主动交互让用户感觉流畅</h3><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">App</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  useEffect(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> start = performance.now()</span><br><span class=\"line\">      <span class=\"keyword\">while</span> (performance.now() - start &lt; <span class=\"number\">1000</span>) &#123; &#125;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'done!'</span>)</span><br><span class=\"line\">    &#125;, <span class=\"number\">5000</span>)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;input type=<span class=\"string\">\"text\"</span> /&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"http://with.muyunyun.cn/574ac0a2b41a78fdb00f2db3d250de37.jpg-400\" alt=\"\"></p>\n<p>一般超过 50 ms 认为是 <code>long task(长任务)</code>, <code>long task</code> 会阻塞 <code>main thread</code> 的运行, 如下是两种解决方案。</p>\n<h4 id=\"Web-Worker\"><a href=\"#Web-Worker\" class=\"headerlink\" title=\"Web Worker\"></a>Web Worker</h4><p><code>app.js</code> 代码如下:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123;useEffect&#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> WorkerCode <span class=\"keyword\">from</span> <span class=\"string\">'./worker'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">App</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  useEffect(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> testWorker = <span class=\"keyword\">new</span> Worker(WorkerCode)</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      testWorker.postMessage(&#123;&#125;)</span><br><span class=\"line\">      testWorker.onmessage = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">ev</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(ev.data)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;, <span class=\"number\">5000</span>)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;input type=<span class=\"string\">\"text\"</span> /&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>worker.js</code> 代码如下:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> workerCode = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  self.onmessage = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> start = performance.now()</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (performance.now() - start &lt; <span class=\"number\">1000</span>) &#123; &#125;</span><br><span class=\"line\">    postMessage(<span class=\"string\">'done!'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"http://with.muyunyun.cn/df7d2b274685c20638cdde68cb54927d.jpg\" alt=\"\"></p>\n<p>此时在输入框输入时没有卡顿的感觉。</p>\n<h4 id=\"Time-Slicing\"><a href=\"#Time-Slicing\" class=\"headerlink\" title=\"Time Slicing\"></a>Time Slicing</h4><p>下面是另外一种使页面流畅的方法 —— <code>Time Slicing</code>(时间分片)。</p>\n<p>观察 Chrome 的 Performance, 火焰图如下,</p>\n<p><img src=\"http://with.muyunyun.cn/8cbc0ea884095aa25a79bd9d474ff2e5.jpg\" alt=\"\"></p>\n<p>从火焰图可以看出主线程被拆分为了多个时间分片, 所以不会造成卡顿。时间分片的代码片段如下所示:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timeSlicing</span>(<span class=\"params\">gen</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> gen === <span class=\"string\">'function'</span>) gen = gen()</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!gen || <span class=\"keyword\">typeof</span> gen.next !== <span class=\"string\">'function'</span>) <span class=\"keyword\">return</span></span><br><span class=\"line\"></span><br><span class=\"line\">  (<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">next</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> res = gen.next() <span class=\"comment\">// ①</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (res.done) <span class=\"keyword\">return</span> <span class=\"comment\">// ⑤</span></span><br><span class=\"line\">    setTimeout(next) <span class=\"comment\">// ③</span></span><br><span class=\"line\">  &#125;)()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 调用时间分片函数</span></span><br><span class=\"line\">timeSlicing(<span class=\"function\"><span class=\"keyword\">function</span>* (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> start = performance.now()</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (performance.now() - start &lt; <span class=\"number\">1000</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'执行逻辑'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> <span class=\"comment\">// ②</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'done'</span>) <span class=\"comment\">// ④</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>该函数虽然代码量不长, 但却不易理解。前置知识 <a href=\"https://github.com/MuYunyun/blog/blob/master/BasicSkill/readES6/Generator.md\" target=\"_blank\" rel=\"noopener\">Generator</a></p>\n<p>下面对该函数进行分析:</p>\n<ol>\n<li>往时间分片函数 <code>timeSlicing</code> 中传入 <code>generator</code> 函数;</li>\n<li>函数的执行顺序 —— ①、②、③、① (此时有个竞赛的关系, 如果 <code>performance.now() - start &lt; 1000</code> 则继续 ②、③, 如果 <code>performance.now() - start &gt;= 1000</code> 则跳出循环执行 ④、⑤);</li>\n</ol>\n<h4 id=\"conclusion\"><a href=\"#conclusion\" class=\"headerlink\" title=\"conclusion\"></a>conclusion</h4><p>针对 <code>long task</code> 会阻塞 <code>main thread</code> 的运行的情形, 给出两种解决方案:</p>\n<ul>\n<li><code>Web Worker</code>: 使用 <code>Web Worker</code> 提供的多线程环境来处理 <code>long task</code>;</li>\n<li><code>Time Slicing</code>: 将主线程上的 <code>long task</code> 进行时间分片;</li>\n</ul>\n<h3 id=\"保证被动交互让用户感觉流畅\"><a href=\"#保证被动交互让用户感觉流畅\" class=\"headerlink\" title=\"保证被动交互让用户感觉流畅\"></a>保证被动交互让用户感觉流畅</h3><p>保证 <code>16.7ms</code> 有新的一帧传输到界面上。除去用户的逻辑代码, 一帧内留给浏览器整合的时间大概只有 <code>6ms</code> 左右, 回到像素管道上来, 我们可以从这几方面进行优化:</p>\n<h4 id=\"避免-CSS-选择器嵌套过深\"><a href=\"#避免-CSS-选择器嵌套过深\" class=\"headerlink\" title=\"避免 CSS 选择器嵌套过深\"></a>避免 CSS 选择器嵌套过深</h4><p>Style 这部分的优化在 css 样式选择器的使用, css 选择器使用的层级越多, 耗费的时间越多。以下是测试 css 选择器不同层级筛选相同元素的一次测试结果。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">div</span><span class=\"selector-class\">.box</span><span class=\"selector-pseudo\">:not(</span><span class=\"selector-pseudo\">:empty)</span><span class=\"selector-pseudo\">:last-of-type</span> <span class=\"selector-tag\">span</span>         2<span class=\"selector-class\">.25ms</span></span><br><span class=\"line\"><span class=\"selector-tag\">index</span><span class=\"selector-class\">.html</span><span class=\"selector-pseudo\">:85</span> <span class=\"selector-class\">.box--last</span> <span class=\"selector-tag\">span</span>                 0<span class=\"selector-class\">.28ms</span></span><br><span class=\"line\"><span class=\"selector-tag\">index</span><span class=\"selector-class\">.html</span><span class=\"selector-pseudo\">:85</span> <span class=\"selector-class\">.box</span><span class=\"selector-pseudo\">:nth-last-child(-n+1)</span> <span class=\"selector-tag\">span</span>  2<span class=\"selector-class\">.51ms</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"避免布局重排\"><a href=\"#避免布局重排\" class=\"headerlink\" title=\"避免布局重排\"></a>避免布局重排</h4><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 先修改值</span></span><br><span class=\"line\">el.style.witdh = <span class=\"string\">'100px'</span></span><br><span class=\"line\"><span class=\"comment\">// 后取值</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> width = el.offsetWidth</span><br></pre></td></tr></table></figure>\n\n<p>这段代码有什么问题呢?</p>\n<p><img src=\"http://with.muyunyun.cn/9f446b40c45fa93b26bf91927e84c676.jpg\" alt=\"\"></p>\n<p>可以看到它会造成布局重排。</p>\n<p><img src=\"http://with.muyunyun.cn/02a6a152cb141781df115840495ed356.jpg\" alt=\"\"></p>\n<p>应对的策略是调整它们的执行顺序,</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 先取值</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> width = el.offsetWidth</span><br><span class=\"line\"><span class=\"comment\">// 后修改值</span></span><br><span class=\"line\">el.style.witdh = <span class=\"string\">'100px'</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"http://with.muyunyun.cn/b84405a014e98f0903703f7d45b9497d.jpg\" alt=\"\"></p>\n<p>可以看到经过调换顺序后, 后执行的 el.style.width 会新开一个像素管道, 而不会在原先的像素管道进行重排。</p>\n<p>此外不要在循环中执行如下的操作,</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> newWidth = container.offsetWidth; <span class=\"comment\">// ①</span></span><br><span class=\"line\">  boxes[i].style.width = newWidth + <span class=\"string\">'px'</span>; <span class=\"comment\">// ②</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以在火焰图中看到它发生了重绘的警告,</p>\n<p><img src=\"http://with.muyunyun.cn/4ee7202c8d28e685a9cd347061eb39e9.jpg\" alt=\"\"></p>\n<p>执行顺序是 ①②①②①②①…, 假若我们在第一个 ① 后面插入一条竖线后 ①|②①②①②①, 其就变成先修改值后取值的情景, 所以也就发生了重绘!</p>\n<p>正确的使用姿势应该如下:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> newWidth = container.offsetWidth;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++) &#123;</span><br><span class=\"line\">  boxes[i].style.width = newWidth + <span class=\"string\">'px'</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"避免重绘\"><a href=\"#避免重绘\" class=\"headerlink\" title=\"避免重绘\"></a>避免重绘</h4><p>创建 Layers(图层) 可以避免重绘,</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attribute\">transform</span>: <span class=\"built_in\">translateZ</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","categories":["JavaScript"],"tags":["JavaScript","性能"]},{"title":"常见数据结构小结","url":"/posts/ac276990/","content":"<p><img src=\"http://with.muyunyun.cn/62245a2ed09ce8856e2eb41efe8f70f8.jpg-muyy\" alt=\"\"></p>\n<a id=\"more\"></a>\n\n<h3 id=\"常见数据结构的-JS-实现\"><a href=\"#常见数据结构的-JS-实现\" class=\"headerlink\" title=\"常见数据结构的 JS 实现\"></a>常见数据结构的 JS 实现</h3><ul>\n<li><a href=\"https://github.com/MuYunyun/blog/blob/master/BasicSkill/algorithm/栈.md\" target=\"_blank\" rel=\"noopener\">栈</a></li>\n<li><a href=\"https://github.com/MuYunyun/blog/blob/master/BasicSkill/algorithm/队列.md\" target=\"_blank\" rel=\"noopener\">队列</a></li>\n<li><a href=\"https://github.com/MuYunyun/blog/blob/master/BasicSkill/algorithm/链表.md\" target=\"_blank\" rel=\"noopener\">链表</a></li>\n<li><a href=\"https://github.com/MuYunyun/blog/blob/master/BasicSkill/algorithm/集合.md\" target=\"_blank\" rel=\"noopener\">集合</a></li>\n<li><a href=\"https://github.com/MuYunyun/blog/blob/master/BasicSkill/algorithm/字典.md\" target=\"_blank\" rel=\"noopener\">字典</a></li>\n<li><a href=\"https://github.com/MuYunyun/blog/blob/master/BasicSkill/algorithm/哈希表.md\" target=\"_blank\" rel=\"noopener\">哈希表</a></li>\n<li><a href=\"https://github.com/MuYunyun/blog/blob/master/BasicSkill/algorithm/二叉树.md\" target=\"_blank\" rel=\"noopener\">二叉树</a></li>\n<li><a href=\"https://github.com/MuYunyun/blog/blob/master/BasicSkill/algorithm/图.md\" target=\"_blank\" rel=\"noopener\">图</a></li>\n</ul>\n<h3 id=\"前端与数据结构\"><a href=\"#前端与数据结构\" class=\"headerlink\" title=\"前端与数据结构\"></a>前端与数据结构</h3><p>数据结构在开发中是一种编程思想的提炼，无关于用何种语言开发或者是哪种端开发。下列将笔者涉猎到的与前端相关的数据结构案例作如下总结：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">数据结构</th>\n<th align=\"center\">案例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">栈</td>\n<td align=\"center\">FILO: 其它数据结构的基础，redux/koa2 中间件机制</td>\n</tr>\n<tr>\n<td align=\"center\">队列</td>\n<td align=\"center\">FIFO：其它数据结构的基础</td>\n</tr>\n<tr>\n<td align=\"center\">链表</td>\n<td align=\"center\">React 16 中的 Fiber 的优化</td>\n</tr>\n<tr>\n<td align=\"center\">集合</td>\n<td align=\"center\">对应 JavaScript 中的 Set</td>\n</tr>\n<tr>\n<td align=\"center\">字典</td>\n<td align=\"center\">对应 JavaScript 中的 Map</td>\n</tr>\n<tr>\n<td align=\"center\">哈希表</td>\n<td align=\"center\">一种特殊的字典，可以用来存储加密数据</td>\n</tr>\n<tr>\n<td align=\"center\">树</td>\n<td align=\"center\">DOM TREE / HTML TREE / CSS TREE</td>\n</tr>\n<tr>\n<td align=\"center\">图</td>\n<td align=\"center\">暂时没遇到，不过里面的 BFS/DFS 蛮常见</td>\n</tr>\n</tbody></table>\n","categories":["数据结构"],"tags":["数据结构"]},{"title":"探寻 JavaScript 精度问题","url":"/posts/49fa8af8/","content":"<p>阅读完本文可以了解到 <code>0.1 + 0.2</code> 为什么等于 <code>0.30000000000000004</code> 以及 JavaScript 中最大安全数是如何来的。</p>\n<a id=\"more\"></a>\n\n<h3 id=\"十进制小数转为二进制小数方法\"><a href=\"#十进制小数转为二进制小数方法\" class=\"headerlink\" title=\"十进制小数转为二进制小数方法\"></a>十进制小数转为二进制小数方法</h3><p>拿 173.8125 举例如何将之转化为二进制小数。</p>\n<p>①. 针对整数部分 173，采取<code>除 2 取余，逆序排列</code>;</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">173</span> / <span class=\"number\">2</span> = <span class=\"number\">86</span> ... <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">86</span> / <span class=\"number\">2</span> = <span class=\"number\">43</span> ... <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">43</span> / <span class=\"number\">2</span> = <span class=\"number\">21</span> ... <span class=\"number\">1</span>   ↑</span><br><span class=\"line\"><span class=\"number\">21</span> / <span class=\"number\">2</span> = <span class=\"number\">10</span> ... <span class=\"number\">1</span>   | 逆序排列</span><br><span class=\"line\"><span class=\"number\">10</span> / <span class=\"number\">2</span> = <span class=\"number\">5</span> ... <span class=\"number\">0</span>    |</span><br><span class=\"line\"><span class=\"number\">5</span> / <span class=\"number\">2</span> = <span class=\"number\">2</span> ... <span class=\"number\">1</span>     |</span><br><span class=\"line\"><span class=\"number\">2</span> / <span class=\"number\">2</span> = <span class=\"number\">1</span> ... <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">1</span> / <span class=\"number\">2</span> = <span class=\"number\">0</span> ... <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n<p>得整数部分的二进制为 <code>10101101</code>。</p>\n<p>②. 针对小数部分 0.8125，采用<code>乘 2 取整，顺序排列</code>;</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0.8125</span> * <span class=\"number\">2</span> = <span class=\"number\">1.625</span>  |</span><br><span class=\"line\"><span class=\"number\">0.625</span> * <span class=\"number\">2</span> = <span class=\"number\">1.25</span>    | 顺序排列</span><br><span class=\"line\"><span class=\"number\">0.25</span> * <span class=\"number\">2</span> = <span class=\"number\">0.5</span>      |</span><br><span class=\"line\"><span class=\"number\">0.5</span> * <span class=\"number\">2</span> = <span class=\"number\">1</span>         ↓</span><br></pre></td></tr></table></figure>\n\n<p>得小数部分的二进制为 <code>1101</code>。</p>\n<p>③. 将前面两部的结果相加，结果为 <code>10101101.1101</code>;</p>\n<h3 id=\"小心，二进制小数丢失了精度！\"><a href=\"#小心，二进制小数丢失了精度！\" class=\"headerlink\" title=\"小心，二进制小数丢失了精度！\"></a>小心，二进制小数丢失了精度！</h3><p>根据上面的知识，将十进制小数 <code>0.1</code> 转为二进制：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0.1</span> * <span class=\"number\">2</span> = <span class=\"number\">0.2</span></span><br><span class=\"line\"><span class=\"number\">0.2</span> * <span class=\"number\">2</span> = <span class=\"number\">0.4</span> <span class=\"comment\">// 注意这里</span></span><br><span class=\"line\"><span class=\"number\">0.4</span> * <span class=\"number\">2</span> = <span class=\"number\">0.8</span></span><br><span class=\"line\"><span class=\"number\">0.8</span> * <span class=\"number\">2</span> = <span class=\"number\">1.6</span></span><br><span class=\"line\"><span class=\"number\">0.6</span> * <span class=\"number\">2</span> = <span class=\"number\">1.2</span></span><br><span class=\"line\"><span class=\"number\">0.2</span> * <span class=\"number\">2</span> = <span class=\"number\">0.4</span> <span class=\"comment\">// 注意这里，循环开始</span></span><br><span class=\"line\"><span class=\"number\">0.4</span> * <span class=\"number\">2</span> = <span class=\"number\">0.8</span></span><br><span class=\"line\"><span class=\"number\">0.8</span> * <span class=\"number\">2</span> = <span class=\"number\">1.6</span></span><br><span class=\"line\"><span class=\"number\">0.6</span> * <span class=\"number\">2</span> = <span class=\"number\">1.2</span></span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>可以发现有限十进制小数 <code>0.1</code> 却转化成了无限二进制小数 <code>0.00011001100...</code>，可以看到精度在转化过程中丢失了！</p>\n<p>能被转化为有限二进制小数的十进制小数的最后一位必然以 5 结尾(因为只有 0.5 * 2 才能变为整数)。所以十进制中一位小数 <code>0.1 ~ 0.9</code> 当中除了 <code>0.5</code> 之外的值在转化成二进制的过程中都丢失了精度。</p>\n<h3 id=\"推导-0-1-0-2-为何等于-0-30000000000000004\"><a href=\"#推导-0-1-0-2-为何等于-0-30000000000000004\" class=\"headerlink\" title=\"推导 0.1 + 0.2 为何等于 0.30000000000000004\"></a>推导 0.1 + 0.2 为何等于 0.30000000000000004</h3><p>在 JavaScript 中所有数值都以 IEEE-754 标准的 <code>64 bit</code> 双精度浮点数进行存储的。先来了解下 IEEE-754 标准下的<a href=\"https://zh.wikipedia.org/wiki/%E9%9B%99%E7%B2%BE%E5%BA%A6%E6%B5%AE%E9%BB%9E%E6%95%B8\" target=\"_blank\" rel=\"noopener\">双精度浮点数</a>。</p>\n<p><img src=\"http://with.muyunyun.cn/dda7d5b38676abfa13afb344f8a792ed.jpg-300\" alt=\"\"></p>\n<p>这幅图很关键，可以从图中看到 IEEE-754 标准下双精度浮点数由三部分组成，分别如下：</p>\n<ul>\n<li>sign(符号): 占 1 bit, 表示正负;</li>\n<li>exponent(指数): 占 11 bit，表示范围;</li>\n<li>mantissa(尾数): 占 52 bit，表示精度，多出的末尾如果是 1 需要进位;</li>\n</ul>\n<p>推荐阅读 <a href=\"https://github.com/camsong/blog/issues/9\" target=\"_blank\" rel=\"noopener\">JavaScript 浮点数陷阱及解法</a>，阅读完该文后可以了解到以下公式的由来。</p>\n<p><img src=\"http://with.muyunyun.cn/5c268e4bd6e0bf2466598d9d5cb58a16.jpg-200\" alt=\"\"></p>\n<blockquote>\n<p>精度位总共是 53 bit，因为用科学计数法表示，所以首位固定的 1 就没有占用空间。即公式中 (M + 1) 里的 1。另外公式里的 1023 是 2^11 的一半。小于 1023 的用来表示小数，大于 1023 的用来表示整数。</p>\n</blockquote>\n<blockquote>\n<p>指数可以控制到 2^1024 - 1，而精度最大只达到 2^53 - 1，两者相比可以得出 JavaScript 实际可以精确表示的数字其实很少。</p>\n</blockquote>\n<p><code>0.1</code> 转化为二进制为 <code>0.0001100110011...</code>，用科学计数法表示为 <code>1.100110011... x 2^(-4)</code>，根据上述公式，<code>S</code> 为 <code>0</code>(1 bit)，<code>E</code> 为 <code>-4 + 1023</code>，对应的二进制为 <code>01111111011</code>(11 bit)，<code>M</code> 为 <code>1001100110011001100110011001100110011001100110011010</code>(52 bit，另外注意末尾的进位)，<code>0.1</code> 的存储示意图如下:</p>\n<p><img src=\"http://with.muyunyun.cn/5b7c0dcc0b1770b6eed238e288eb4c0e.jpg-300\" alt=\"\"></p>\n<p>同理，<code>0.2</code> 转化为二进制为 <code>0.001100110011...</code>，用科学计数法表示为 <code>1.100110011... x 2^(-3)</code>，根据上述公式，<code>E</code> 为 <code>-3 + 1023</code>，对应的二进制为 <code>01111111100</code>, <code>M</code> 为 <code>1001100110011001100110011001100110011001100110011010</code>, <code>0.2</code> 的存储示意图如下:</p>\n<p><img src=\"http://with.muyunyun.cn/cb0ef89aa0ed6e8d32b90d1a29cfc9e1.jpg-300\" alt=\"\"></p>\n<p><code>0.1 + 0.2</code> 即 2^(-4) x 1.1001100110011001100110011001100110011001100110011010 与 2^(-3) x 1.1001100110011001100110011001100110011001100110011010 之和</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 计算过程</span></span><br><span class=\"line\"><span class=\"number\">0.00011001100110011001100110011001100110011001100110011010</span></span><br><span class=\"line\"><span class=\"number\">0.0011001100110011001100110011001100110011001100110011010</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 相加得</span></span><br><span class=\"line\"><span class=\"number\">0.01001100110011001100110011001100110011001100110011001110</span></span><br></pre></td></tr></table></figure>\n\n<p><code>0.01001100110011001100110011001100110011001100110011001110</code> 转化为十进制就是 <code>0.30000000000000004</code>。验证完成!</p>\n<h3 id=\"JavaScript-的最大安全数是如何来的\"><a href=\"#JavaScript-的最大安全数是如何来的\" class=\"headerlink\" title=\"JavaScript 的最大安全数是如何来的\"></a>JavaScript 的最大安全数是如何来的</h3><p>根据双精度浮点数的构成，精度位数是 <code>53 bit</code>。安全数的意思是在 <code>-2^53 ~ 2^53</code> 内的整数(不包括边界)与唯一的双精度浮点数互相对应。举个例子比较好理解：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Math</span>.pow(<span class=\"number\">2</span>, <span class=\"number\">53</span>) === <span class=\"built_in\">Math</span>.pow(<span class=\"number\">2</span>, <span class=\"number\">53</span>) + <span class=\"number\">1</span> <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p><code>Math.pow(2, 53)</code> 竟然与 <code>Math.pow(2, 53) + 1</code> 相等！这是因为 Math.pow(2, 53) + 1 已经超过了尾数的精度限制(53 bit)，在这个例子中 <code>Math.pow(2, 53)</code> 和 <code>Math.pow(2, 53) + 1</code> 对应了同一个双精度浮点数。所以 <code>Math.pow(2, 53)</code> 就不是安全数了。</p>\n<blockquote>\n<p>最大的安全数为 <code>Math.pow(2, 53) - 1</code>，即 <code>9007199254740991</code>。</p>\n</blockquote>\n<h3 id=\"相关链接\"><a href=\"#相关链接\" class=\"headerlink\" title=\"相关链接\"></a>相关链接</h3><ul>\n<li><a href=\"http://justjavac.com/codepuzzle/2012/11/11/codepuzzle-float-who-stole-your-accuracy.html\" target=\"_blank\" rel=\"noopener\">代码之谜系列</a></li>\n<li><a href=\"http://www.binaryconvert.com/convert_double.html\" target=\"_blank\" rel=\"noopener\">IEEE-754 进制转换图生成</a></li>\n<li><a href=\"https://github.com/camsong/blog/issues/9\" target=\"_blank\" rel=\"noopener\">JavaScript 浮点数陷阱及解法</a>: 推荐阅读</li>\n<li><a href=\"https://www.zhihu.com/question/29010688\" target=\"_blank\" rel=\"noopener\">javascript 里最大的安全的整数为什么是2的53次方减一</a></li>\n</ul>\n","categories":["JavaScrip","精度"],"tags":["JavaScript","精度"]},{"title":"探索从 MVC 到 MVVM + Flux 架构模式的转变","url":"/posts/f0f11de9/","content":"<p><img src=\"http://with.muyunyun.cn/77fcc2250cfde1b47300673eb3006c8c.jpg-muyy\" alt=\"\"></p>\n<p>在业务中一般 MVVM 框架一般都会配合上数据状态库(redux, mobx 等)一起使用，本文会通过一个小 demo 来讲述为什么会引人数据状态库。</p>\n<a id=\"more\"></a>\n\n<h3 id=\"从-MVC-到-MVVM-模式说起\"><a href=\"#从-MVC-到-MVVM-模式说起\" class=\"headerlink\" title=\"从 MVC 到 MVVM 模式说起\"></a>从 MVC 到 MVVM 模式说起</h3><p>传统 MVC 架构(如 JSP)在当今移动端流量寸土寸金的年代一个比较头疼的问题就是会进行大量的全局重复渲染。但是 MVC 架构是好东西，其对数据、视图、逻辑有了清晰的分工，于是前端 MVC 框架(比如 backbone.js) 出来了，对于很多业务规模不大的场景，前端 MVC 框架已经够用了，它也能做到前后端分离开发单页面应用，那么它的缺陷在哪呢？</p>\n<p>拿 backbone.js 说，它的 Model 对外暴露了 set 方法，也就是说可以在不止一个 View 里修改同个 Model 的数据，然后一个 Model 的数据同时对应多个 View 的呈现，如下图所示。当业务逻辑过多时，多个 Model 和多个 View 就会耦合到一块，可以想到排查 bug 的时候会比较痛苦。</p>\n<p><img src=\"http://with.muyunyun.cn/779649b773473d622881577730d81be7.jpg-200\" alt=\"\"></p>\n<p>针对传统 MVC 架构性能低(多次全局渲染)以及前端 MVC 框架耦合度高(Model 和 View) 的痛处，MVVM 框架完美地解决了以上两点。可以参阅之前写的 <a href=\"https://github.com/MuYunyun/blog/issues/11\" target=\"_blank\" rel=\"noopener\">MVVM 框架解析之双向绑定</a></p>\n<h3 id=\"only-MVVM\"><a href=\"#only-MVVM\" class=\"headerlink\" title=\"only MVVM\"></a>only MVVM</h3><p>假设有这么一个场景，在输入框中查询条件，点击查询，然后在列表中返回相应内容。如下图所示：</p>\n<p><img src=\"http://with.muyunyun.cn/ecb63d73e997ebf901552c2a89a991c8.jpg-200\" alt=\"\"></p>\n<p>假设用 react 实现，思路大体是先调用查询接口，调用成功后将获取到的数据通过 <code>setState</code> 存进 list 中，列表显示部分代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Decorate = <span class=\"function\">(<span class=\"params\">ListComponent</span>) =&gt;</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>()</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = &#123; <span class=\"attr\">list</span>: [] &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  componentDidMount() &#123;</span><br><span class=\"line\">    fetch(<span class=\"string\">'./list.json'</span>)</span><br><span class=\"line\">      .then(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> res.json())</span><br><span class=\"line\">      .then(<span class=\"function\"><span class=\"params\">result</span> =&gt;</span> <span class=\"keyword\">this</span>.setState(&#123; <span class=\"attr\">list</span>: result.data &#125;))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;ListComponent data=&#123;<span class=\"keyword\">this</span>.state.list&#125; /&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接着往封装的 Decorate 组件里，传入无状态函数构建的 List 组件用来展示列表数据，代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">List</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">      &#123;props.data.map(<span class=\"function\"><span class=\"params\">r</span> =&gt;</span></span><br><span class=\"line\">        &lt;p key=&#123;r.id&#125;&gt;&#123;r.content&#125;&lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      )&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;/</span>div&gt;</span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到 List 组件相当于是 View 层，而封装的 Decorate 组件相当于是 Model 层。但是这么做还是把业务逻辑写进了组件当中。而我们期望的是能得到一个纯粹的 Model 层和 View 层。接着一起看看 Flux 架构模式是如何解决这个问题的。</p>\n<h3 id=\"引人-Flux-架构模式\"><a href=\"#引人-Flux-架构模式\" class=\"headerlink\" title=\"引人 Flux 架构模式\"></a>引人 Flux 架构模式</h3><p><img src=\"http://with.muyunyun.cn/77fcc2250cfde1b47300673eb3006c8c.jpg-200\" alt=\"\"></p>\n<p>Flux 架构模式的 4 个重要组成部分以及它们的关系如上图所示，下文会根据 dispatch，store, action, view 的顺序逐步揭开 Flux 架构模式的面纱。</p>\n<p>从 <a href=\"https://github.com/facebook/flux/blob/master/src/Dispatcher.js\" target=\"_blank\" rel=\"noopener\">Flux 的源码</a>中可以看出 Dispacher.js 是其的核心文件，其核心是基于事件的发布/订阅模式完成的，核心源码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dispatcher</span> </span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"comment\">// 注册回调函数，</span></span><br><span class=\"line\">  register(callback) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> id = _prefix + <span class=\"keyword\">this</span>._lastID++;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._callbacks[id] = callback;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 当调用 dispatch 的时候会调用 register 中注册的回调函数</span></span><br><span class=\"line\">  dispatch(payload) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._startDispatching(payload);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> id <span class=\"keyword\">in</span> <span class=\"keyword\">this</span>._callbacks) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>._invokeCallback(id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>回顾下之前的目的：让 Store 层变得纯粹。于是定义了一个变量 comments 用来专门存放列表数据，在了解 Dispatcher 的核心原理之后，当调用 dispatch(obj) 方法时，就可以把参数传递到事先注册的 register 函数中，代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// commentStore.js</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> comments = []</span><br><span class=\"line\"><span class=\"keyword\">const</span> CommentStore = &#123;</span><br><span class=\"line\">  getComment() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> comments</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">dispathcer.register(<span class=\"function\">(<span class=\"params\">action</span>) =&gt;</span> &#123; <span class=\"comment\">// 调用 Dispatcher 实例上的 register 函数</span></span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (action.type) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'GET_LIST_SUCCESS'</span>: &#123;</span><br><span class=\"line\">      comments = action.comment</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>以及 action 中的函数如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// commentAction.js</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> commentAction = &#123;</span><br><span class=\"line\">  getList() &#123;</span><br><span class=\"line\">    fetch(<span class=\"string\">'./list.json'</span>)</span><br><span class=\"line\">      .then(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span> res.json())</span><br><span class=\"line\">      .then(<span class=\"function\"><span class=\"params\">result</span> =&gt;</span></span><br><span class=\"line\">        dispathcer.dispatch(&#123; <span class=\"comment\">// 调用 Dispatcher 实例上的 dispatch 函数</span></span><br><span class=\"line\">          type: <span class=\"string\">'GET_LIST_SUCCESS'</span>,</span><br><span class=\"line\">          comment: result.data</span><br><span class=\"line\">        &#125;))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是似乎少了点什么，当 <code>GET_LIST_SUCCESS</code> 成功后，发现还缺少通知到页面再次调用 CommentStore.getComment() 的能力，所以再次引用事件发布/订阅模式，这次使用了 Node.js 提供的 events 模块，对 commentStore.js 文件进行修改，修改后代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> comments = []</span><br><span class=\"line\"><span class=\"keyword\">const</span> CommentStore = <span class=\"built_in\">Object</span>.assign(&#123;&#125;, EventEmitter.prototype, &#123;</span><br><span class=\"line\">  getComment() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> comments</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  emitChange() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.emit(<span class=\"string\">'change'</span>)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  addListener(callback) &#123; <span class=\"comment\">// 提供给页面组件使用</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.on(<span class=\"string\">'change'</span>, callback)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">appDispathcer.register(<span class=\"function\">(<span class=\"params\">action</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (action.type) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'GET_LIST_SUCCESS'</span>: &#123;</span><br><span class=\"line\">      comments = action.comment</span><br><span class=\"line\">      CommentStore.emitChange() <span class=\"comment\">// 有了这行代码，也就有了通知页面再次进行调用 CommentStore.getComment 的能力</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>剩下最后一步了，就是整合 store 和 action 进页面中，代码如下:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ComponentList</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>()</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;</span><br><span class=\"line\">      comment: commentStore.getComment()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  componentDidMount() &#123;</span><br><span class=\"line\">    commentStore.addListener(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"keyword\">this</span>.setState(&#123; <span class=\"comment\">// 注册函数，上面已经提过，供 store 使用</span></span><br><span class=\"line\">      comment: commentStore.getComment()</span><br><span class=\"line\">    &#125;))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &#123;<span class=\"keyword\">this</span>.state.comment.map(<span class=\"function\"><span class=\"params\">r</span> =&gt;</span></span><br><span class=\"line\">          &lt;p key=&#123;r.id&#125;&gt;&#123;r.content&#125;&lt;<span class=\"regexp\">/p&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        )&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>div&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>单纯以 mvvm 构建应用会发现业务逻辑以及数据都耦合在组件之中，引入了 Flux 架构模式后数据和业务逻辑得到较好的分离。但是使用 Flux 有什么缺点呢？在下篇 《聊聊 Redux 架构模式》中会进行分析，下回见。</p>\n<p>本文实践案例已上传至 <a href=\"https://github.com/MuYunyun/stateManage\" target=\"_blank\" rel=\"noopener\">stateManage</a></p>\n<p><a href=\"https://github.com/MuYunyun/blog\" target=\"_blank\" rel=\"noopener\">系列博客</a>，欢迎 Star</p>\n","categories":["框架"],"tags":["框架","状态管理","react"]},{"title":"JS 装饰器解析","url":"/posts/b7045d95/","content":"<p><img src=\"http://with.muyunyun.cn/b8c937cfafeecc6ae8d6278753ac645d.jpg-muyy\" alt=\"\"></p>\n<p>随着 ES6 和 TypeScript 中类的引入，在某些场景需要在不改变原有类和类属性的基础上扩展些功能，这也是装饰器出现的原因。</p>\n<a id=\"more\"></a>\n\n<h3 id=\"装饰器简介\"><a href=\"#装饰器简介\" class=\"headerlink\" title=\"装饰器简介\"></a>装饰器简介</h3><p>作为一种可以动态增删功能模块的模式(比如 <a href=\"https://github.com/MuYunyun/blog/issues/15\" target=\"_blank\" rel=\"noopener\">redux 的中间件机制</a>)，装饰器同样具有很强的动态灵活性，只需在类或类属性之前加上 <code>@方法名</code> 就完成了相应的类或类方法功能的变化。</p>\n<p>不过装饰器模式仍处于<a href=\"https://github.com/tc39/proposal-decorators\" target=\"_blank\" rel=\"noopener\">第 2 阶段提案中</a>，使用它之前需要使用 babel 模块 <code>transform-decorators-legacy</code> 编译成 ES5 或 ES6。</p>\n<p>在 TypeScript 的 <a href=\"https://github.com/Microsoft/TypeScript/blob/c48662c891ce810f5627a0f6a8594049cccceeb5/lib/lib.es5.d.ts#L1291\" target=\"_blank\" rel=\"noopener\">lib.es5.d.ts</a> 中，定义了 4 种不同装饰器的接口，其中装饰类以及装饰类方法的接口定义如下所示：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">type</span> ClassDecorator = &lt;TFunction <span class=\"keyword\">extends</span> <span class=\"built_in\">Function</span>&gt;<span class=\"function\">(<span class=\"params\">target: TFunction</span>) =&gt;</span> TFunction | <span class=\"built_in\">void</span>;</span><br><span class=\"line\"><span class=\"keyword\">declare</span> <span class=\"keyword\">type</span> MethodDecorator = &lt;T&gt;<span class=\"function\">(<span class=\"params\">target: <span class=\"built_in\">Object</span>, propertyKey: <span class=\"built_in\">string</span> | symbol, descriptor: TypedPropertyDescriptor&lt;T&gt;</span>) =&gt;</span> TypedPropertyDescriptor&lt;T&gt; | <span class=\"built_in\">void</span>;</span><br></pre></td></tr></table></figure>\n\n<p>下面对这两种情况进行解析。</p>\n<h3 id=\"作用于类的装饰器\"><a href=\"#作用于类的装饰器\" class=\"headerlink\" title=\"作用于类的装饰器\"></a>作用于类的装饰器</h3><p>当装饰的对象是类时，我们操作的就是这个<code>类本身</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">@log</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyClass</span> </span>&#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">log</span>(<span class=\"params\">target</span>) </span>&#123; <span class=\"comment\">// 这个 target 在这里就是 MyClass 这个类</span></span><br><span class=\"line\">   target.prototype.logger = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"string\">`<span class=\"subst\">$&#123;target.name&#125;</span> 被调用`</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> test = <span class=\"keyword\">new</span> MyClass()</span><br><span class=\"line\">test.logger() <span class=\"comment\">// MyClass 被调用</span></span><br></pre></td></tr></table></figure>\n\n<p>由于装饰器是表达式，我们也可以在装饰器后面再添加提个参数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">@log(<span class=\"string\">'hi'</span>)</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyClass</span> </span>&#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">log</span>(<span class=\"params\">text</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">target</span>) </span>&#123;</span><br><span class=\"line\">    target.prototype.logger = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"string\">`<span class=\"subst\">$&#123;text&#125;</span>，<span class=\"subst\">$&#123;target.name&#125;</span> 被调用`</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> test = <span class=\"keyword\">new</span> MyClass()</span><br><span class=\"line\">test.logger() <span class=\"comment\">// hello，MyClass 被调用</span></span><br></pre></td></tr></table></figure>\n\n<p>在使用 redux 中，我们最常使用 react-redux 的写法如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">@connect(mapStateToProps, mapDispatchToProps)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyComponent</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>经过上述分析，我们知道了上述写法等价于下面这种写法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyComponent</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> connect(mapStateToProps, mapDispatchToProps)(MyComponent)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"作用于类方法的装饰器\"><a href=\"#作用于类方法的装饰器\" class=\"headerlink\" title=\"作用于类方法的装饰器\"></a>作用于类方法的装饰器</h3><p>与装饰类不同，对类方法的装饰本质是操作其描述符。可以把此时的装饰器理解成是 <code>Object.defineProperty(obj, prop, descriptor)</code> 的语法糖，看如下代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span> </span>&#123;</span><br><span class=\"line\">  @readonly(<span class=\"literal\">false</span>)</span><br><span class=\"line\">  method() &#123; <span class=\"built_in\">console</span>.log(<span class=\"string\">'cat'</span>) &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">readonly</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">target, key, descriptor</span>) </span>&#123; <span class=\"comment\">// 此处 target 为 C.prototype; key 为 method;</span></span><br><span class=\"line\">    <span class=\"comment\">// 原 descriptor 为：&#123; value: f, enumarable: false, writable: true, configurable: true &#125;</span></span><br><span class=\"line\">    descriptor.writable = value</span><br><span class=\"line\">    <span class=\"keyword\">return</span> descriptor</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> c = <span class=\"keyword\">new</span> C()</span><br><span class=\"line\">c.method = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">'dog'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">c.method() <span class=\"comment\">// cat</span></span><br></pre></td></tr></table></figure>\n\n<p>可以看到装饰器函数接收的三个参数与 Object.defineProperty 是完全一样的，具体实现可以看 babel 转化后的代码，主要实现如下所示：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> C = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span> </span>&#123;</span><br><span class=\"line\">    method() &#123; <span class=\"built_in\">console</span>.log(<span class=\"string\">'cat'</span>) &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> temp</span><br><span class=\"line\">  temp = readonly(<span class=\"literal\">false</span>)(C.prototype, <span class=\"string\">'method'</span>,</span><br><span class=\"line\">    temp = <span class=\"built_in\">Object</span>.getOwnPropertyDescriptor(C.prototype, <span class=\"string\">'method'</span>)) || temp <span class=\"comment\">// 通过 Object.getOwnPropertyDescriptor 获取到描述符传入到装饰器函数中</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (temp) <span class=\"built_in\">Object</span>.defineProperty(C.prototype, <span class=\"string\">'method'</span>, temp)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> C</span><br><span class=\"line\">&#125;)()</span><br></pre></td></tr></table></figure>\n\n<p>再将再来看看如果有多个装饰器作用于同一个方法上呢？</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span> </span>&#123;</span><br><span class=\"line\">  @readonly(<span class=\"literal\">false</span>)</span><br><span class=\"line\">  @log</span><br><span class=\"line\">  method() &#123; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>经 babel 转化后的代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">desc = [readonly(<span class=\"literal\">false</span>), log]</span><br><span class=\"line\">    .slice()</span><br><span class=\"line\">    .reverse()</span><br><span class=\"line\">    .reduce(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">desc, decorator</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> decorator(target, property, desc) || desc;</span><br><span class=\"line\">    &#125;, desc);</span><br></pre></td></tr></table></figure>\n\n<p>可以清晰地看出，经过 reverse 倒序后，装饰器方法会至里向外执行。</p>\n<h3 id=\"相关链接\"><a href=\"#相关链接\" class=\"headerlink\" title=\"相关链接\"></a>相关链接</h3><p><a href=\"https://github.com/wycats/javascript-decorators\" target=\"_blank\" rel=\"noopener\">javascript-decorators</a><br><a href=\"https://aotu.io/notes/2016/10/24/decorator/index.html\" target=\"_blank\" rel=\"noopener\">Javascript 中的装饰器</a><br><a href=\"https://juejin.im/post/59f1c484f265da431c6f8940\" target=\"_blank\" rel=\"noopener\">JS 装饰器（Decorator）场景实战</a><br><a href=\"http://es6.ruanyifeng.com/#docs/decorator#%E6%96%B9%E6%B3%95%E7%9A%84%E4%BF%AE%E9%A5%B0\" target=\"_blank\" rel=\"noopener\">修饰器</a><br><a href=\"http://babeljs.io\" target=\"_blank\" rel=\"noopener\">Babel</a></p>\n","categories":["decorators"],"tags":["decorators","ES7"]},{"title":"组件设计 —— 重新认识受控与非受控组件","url":"/posts/8bdf2cdf/","content":"<p><img src=\"http://with.muyunyun.cn/21ec115261725fc7a37543143c1e89ed.jpg-400\" alt=\"\"></p>\n<a id=\"more\"></a>\n\n<h3 id=\"重新定义受控与非受控组件的边界\"><a href=\"#重新定义受控与非受控组件的边界\" class=\"headerlink\" title=\"重新定义受控与非受控组件的边界\"></a>重新定义受控与非受控组件的边界</h3><p><img src=\"http://with.muyunyun.cn/3e1327ce86f89d2763d8fed9c169887d.jpg-400\" alt=\"\"></p>\n<p><a href=\"https://reactjs.org/docs/uncontrolled-components.html\" target=\"_blank\" rel=\"noopener\">React 官网中</a>对非受控组件与受控组件作了如图中下划线的边界定义。一经推敲, 该定义是缺乏了些<code>完整性</code>和<code>严谨性</code>的, 比如针对非表单组件(弹框、轮播图)如何划分受控与非受控的边界? 又比如非受控组件是否真的如文案上所说的数据的展示与变更都由 dom 自身接管呢?</p>\n<p>在非受控组件中, 通常业务调用方只需传入一个<code>初始默认值</code>便可使用该组件。以 Input 组件为例:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 组件提供方</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Input</span>(<span class=\"params\">&#123; defaultValue &#125;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">defaultValue</span>=<span class=\"string\">&#123;defaultValue&#125;</span> /&gt;</span></span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 调用方</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Demo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Input</span> <span class=\"attr\">defaultValue</span>=<span class=\"string\">&#123;1&#125;</span> /&gt;</span></span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在受控组件中, 数值的<code>展示与变更</code>则分别由组件的 <code>state</code> 与 <code>setState</code> 接管。同样以 Input 组件为例:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 组件提供方</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Input</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [value, setValue] = React.useState(<span class=\"number\">1</span>)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">value</span>=<span class=\"string\">&#123;value&#125;</span> <span class=\"attr\">onChange</span>=<span class=\"string\">&#123;e</span> =&gt;</span> setValue(e.target.value)&#125; /&gt;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 调用方</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Demo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Input</span> /&gt;</span></span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>有意思的一个问题来了, <code>Input</code> 组件到底是受控的还是非受控的? 我们甚至还可以对代码稍加改动成 <code>&lt;Input defaultValue={1} /&gt;</code> 的最初调用方式:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 组件提供方</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Input</span>(<span class=\"params\">&#123; defaultValue &#125;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [value, setValue] = React.useState(defaultValue)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">value</span>=<span class=\"string\">&#123;value&#125;</span> <span class=\"attr\">onChange</span>=<span class=\"string\">&#123;e</span> =&gt;</span> setValue(e.target.value)&#125; /&gt;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 调用方</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Demo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Input</span> <span class=\"attr\">defaultValue</span>=<span class=\"string\">&#123;1&#125;</span> /&gt;</span></span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>尽管此时 Input 组件本身是一个受控组件, 但与之相对的调用方失去了更改 Input 组件值的<code>控制权</code>, 所以对调用方而言, Input 组件是一个非受控组件。值得一提的是, <code>以非受控组件的使用方式去调用受控组件</code>是一种反模式, 在下文中会分析其中的弊端。</p>\n<p>如何做到不管对于组件提供方还是调用方 Input 组件都为受控组件呢? 提供方让出控制权即可, 调整代码如下<a href=\"https://codesandbox.io/s/clever-montalcini-kysbg\" target=\"_blank\" rel=\"noopener\">codesandbox</a>:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 组件提供方</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Input</span>(<span class=\"params\">&#123; value, onChange &#125;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">value</span>=<span class=\"string\">&#123;value&#125;</span> <span class=\"attr\">onChange</span>=<span class=\"string\">&#123;onChange&#125;</span> /&gt;</span></span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 调用方</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Demo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [value, setValue] = React.useState(<span class=\"number\">1</span>)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Input</span> <span class=\"attr\">value</span>=<span class=\"string\">&#123;value&#125;</span> <span class=\"attr\">onChange</span>=<span class=\"string\">&#123;e</span> =&gt;</span> setValue(e.target.value)&#125; /&gt;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>经过上述代码的推演后, 概括如下: 受控以及非受控组件的边界划分取决于<code>当前组件对于子组件值的变更是否拥有控制权</code>。如若有则该子组件是当前组件的受控组件; 如若没有则该子组件是当前组件的非受控组件。</p>\n<h3 id=\"职能范围\"><a href=\"#职能范围\" class=\"headerlink\" title=\"职能范围\"></a>职能范围</h3><p>基于调用方对于受控组件拥有控制权这一认知, 因此受控组件相较非受控组件能赋予调用方更多的定制化职能。这一思路与软件开发中的<a href=\"https://baike.baidu.com/item/%E5%BC%80%E6%94%BE%E5%B0%81%E9%97%AD%E5%8E%9F%E5%88%99\" target=\"_blank\" rel=\"noopener\">开放/封闭原则</a>有异曲同工之妙, 同时让笔者受益匪浅的 <a href=\"https://kentcdodds.com/blog/inversion-of-control\" target=\"_blank\" rel=\"noopener\">Inversion of Control</a> 也是类似的思想。</p>\n<p>借助受控组件的赋能, 以 Input 组件为例, 比如调用方可以更为自由地对值进行校验限制, 又比如在值发生变更时执行一些额外逻辑。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 组件提供方</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Input</span>(<span class=\"params\">&#123; value, onChange &#125;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">value</span>=<span class=\"string\">&#123;value&#125;</span> <span class=\"attr\">onChange</span>=<span class=\"string\">&#123;onChange&#125;</span> /&gt;</span></span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 调用方</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Demo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [value, setValue] = React.useState(<span class=\"number\">1</span>)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Input</span> <span class=\"attr\">value</span>=<span class=\"string\">&#123;value&#125;</span> <span class=\"attr\">onChange</span>=<span class=\"string\">&#123;e</span> =&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">    // 只支持数值的变更</span></span><br><span class=\"line\"><span class=\"xml\">    if (/\\D/.test(e.target.value)) return</span></span><br><span class=\"line\"><span class=\"xml\">    setValue(e.target.value)&#125;</span></span><br><span class=\"line\"><span class=\"xml\">  /&gt;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因此综合基础组件<code>扩展性</code>与<code>通用性</code>的考虑, 受控组件的职能相较非受控组件更加宽泛, 建议<code>优先使用受控组件</code>来构建基础组件。</p>\n<h3 id=\"反模式-——-以非受控组件的使用方式调用受控组件\"><a href=\"#反模式-——-以非受控组件的使用方式调用受控组件\" class=\"headerlink\" title=\"反模式 —— 以非受控组件的使用方式调用受控组件\"></a>反模式 —— 以非受控组件的使用方式调用受控组件</h3><p>首先何谓反模式? 笔者将其总结为<code>增大隐性 bug 出现概率的模式</code>, 该模式是<code>最佳实践的对立经验</code>。如若使用了反模式就不得不花更多的精力去避免潜在 bug。官网对反模式也有很好的<a href=\"https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#common-bugs-when-using-derived-state\" target=\"_blank\" rel=\"noopener\">概括总结</a>。</p>\n<p>缘何上文提到以非受控组件的使用方式去调用受控组件是一种反模式? 观察 Input 组件的第一行代码, 其将 defaultValue 赋值给 value, 这种<code>将 props 赋值给 state</code> 的赋值行为在一定程度上会增加某些隐性 bug 的出现概率。</p>\n<p>比如在切换导航栏的场景中, 恰巧两个导航中传进组件的 defaultValue 是相同的值, 在导航切换的过程中便会将导航一中的 Input 的状态值带到导航二中, 这显然会让使用方感到困惑。<a href=\"https://codesandbox.io/s/controllerinput-bobkp\" target=\"_blank\" rel=\"noopener\">codesandbox</a></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 组件提供方</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Input</span>(<span class=\"params\">&#123; defaultValue &#125;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 反模式</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> [value, setValue] = React.useState(defaultValue);</span><br><span class=\"line\">  React.useEffect(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    setValue(defaultValue);</span><br><span class=\"line\">  &#125;, [defaultValue]);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">value</span>=<span class=\"string\">&#123;value&#125;</span> <span class=\"attr\">onChange</span>=<span class=\"string\">&#123;e</span> =&gt;</span> setValue(e.target.value)&#125; /&gt;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 调用方</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Demo</span>(<span class=\"params\">&#123; defaultValue &#125;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Input</span> <span class=\"attr\">defaultValue</span>=<span class=\"string\">&#123;defaultValue&#125;</span> /&gt;</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">App</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [tab, setTab] = React.useState(<span class=\"number\">1</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;&gt;</span><br><span class=\"line\">      &#123;tab === <span class=\"number\">1</span> ? <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Demo</span> <span class=\"attr\">defaultValue</span>=<span class=\"string\">&#123;1&#125;</span> /&gt;</span></span> : <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Demo</span> <span class=\"attr\">defaultValue</span>=<span class=\"string\">&#123;1&#125;</span> /&gt;</span></span>&#125;</span><br><span class=\"line\">      &lt;button onClick=&#123;() =&gt; (tab === <span class=\"number\">1</span> ? setTab(<span class=\"number\">2</span>) : setTab(<span class=\"number\">1</span>))&#125;&gt;</span><br><span class=\"line\">        切换 Tab</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/button&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;/</span>&gt;</span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如何避免使用该反模式同时有效解决问题呢? 官方提供了两种较为优质的解法, 笔者将其留给大家思考。</p>\n<ol>\n<li>方法一: <a href=\"https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#recommendation-fully-controlled-component\" target=\"_blank\" rel=\"noopener\">使用完全受控组件</a>(更为推荐)</li>\n<li>方法二: <a href=\"https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#recommendation-fully-uncontrolled-component-with-a-key\" target=\"_blank\" rel=\"noopener\">使用完全非受控组件 + key</a></li>\n</ol>\n","categories":["React"],"tags":["React","components"]},{"title":"解读 IoC 框架 InversifyJS","url":"/posts/73be8760/","content":"<p><img src=\"http://with.muyunyun.cn/dacdda6b87f5e7acc3ffc74759f97360.jpg-muyy\" alt=\"\"></p>\n<p>InversityJS 是一个 IoC 框架。IoC(Inversion of Control) 包括依赖注入(Dependency Injection) 和依赖查询(Dependency Lookup)。</p>\n<p>相比于类继承的方式，控制反转解耦了父类和子类的联系。</p>\n<a id=\"more\"></a>\n\n<h3 id=\"案例解析\"><a href=\"#案例解析\" class=\"headerlink\" title=\"案例解析\"></a>案例解析</h3><figure class=\"highlight ts\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'reflect-metadata'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; inject, injectable, Container &#125; <span class=\"keyword\">from</span> <span class=\"string\">'inversify'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> container = <span class=\"keyword\">new</span> Container()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@injectable</span>()</span><br><span class=\"line\"><span class=\"keyword\">class</span> PopMusic &#123;</span><br><span class=\"line\">  getName() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'流行音乐'</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">container.bind(<span class=\"string\">'request1'</span>).to(PopMusic)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@injectable</span>()</span><br><span class=\"line\"><span class=\"keyword\">class</span> ClassicalMusic &#123;</span><br><span class=\"line\">  getName() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'古典音乐'</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">container.bind(<span class=\"string\">'request2'</span>).to(ClassicalMusic)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@injectable</span>()</span><br><span class=\"line\"><span class=\"keyword\">class</span> Music &#123;</span><br><span class=\"line\">  pm: <span class=\"built_in\">any</span></span><br><span class=\"line\">  cm: <span class=\"built_in\">any</span></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(<span class=\"params\"></span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"meta\">@inject</span>(<span class=\"string\">'request1'</span>) popMusic: <span class=\"built_in\">any</span>,</span></span><br><span class=\"line\"><span class=\"params\">    <span class=\"meta\">@inject</span>(<span class=\"string\">'request2'</span>) classicalMusic: <span class=\"built_in\">any</span></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.pm = popMusic</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.cm = classicalMusic</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  getName() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> result = <span class=\"keyword\">this</span>.pm.getName() + <span class=\"keyword\">this</span>.cm.getName()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">container.bind(<span class=\"string\">'Plan'</span>).to(Music)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> music: <span class=\"built_in\">any</span> = container.get(<span class=\"string\">'Plan'</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(music.getName()) <span class=\"comment\">// 流行音乐古典音乐</span></span><br></pre></td></tr></table></figure>\n\n<p>上述案例可以抽象为下图：</p>\n<p><img src=\"http://with.muyunyun.cn/8a9ccba28d00ea0c752c3601d716ebcd.jpg-400\" alt=\"\"></p>\n<blockquote>\n<p>虚线表示可以注入，但在代码中没有表现出来。</p>\n</blockquote>\n<p>代码流程可概括如下：</p>\n<p>1.将所有相关类(这里指 Music、popMusic、classicMusic) 通过 <code>@injectable</code> 声明进 <code>container</code> 容器;</p>\n<p>2.通过 <code>container.get()</code> 获取 <code>container.bind().to(target)</code> 中的目标对象(这里指 Music);</p>\n<p>3.如果目标对象中的 constructor() 里有 <code>@inject()</code>, 则将相应的实例(这里指 PopMusic 与 classicalMusic 的实例)当作构造函数的参数’注入’;</p>\n<h3 id=\"inject-injectable-相关源码\"><a href=\"#inject-injectable-相关源码\" class=\"headerlink\" title=\"inject/injectable 相关源码\"></a>inject/injectable 相关源码</h3><p>inject 源码简化如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这是一个属性装饰器</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">inject</span>(<span class=\"params\">serviceIdentifier</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">target, targetKey</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> metadataValue = &#123; [targetKey]: [Metadata &#123; <span class=\"attr\">key</span>: <span class=\"string\">'inject'</span>, <span class=\"attr\">value</span>: serviceIdentifier &#125;)] &#125;</span><br><span class=\"line\">    <span class=\"built_in\">Reflect</span>.defineMetadata(<span class=\"string\">'inversify:tagged_props'</span>, metadataValue, target.constructor);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>injectable 源码简化如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这是一个类装饰器</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">injectable</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">target</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> metadataValue = []</span><br><span class=\"line\">    <span class=\"built_in\">Reflect</span>.defineMetadata(<span class=\"string\">'inversify:paramtypes'</span>, metadataValue, target)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> target</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从简化版源码中可以看到 inject/injectable 最终是对 <code>Reflect.defineMetadata()</code> 的一个使用。可以将 metadata 看成是一种相对高效的数据结构。</p>\n<h4 id=\"reflect-metadata\"><a href=\"#reflect-metadata\" class=\"headerlink\" title=\"reflect-metadata\"></a>reflect-metadata</h4><p>InversityJS 深度结合了 <a href=\"https://github.com/rbuckton/reflect-metadata\" target=\"_blank\" rel=\"noopener\">reflect-metadata</a>, reflect-metadata 在 Reflect 基础上对其 api 进行了扩展。</p>\n<blockquote>\n<p>metadata 本质上是一个 <code>WeakMap</code> 对象。扩展：<a href=\"https://github.com/MuYunyun/blog/blob/master/BasicSkill/algorithm/字典.md#map-和-weakmap-的区别\" target=\"_blank\" rel=\"noopener\">Map 和 WeakMap 的区别</a></p>\n</blockquote>\n<p><code>Reflect.defineMetadata(metadataKey, metadataValue, target[, propertyKey])</code> 简化版实现如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Metadata = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakMap</span>()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">defineMetadata</span>(<span class=\"params\">metadataKey, metadataValue, target, propertyKey</span>) </span>&#123;</span><br><span class=\"line\">  metadataMap = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>()</span><br><span class=\"line\">  metadataMap.set(metadataKey, metadataValue)</span><br><span class=\"line\">  targetMetadata = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>()</span><br><span class=\"line\">  targetMetadata.set(propertyKey, metadataMap)</span><br><span class=\"line\">  Metadata.set(target, targetMetadata)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>Reflect.getOwnMetadata(metadataKey, target[, propertyKey])</code> 简化版实现如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getOwnMetadata</span>(<span class=\"params\">metadataKey, target, propertyKey</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> targetMetadata = Metadata.get(target)</span><br><span class=\"line\">  <span class=\"keyword\">var</span> metadataMap = targetMetadata.get(propertyKey)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> metadataMap.get(metadataKey)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其数据结构可表示如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">WeakMap</span> &#123;</span><br><span class=\"line\">  target: <span class=\"built_in\">Map</span> &#123;</span><br><span class=\"line\">    propertyKey: <span class=\"built_in\">Map</span> &#123;</span><br><span class=\"line\">      metadataKey: metadataValue</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"相关链接\"><a href=\"#相关链接\" class=\"headerlink\" title=\"相关链接\"></a>相关链接</h3><ul>\n<li><a href=\"https://github.com/inversify/InversifyJS/blob/master/wiki/architecture.md\" target=\"_blank\" rel=\"noopener\">Architecture overview</a></li>\n</ul>\n","categories":["IoC"],"tags":["设计模式"]},{"title":"JavaScript 中常见设计模式整理","url":"/posts/ed7c4af7/","content":"<p><img src=\"http://with.muyunyun.cn/27217012b15ee9b788f2103ddbc30c30.jpg-muyy\" alt=\"\"></p>\n<p>开发中，我们或多或少地接触了设计模式，但是很多时候不知道自己使用了哪种设计模式或者说该使用何种设计模式。本文意在梳理常见设计模式的特点，从而对它们有比较清晰的认知。</p>\n<a id=\"more\"></a>\n\n<h3 id=\"JavaScript-中常见设计模式\"><a href=\"#JavaScript-中常见设计模式\" class=\"headerlink\" title=\"JavaScript 中常见设计模式\"></a>JavaScript 中常见设计模式</h3><ul>\n<li><a href=\"https://github.com/MuYunyun/blog/blob/master/BasicSkill/设计模式/单例模式.md\" target=\"_blank\" rel=\"noopener\">单例模式</a></li>\n<li><a href=\"https://github.com/MuYunyun/blog/blob/master/BasicSkill/设计模式/策略模式.md\" target=\"_blank\" rel=\"noopener\">策略模式</a></li>\n<li><a href=\"https://github.com/MuYunyun/blog/blob/master/BasicSkill/设计模式/代理模式.md\" target=\"_blank\" rel=\"noopener\">代理模式</a></li>\n<li><a href=\"https://github.com/MuYunyun/blog/blob/master/BasicSkill/设计模式/迭代器模式.md\" target=\"_blank\" rel=\"noopener\">迭代器模式</a></li>\n<li><a href=\"https://github.com/MuYunyun/blog/blob/master/BasicSkill/设计模式/发布订阅模式.md\" target=\"_blank\" rel=\"noopener\">发布-订阅模式</a></li>\n<li><a href=\"https://github.com/MuYunyun/blog/blob/master/BasicSkill/设计模式/命令模式.md\" target=\"_blank\" rel=\"noopener\">命令模式</a></li>\n<li><a href=\"https://github.com/MuYunyun/blog/blob/master/BasicSkill/设计模式/组合模式.md\" target=\"_blank\" rel=\"noopener\">组合模式</a></li>\n<li><a href=\"https://github.com/MuYunyun/blog/blob/master/BasicSkill/设计模式/模板方法模式.md\" target=\"_blank\" rel=\"noopener\">模板方法模式</a></li>\n<li><a href=\"https://github.com/MuYunyun/blog/blob/master/BasicSkill/设计模式/享元模式.md\" target=\"_blank\" rel=\"noopener\">享元模式</a></li>\n<li><a href=\"https://github.com/MuYunyun/blog/blob/master/BasicSkill/设计模式/职责链模式.md\" target=\"_blank\" rel=\"noopener\">职责链模式</a></li>\n<li><a href=\"https://github.com/MuYunyun/blog/blob/master/BasicSkill/设计模式/中介者模式.md\" target=\"_blank\" rel=\"noopener\">中介者模式</a></li>\n<li><a href=\"https://github.com/MuYunyun/blog/blob/master/BasicSkill/设计模式/装饰者模式.md\" target=\"_blank\" rel=\"noopener\">装饰者模式</a></li>\n<li><a href=\"https://github.com/MuYunyun/blog/blob/master/BasicSkill/设计模式/状态模式.md\" target=\"_blank\" rel=\"noopener\">状态模式</a></li>\n<li><a href=\"https://github.com/MuYunyun/blog/blob/master/BasicSkill/设计模式/适配者模式.md\" target=\"_blank\" rel=\"noopener\">适配者模式</a></li>\n<li><a href=\"https://github.com/MuYunyun/blog/blob/master/BasicSkill/设计模式/观察者模式.md\" target=\"_blank\" rel=\"noopener\">观察者模式</a></li>\n</ul>\n<h3 id=\"各设计模式关键词\"><a href=\"#各设计模式关键词\" class=\"headerlink\" title=\"各设计模式关键词\"></a>各设计模式关键词</h3><p>看完了上述设计模式后，把它们的关键词特点罗列出来，以后提到某种设计模式，进而联想相应的关键词和例子，从而心中有数。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">设计模式</th>\n<th align=\"center\">特点</th>\n<th align=\"center\">案例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">单例模式</td>\n<td align=\"center\">一个类只能构造出唯一实例</td>\n<td align=\"center\"><a href=\"https://github.com/MuYunyun/blog/blob/master/BasicSkill/设计模式/单例模式.md\" target=\"_blank\" rel=\"noopener\">创建菜单对象</a></td>\n</tr>\n<tr>\n<td align=\"center\">策略模式</td>\n<td align=\"center\">根据不同参数可以命中不同的策略</td>\n<td align=\"center\"><a href=\"https://github.com/MuYunyun/blog/blob/master/BasicSkill/设计模式/策略模式.md\" target=\"_blank\" rel=\"noopener\">动画库里的算法函数</a></td>\n</tr>\n<tr>\n<td align=\"center\">代理模式</td>\n<td align=\"center\">代理对象和本体对象具有一致的接口</td>\n<td align=\"center\"><a href=\"https://github.com/MuYunyun/blog/blob/master/BasicSkill/设计模式/代理模式.md\" target=\"_blank\" rel=\"noopener\">图片预加载</a></td>\n</tr>\n<tr>\n<td align=\"center\">迭代器模式</td>\n<td align=\"center\">能获取聚合对象的顺序和元素</td>\n<td align=\"center\"><code>each([1, 2, 3], cb)</code></td>\n</tr>\n<tr>\n<td align=\"center\">发布-订阅模式</td>\n<td align=\"center\">PubSub</td>\n<td align=\"center\"><a href=\"https://github.com/MuYunyun/waterfall/blob/0f229c1a2881d26166b92aa746b7f892af59c28f/waterfall.js#L8\" target=\"_blank\" rel=\"noopener\">瀑布流库</a></td>\n</tr>\n<tr>\n<td align=\"center\">命令模式</td>\n<td align=\"center\">不同对象间约定好相应的接口</td>\n<td align=\"center\"><a href=\"https://github.com/MuYunyun/blog/blob/master/BasicSkill/设计模式/命令模式.md\" target=\"_blank\" rel=\"noopener\">按钮和命令的分离</a></td>\n</tr>\n<tr>\n<td align=\"center\">组合模式</td>\n<td align=\"center\">组合模式在对象间形成一致对待的树形结构</td>\n<td align=\"center\"><a href=\"https://github.com/MuYunyun/blog/blob/master/BasicSkill/设计模式/组合模式.md\" target=\"_blank\" rel=\"noopener\">扫描文件夹</a></td>\n</tr>\n<tr>\n<td align=\"center\">模板方法模式</td>\n<td align=\"center\">父类中定好执行顺序</td>\n<td align=\"center\"><a href=\"https://github.com/MuYunyun/blog/blob/master/BasicSkill/设计模式/模板方法模式.md\" target=\"_blank\" rel=\"noopener\">咖啡和茶</a></td>\n</tr>\n<tr>\n<td align=\"center\">享元模式</td>\n<td align=\"center\">减少创建实例的个数</td>\n<td align=\"center\"><a href=\"https://github.com/MuYunyun/blog/blob/master/BasicSkill/设计模式/享元模式.md\" target=\"_blank\" rel=\"noopener\">男女模具试装</a></td>\n</tr>\n<tr>\n<td align=\"center\">职责链模式</td>\n<td align=\"center\">通过请求第一个条件，会持续执行后续的条件，直到返回结果为止</td>\n<td align=\"center\"><a href=\"https://github.com/MuYunyun/blog/blob/master/BasicSkill/设计模式/职责链模式.md\" target=\"_blank\" rel=\"noopener\">if else 优化</a></td>\n</tr>\n<tr>\n<td align=\"center\">中介者模式</td>\n<td align=\"center\">对象和对象之间借助第三方中介者进行通信</td>\n<td align=\"center\"><a href=\"https://github.com/MuYunyun/blog/blob/master/BasicSkill/设计模式/中介者模式.md\" target=\"_blank\" rel=\"noopener\">测试结束告知结果</a></td>\n</tr>\n<tr>\n<td align=\"center\">装饰者模式</td>\n<td align=\"center\">动态地给函数赋能</td>\n<td align=\"center\"><a href=\"https://github.com/MuYunyun/blog/blob/master/BasicSkill/设计模式/装饰者模式.md\" target=\"_blank\" rel=\"noopener\">天冷了穿衣服，热了脱衣服</a></td>\n</tr>\n<tr>\n<td align=\"center\">状态模式</td>\n<td align=\"center\">每个状态建立一个类，状态改变会产生不同行为</td>\n<td align=\"center\"><a href=\"https://github.com/MuYunyun/blog/blob/master/BasicSkill/设计模式/状态模式.md\" target=\"_blank\" rel=\"noopener\">电灯换挡</a></td>\n</tr>\n<tr>\n<td align=\"center\">适配者模式</td>\n<td align=\"center\">一种数据结构改成另一种数据结构</td>\n<td align=\"center\"><a href=\"https://github.com/MuYunyun/blog/blob/master/BasicSkill/设计模式/适配者模式.md\" target=\"_blank\" rel=\"noopener\">枚举值接口变更</a></td>\n</tr>\n<tr>\n<td align=\"center\">观察者模式</td>\n<td align=\"center\">当观察对象发生变化时自动调用相关函数</td>\n<td align=\"center\"><a href=\"https://github.com/MuYunyun/blog/issues/11\" target=\"_blank\" rel=\"noopener\">vue 双向绑定</a></td>\n</tr>\n</tbody></table>\n<h3 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h3><p>*《JavaScript设计模式与开发实践》</p>\n","categories":["设计模式"],"tags":["设计模式"]},{"title":"MVVM 框架解析之双向绑定","url":"/posts/384a97b3/","content":"<p><img src=\"http://with.muyunyun.cn/203d14fb02edc5f37ae3841a2372434b.jpg-muyy\" alt=\"\"></p>\n<h3 id=\"MVVM-框架\"><a href=\"#MVVM-框架\" class=\"headerlink\" title=\"MVVM 框架\"></a>MVVM 框架</h3><p>近年来前端一个明显的开发趋势就是架构从传统的 MVC 模式向 MVVM 模式迁移。在传统的 MVC 下，当前前端和后端发生数据交互后会刷新整个页面，从而导致比较差的用户体验。因此我们通过 Ajax 的方式和网关 REST API 作通讯，异步的刷新页面的某个区块，来优化和提升体验。</p>\n<a id=\"more\"></a>\n\n<h4 id=\"MVVM-框架基本概念\"><a href=\"#MVVM-框架基本概念\" class=\"headerlink\" title=\"MVVM 框架基本概念\"></a>MVVM 框架基本概念</h4><p><img src=\"http://with.muyunyun.cn/203d14fb02edc5f37ae3841a2372434b.jpg-400\" alt=\"\"></p>\n<p>在 MVVM 框架中，View(视图) 和 Model(数据) 是不可以直接通讯的，在它们之间存在着 ViewModel 这个中间介充当着观察者的角色。当用户操作 View(视图)，ViewModel 感知到变化，然后通知 Model 发生相应改变；反之当 Model(数据) 发生改变，ViewModel 也能感知到变化，使 View 作出相应更新。这个一来一回的过程就是我们所熟知的双向绑定。</p>\n<h4 id=\"MVVM-框架的应用场景\"><a href=\"#MVVM-框架的应用场景\" class=\"headerlink\" title=\"MVVM 框架的应用场景\"></a>MVVM 框架的应用场景</h4><p>MVVM 框架的好处显而易见：当前端对数据进行操作的时候，可以通过 Ajax 请求对数据持久化，只需改变 dom 里需要改变的那部分数据内容，而不必刷新整个页面。特别是在移动端，刷新页面的代价太昂贵。虽然有些资源会被缓存，但是页面的 dom、css、js 都会被浏览器重新解析一遍，因此移动端页面通常会被做成 SPA 单页应用。由此在这基础上诞生了很多 MVVM 框架，比如 React.js、Vue.js、Angular.js 等等。</p>\n<h3 id=\"MVVM-框架的简单实现\"><a href=\"#MVVM-框架的简单实现\" class=\"headerlink\" title=\"MVVM 框架的简单实现\"></a>MVVM 框架的简单实现</h3><blockquote>\n<p>贴士：这篇文章主要是针对 vue 的双向绑定实现，React 中其实并没有双向绑定这一说。</p>\n</blockquote>\n<p><img src=\"http://with.muyunyun.cn/ecac404dd0a757b06ae1bd1b5c8212ef.jpg-600\" alt=\"\"></p>\n<p>模拟 Vue 的双向绑定流，实现了一个简单的 <a href=\"https://github.com/MuYunyun/mvvm\" target=\"_blank\" rel=\"noopener\">MVVM 框架</a>，从上图中可以看出虚线方形中就是之前提到的 ViewModel 中间介层，它充当着观察者的角色。另外可以发现双向绑定流中的 View 到 Model 其实是通过 input 的事件监听函数实现的，如果换成 React(单向绑定流) 的话，它在这一步交给状态管理工具(比如 Redux)来实现。另外双向绑定流中的 Model 到 View 其实各个 MVVM 框架实现的都是大同小异的，都用到的核心方法是 <code>Object.defineProperty()</code>，通过这个方法可以进行数据劫持，当数据发生变化时可以捕捉到相应变化，从而进行后续的处理。</p>\n<p><img src=\"http://with.muyunyun.cn/4b8db3d45cd6f37935e9bec42f0095c7.jpg-300\" alt=\"\"></p>\n<h4 id=\"Mvvm-入口文件-的实现\"><a href=\"#Mvvm-入口文件-的实现\" class=\"headerlink\" title=\"Mvvm(入口文件) 的实现\"></a>Mvvm(入口文件) 的实现</h4><p>一般会这样调用 Mvvm 框架</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> vm = <span class=\"keyword\">new</span> Mvvm(&#123;</span><br><span class=\"line\">            el: <span class=\"string\">'#app'</span>,</span><br><span class=\"line\">            data: &#123;</span><br><span class=\"line\">              title: <span class=\"string\">'mvvm title'</span>,</span><br><span class=\"line\">              name: <span class=\"string\">'mvvm name'</span></span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">          &#125;)</span><br></pre></td></tr></table></figure>\n\n<p>但是这样子的话，如果要得到 title 属性就要形如 vm.data.title 这样取得，为了让 vm.title 就能获得 title 属性，从而在 Mvvm 的 prototype 上加上一个代理方法，代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Mvvm</span> (<span class=\"params\">options</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.data = options.data</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> self = <span class=\"keyword\">this</span></span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.keys(<span class=\"keyword\">this</span>.data).forEach(<span class=\"function\"><span class=\"params\">key</span> =&gt;</span></span><br><span class=\"line\">    self.proxyKeys(key)</span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Mvvm.prototype = &#123;</span><br><span class=\"line\">  proxyKeys: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">key</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> self = <span class=\"keyword\">this</span></span><br><span class=\"line\">    <span class=\"built_in\">Object</span>.defineProperty(<span class=\"keyword\">this</span>, key, &#123;</span><br><span class=\"line\">      <span class=\"keyword\">get</span>: function () &#123; <span class=\"comment\">// 这里的 get 和 set 实现了 vm.data.title 和 vm.title 的值同步</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.data[key]</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      <span class=\"keyword\">set</span>: function (newValue) &#123;</span><br><span class=\"line\">        self.data[key] = newValue</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实现了代理方法后，就步入主流程的实现</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Mvvm</span> (<span class=\"params\">options</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.data = options.data</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  observe(<span class=\"keyword\">this</span>.data)</span><br><span class=\"line\">  <span class=\"keyword\">new</span> Compile(options.el, <span class=\"keyword\">this</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"observer-观察者-的实现\"><a href=\"#observer-观察者-的实现\" class=\"headerlink\" title=\"observer(观察者) 的实现\"></a>observer(观察者) 的实现</h4><p>observer 的职责是监听 Model(JS 对象) 的变化，最核心的部分就是用到了 Object.defineProperty() 的 get 和 set 方法，当要获取 Model(JS 对象) 的值时，会自动调用 get 方法；当改动了 Model(JS 对象) 的值时，会自动调用 set 方法；从而实现了对数据的劫持，代码如下所示。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> data = &#123;</span><br><span class=\"line\">  number: <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">observe(data)</span><br><span class=\"line\"></span><br><span class=\"line\">data.number = <span class=\"number\">1</span> <span class=\"comment\">// 值发生变化</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">observe</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!data || <span class=\"keyword\">typeof</span>(data) !== <span class=\"string\">'object'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> self = <span class=\"keyword\">this</span></span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.keys(data).forEach(<span class=\"function\"><span class=\"params\">key</span> =&gt;</span></span><br><span class=\"line\">    self.defineReactive(data, key, data[key])</span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">defineReactive</span>(<span class=\"params\">data, key, value</span>) </span>&#123;</span><br><span class=\"line\">  observe(value) <span class=\"comment\">// 遍历嵌套对象</span></span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.defineProperty(data, key, &#123;</span><br><span class=\"line\">    <span class=\"keyword\">get</span>: function() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> value</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"keyword\">set</span>: function(newValue) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (value !== newValue) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'值发生变化'</span>, <span class=\"string\">'newValue:'</span> + newValue + <span class=\"string\">' '</span> + <span class=\"string\">'oldValue:'</span> + value)</span><br><span class=\"line\">        value = newValue</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行代码，可以看到控制台输出 <code>值发生变化 newValue:1 oldValue:0</code>，至此就完成了 observer 的逻辑。</p>\n<h4 id=\"Dep-订阅者数组-和-watcher-订阅者-的关系\"><a href=\"#Dep-订阅者数组-和-watcher-订阅者-的关系\" class=\"headerlink\" title=\"Dep(订阅者数组) 和 watcher(订阅者) 的关系\"></a>Dep(订阅者数组) 和 watcher(订阅者) 的关系</h4><p>观测到变化后，我们总要通知给特定的人群，让他们做出相应的处理吧。为了更方便地理解，我们可以把订阅当成是订阅了一个微信公众号，当微信公众号的内容有更新时，那么它会把内容推送(update) 到订阅了它的人。</p>\n<p><img src=\"http://with.muyunyun.cn/42bd217acd8b2ef5c76de1ca65ba7581.jpg-200\" alt=\"\"></p>\n<p>那么订阅了同个微信公众号的人有成千上万个，那么首先想到的就是要 new Array() 去存放这些人(html 节点)吧。于是就有了如下代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// observer.js</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Dep</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.subs = [] <span class=\"comment\">// 存放订阅者</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Dep.prototype = &#123;</span><br><span class=\"line\">  addSub: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">sub</span>) </span>&#123; <span class=\"comment\">// 添加订阅者</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.subs.push(sub)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  notify: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// 通知订阅者更新</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.subs.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">sub</span>) </span>&#123;</span><br><span class=\"line\">      sub.update()</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">observe</span>(<span class=\"params\">data</span>) </span>&#123;...&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">defineReactive</span>(<span class=\"params\">data, key, value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> dep = <span class=\"keyword\">new</span> Dep()</span><br><span class=\"line\">  observe(value) <span class=\"comment\">// 遍历嵌套对象</span></span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.defineProperty(data, key, &#123;</span><br><span class=\"line\">    <span class=\"keyword\">get</span>: function() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (Dep.target) &#123; <span class=\"comment\">// 往订阅器添加订阅者</span></span><br><span class=\"line\">        dep.addSub(Dep.target)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> value</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"keyword\">set</span>: function(newValue) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (value !== newValue) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'值发生变化'</span>, <span class=\"string\">'newValue:'</span> + newValue + <span class=\"string\">' '</span> + <span class=\"string\">'oldValue:'</span> + value)</span><br><span class=\"line\">        value = newValue</span><br><span class=\"line\">        dep.notify()</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>初看代码也比较顺畅了，但可能会卡在 <code>Dep.target</code> 和 <code>sub.update</code>，由此自然而然地将目光移向 watcher，</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// watcher.js</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Watcher</span>(<span class=\"params\">vm, exp, cb</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.vm = vm</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.exp = exp</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.cb = cb</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.value = <span class=\"keyword\">this</span>.get()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Watcher.prototype = &#123;</span><br><span class=\"line\">  update: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.run()</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  run: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (value !== oldVal) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.cb.call(<span class=\"keyword\">this</span>.vm, value) <span class=\"comment\">// 触发 compile 中的回调</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">get</span>: function() &#123;</span><br><span class=\"line\">    Dep.target = <span class=\"keyword\">this</span> <span class=\"comment\">// 缓存自己</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> value = <span class=\"keyword\">this</span>.vm.data[<span class=\"keyword\">this</span>.exp] <span class=\"comment\">// 强制执行监听器里的 get 函数</span></span><br><span class=\"line\">    Dep.target = <span class=\"literal\">null</span> <span class=\"comment\">// 释放自己</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> value</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从代码中可以看到当构造 Watcher 实例时，会调用 get() 方法，接着重点关注 <code>const value = this.vm.data[this.exp]</code> 这句，前面说了当要获取 Model(JS 对象) 的值时，会自动调用 Object.defineProperty 的 get 方法，也就是当执行完这句的时候，Dep.target 的值传进了 observer.js 中的 Object.defineProperty 的 get 方法中。同时也一目了然地在 Watcher.prototype 中发现了 update 方法，其作用即触发 compile 中绑定的回调来更新界面。至此解释了 Observer 中 Dep.target 和 sub.update 的由来。</p>\n<p>来归纳下 Watcher 的作用，其充当了 observer 和 compile 的桥梁。</p>\n<p>1 在自身实例化的过程中，往订阅器(dep) 中添加自己</p>\n<p>2 当 model 发生变动，dep.notify() 通知时，其能调用自身的 update 函数，并触发 compile 绑定的回调函数实现视图更新</p>\n<p>最后再来看下生成 Watcher 实例的 compile.js 文件。</p>\n<h4 id=\"compile-编译-的实现\"><a href=\"#compile-编译-的实现\" class=\"headerlink\" title=\"compile(编译) 的实现\"></a>compile(编译) 的实现</h4><p>首先遍历解析的过程有多次操作 dom 节点，为提高性能和效率，会先将跟节点 el 转换成 fragment(文档碎片) 进行解析编译，解析完成，再将 fragment 添加回原来的真实 dom 节点中。代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Compile</span>(<span class=\"params\">el, vm</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.vm = vm</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.el = <span class=\"built_in\">document</span>.querySelector(el)</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.fragment = <span class=\"literal\">null</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.init()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Compile.prototype = &#123;</span><br><span class=\"line\">  init: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.el) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.fragment = <span class=\"keyword\">this</span>.nodeToFragment(<span class=\"keyword\">this</span>.el) <span class=\"comment\">// 将节点转为 fragment 文档碎片</span></span><br><span class=\"line\">      <span class=\"keyword\">this</span>.compileElement(<span class=\"keyword\">this</span>.fragment) <span class=\"comment\">// 对 fragment 进行编译解析</span></span><br><span class=\"line\">      <span class=\"keyword\">this</span>.el.appendChild(<span class=\"keyword\">this</span>.fragment)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  nodeToFragment: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">el</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> fragment = <span class=\"built_in\">document</span>.createDocumentFragment()</span><br><span class=\"line\">    <span class=\"keyword\">let</span> child = el.firstChild <span class=\"comment\">// △ 第一个 firstChild 是 text</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(child) &#123;</span><br><span class=\"line\">      fragment.appendChild(child)</span><br><span class=\"line\">      child = el.firstChild</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fragment</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  compileElement: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">el</span>) </span>&#123;...&#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个简单的 mvvm 框架在对 fragment 编译解析的过程中对 <code>{{}} 文本元素</code>、<code>v-on:click 事件指令</code>、<code>v-model 指令</code>三种类型进行了相应的处理。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">Compile.prototype = &#123;</span><br><span class=\"line\">  init: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.el) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.fragment = <span class=\"keyword\">this</span>.nodeToFragment(<span class=\"keyword\">this</span>.el) <span class=\"comment\">// 将节点转为 fragment 文档碎片</span></span><br><span class=\"line\">      <span class=\"keyword\">this</span>.compileElement(<span class=\"keyword\">this</span>.fragment) <span class=\"comment\">// 对 fragment 进行编译解析</span></span><br><span class=\"line\">      <span class=\"keyword\">this</span>.el.appendChild(<span class=\"keyword\">this</span>.fragment)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  nodeToFragment: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">el</span>) </span>&#123;...&#125;,</span><br><span class=\"line\">  compileElement: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">el</span>) </span>&#123;...&#125;,</span><br><span class=\"line\">  compileText: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">node, exp</span>) </span>&#123; <span class=\"comment\">// 对文本类型进行处理替换</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> self = <span class=\"keyword\">this</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> initText = <span class=\"keyword\">this</span>.vm[exp]</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.updateText(node, initText) <span class=\"comment\">// 初始化</span></span><br><span class=\"line\">    <span class=\"keyword\">new</span> Watcher(<span class=\"keyword\">this</span>.vm, exp, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123; <span class=\"comment\">// 实例化订阅者</span></span><br><span class=\"line\">      self.updateText(node, value)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  compileEvent: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">node, vm, exp, dir</span>) </span>&#123; <span class=\"comment\">// 对事件指令进行处理</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> eventType = dir.split(<span class=\"string\">':'</span>)[<span class=\"number\">1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">const</span> cb = vm.methods &amp;&amp; vm.methods[exp]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (eventType &amp;&amp; cb) &#123;</span><br><span class=\"line\">      node.addEventListener(eventType, cb.bind(vm), <span class=\"literal\">false</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  compileModel: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">node, vm, exp</span>) </span>&#123; <span class=\"comment\">// 对 v-model 进行处理</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> val = vm[exp]</span><br><span class=\"line\">    <span class=\"keyword\">const</span> self = <span class=\"keyword\">this</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.modelUpdater(node, val)</span><br><span class=\"line\">    node.addEventListener(<span class=\"string\">'input'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> newValue = e.target.value</span><br><span class=\"line\">      self.vm[exp] = newValue <span class=\"comment\">// 实现 view 到 model 的绑定</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在上述代码的 compileTest 函数中看到了期盼已久的 Watcher 实例化，对 Watcher 作用模糊的朋友可以往上回顾下 Watcher 的作用。另外在 compileModel 函数中看到了本文最开始提到的双向绑定流中的 View 到 Model 是借助 input 监听事件变化实现的。</p>\n<h3 id=\"项目地址\"><a href=\"#项目地址\" class=\"headerlink\" title=\"项目地址\"></a>项目地址</h3><p>本文记录了些阅读 mvvm 框架源码关于双向绑定的心得，并动手实践了一个简版的 mvvm 框架，不足之处在所难免，欢迎指正。</p>\n<p><a href=\"http://muyunyun.cn/mvvm/\">项目演示</a></p>\n<p><a href=\"https://github.com/MuYunyun/mvvm\" target=\"_blank\" rel=\"noopener\">项目地址</a></p>\n","categories":["Mvvm"],"tags":["Mvvm"]},{"title":"React Hooks 深入系列","url":"/posts/290a4219/","content":"<p><img src=\"http://with.muyunyun.cn/34a60f7edb08afaf6d721708ab21b4d7.jpg-muyy\" alt=\"\"></p>\n<p>本文为对 hooks 碎片化的理解。同时欢迎关注基于 hooks 构建的 UI 组件库 —— <a href=\"https://github.com/ming-cult/snake-design\" target=\"_blank\" rel=\"noopener\">snake-design</a>。</p>\n<a id=\"more\"></a>\n\n<p>在 class 已经融入 React 生态的节点下, React 推出的 Hooks 具有如下优势:</p>\n<ul>\n<li>更简洁的书写;</li>\n<li>相对类中的 <code>HOC</code> 与 <code>render Props</code>, Hooks 拥有更加自由地组合抽象的能力;</li>\n</ul>\n<h3 id=\"使用-Hooks-的注意项\"><a href=\"#使用-Hooks-的注意项\" class=\"headerlink\" title=\"使用 Hooks 的注意项\"></a>使用 Hooks 的注意项</h3><ul>\n<li><p>在 <code>hooks</code> 中每一次 <code>render</code> 都有自己的 <code>state</code> 和 <code>props</code>, 这与 <code>class</code> 中存在差异, 见 <a href=\"https://overreacted.io/a-complete-guide-to-useeffect/#each-render-has-its-own-everything\" target=\"_blank\" rel=\"noopener\">Hooks 每次渲染都是闭包</a></p>\n<ul>\n<li><code>class</code> 中可以用闭包模拟 <code>hooks</code> 的表现, <a href=\"https://codesandbox.io/s/w7vjo07055\" target=\"_blank\" rel=\"noopener\">链接</a>, <code>hooks</code> 中可以使用 <code>ref</code> 模拟 <code>class</code> 的表现, <a href=\"https://codesandbox.io/s/rm7z22qnlp\" target=\"_blank\" rel=\"noopener\">链接</a>;</li>\n</ul>\n</li>\n<li><p>写出 useEffect 的所用到的依赖</p>\n</li>\n</ul>\n<p>在以下 demo 中, <code>useEffect</code> 的第二个参数传入 <code>[]</code>, 希望的是 <code>useEffect</code> 里的函数只执行一次(类似在 <code>componentDidMount</code> 中执行一次, 但是注意这里仅仅是<code>类似</code>, 详细原因见上一条注意项), 页面上每隔 1s 递增 1。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Demo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [count, setCount] = useState(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  useEffect(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> id = setInterval(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      setCount(count + <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      clearInterval(id);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;, []);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但这样达到我们预期的效果了么? <a href=\"https://codesandbox.io/s/n3o2m1wpj4\" target=\"_blank\" rel=\"noopener\">demo</a>, 可以看到界面上只增加到 1 就停止了。原因就是传入的第二个参数 <code>[]</code> 搞的鬼, <code>[]</code> 表示没有外界状态对 <code>effect</code> 产生干扰。流程大致如下:</p>\n<ol>\n<li>第一次调用 <code>useEffect</code> 传入的 <code>count</code> 为 0, 于是 <code>setCount(0 + 1)</code>;</li>\n<li>受 <code>useEffect</code> 第二个参数 <code>[]</code> 的影响，<code>count</code> 仍然为 0, 所以相当于还是 <code>setCount(0 + 1)</code>;</li>\n</ol>\n<p>那如何修正上述问题呢? 方法有两个(方法一为主, 方法二为辅):</p>\n<ul>\n<li>方法一: 将 <code>[]</code> 改为 <code>[count]</code></li>\n<li>方法二: 将 <code>setCount(count + 1)</code> 改为 <code>setCount(count =&gt; count + 1)</code>。这种方法的思想是修正状态的值而不依赖外面传进的状态。</li>\n</ul>\n<p>不过遇到 <code>setCount(count =&gt; count + 1)</code> 的情况就可以考虑使用 <code>useReducer</code> 了。</p>\n<h4 id=\"何时使用-useReducer\"><a href=\"#何时使用-useReducer\" class=\"headerlink\" title=\"何时使用 useReducer\"></a>何时使用 useReducer</h4><p>使用 <code>useState</code> 的地方都能用 <code>useReducer</code> 进行替代。相较 <code>useState</code>, <code>useReducer</code> 有如下优势:</p>\n<ul>\n<li><code>useReducer</code> 将 <code>how</code>(reducer) 和 <code>what</code>(dispatch(action)) 进行抽离; 使用 <code>reducer</code> 逻辑状态进行集中化维护;</li>\n<li>相比 useState, useReducer 没有<a href=\"https://overreacted.io/a-complete-guide-to-useeffect/#each-render-has-its-own-everything\" target=\"_blank\" rel=\"noopener\">闭包问题</a>;</li>\n<li>当状态的一个 state 依赖状态中的另一个 state 时, 这种情况最好使用 useReducer; 可以参考 <a href=\"https://overreacted.io/a-complete-guide-to-useeffect/#decoupling-updates-from-actions\" target=\"_blank\" rel=\"noopener\">decoupling-updates-from-actions</a> 中 Dan 列举的 demo。</li>\n</ul>\n<h4 id=\"处理-useEffect-中的公用函数\"><a href=\"#处理-useEffect-中的公用函数\" class=\"headerlink\" title=\"处理 useEffect 中的公用函数\"></a>处理 useEffect 中的公用函数</h4><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Demo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [count, setCount] = useState(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getFetchUrl</span>(<span class=\"params\">query</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">`http://demo<span class=\"subst\">$&#123;query&#125;</span>`</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  useEffect(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> url = getFetchUrl(<span class=\"string\">'react'</span>)</span><br><span class=\"line\">  &#125;, [getFetchUrl]);</span><br><span class=\"line\"></span><br><span class=\"line\">  useEffect(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> url = getFetchUrl(<span class=\"string\">'redux'</span>)</span><br><span class=\"line\">  &#125;, [getFetchUrl]);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>此时 <code>useEffect</code> 中传入的第二个参数 <code>getFetchUrl</code> 相当于每次都是新的, 所以每次都会请求数据, 那除了 <code>[getFetchUrl]</code> 将改为 <code>[]</code> 这种不推荐的写法外，有两种解决方法:</p>\n<p>*. 方法一: 提升 <code>getFetchUrl</code> 的作用域;<br>*. 方法二: 使用 <code>useCallback</code> 或者 <code>useMemo</code> 来包裹 getFetchUrl;</p>\n<blockquote>\n<p><code>React.memo</code> 修饰一个函数组件, <code>useMemo</code> 修饰一个函数。它们本质都是运用缓存。</p>\n</blockquote>\n<h3 id=\"React-Hooks-内部是怎么工作的\"><a href=\"#React-Hooks-内部是怎么工作的\" class=\"headerlink\" title=\"React Hooks 内部是怎么工作的\"></a>React Hooks 内部是怎么工作的</h3><p>为了理解 React Hooks 内部实现原理, 对 <code>useState</code>、<code>useEffect</code> 进行了简单的实现。</p>\n<h4 id=\"useState-的简单实现\"><a href=\"#useState-的简单实现\" class=\"headerlink\" title=\"useState 的简单实现\"></a>useState 的简单实现</h4><p>使用闭包来实现 <code>useState</code> 的简单逻辑:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这里使用闭包</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> React = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> _val</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    useState(initialValue) &#123;</span><br><span class=\"line\">      _val = _val || initialValue</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">setVal</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">        _val = value</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">return</span> [_val, setVal]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)()</span><br></pre></td></tr></table></figure>\n\n<p>测试如下:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Counter</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [count, setCount] = React.useState(<span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    render: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">console</span>.log(count),</span><br><span class=\"line\">    click: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> setCount(count + <span class=\"number\">1</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Counter().render() <span class=\"comment\">// 0</span></span><br><span class=\"line\">Counter().click()  <span class=\"comment\">// 模拟点击</span></span><br><span class=\"line\">Counter().render() <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"useEffect-的简单实现\"><a href=\"#useEffect-的简单实现\" class=\"headerlink\" title=\"useEffect 的简单实现\"></a>useEffect 的简单实现</h4><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> React = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> _val, _deps</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    useState(initialValue) &#123;</span><br><span class=\"line\">      _val = _val || initialValue</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">setVal</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">        _val = value</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">return</span> [_val, setVal]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    useEffect(callback, deps) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> ifUpdate = !deps</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 判断 Deps 中的依赖是否改变</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> ifDepsChange = _deps ? !_deps.every(<span class=\"function\">(<span class=\"params\">r, index</span>) =&gt;</span> r === deps[index]) : <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (ifUpdate || ifDepsChange) &#123;</span><br><span class=\"line\">        callback()</span><br><span class=\"line\"></span><br><span class=\"line\">        _deps = deps || []</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)()</span><br></pre></td></tr></table></figure>\n\n<p>测试代码如下:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> &#123;useState, useEffect&#125; = React</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Counter</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [count, setCount] = useState(<span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  useEffect(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'useEffect'</span>, count)</span><br><span class=\"line\">  &#125;, [count])</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    render: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">'render'</span>, count),</span><br><span class=\"line\">    click: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> setCount(count + <span class=\"number\">1</span>),</span><br><span class=\"line\">    noop: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> setCount(count), <span class=\"comment\">// 保持不变, 观察 useEffect 是否被调用</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Counter().render() <span class=\"comment\">// 'useEffect' 0, 'render', 0</span></span><br><span class=\"line\">Counter().noop()</span><br><span class=\"line\">Counter().render() <span class=\"comment\">// 'render', 0</span></span><br><span class=\"line\">Counter().click()</span><br><span class=\"line\">Counter().render() <span class=\"comment\">// 'useEffect' 1, 'render', 1</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"处理多次调用的情形\"><a href=\"#处理多次调用的情形\" class=\"headerlink\" title=\"处理多次调用的情形\"></a>处理多次调用的情形</h4><p>为了在 <code>hooks</code> 中能使用多次 <code>useState</code>, <code>useEffect</code>, 将各个 <code>useState</code>, <code>useEffect</code> 的调用存进一个数组中, 在上面基础上进行如下改造:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> React = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> hooks = []</span><br><span class=\"line\">  <span class=\"keyword\">let</span> currentHook = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    render(Component) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> component = Component()</span><br><span class=\"line\">      component.render()</span><br><span class=\"line\">      currentHook = <span class=\"number\">0</span> <span class=\"comment\">// 重置, 这里很关键, 将 hooks 的执行放到 hooks 队列中, 确保每次执行的顺序保持一致。</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> component</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    useState(initialValue) &#123;</span><br><span class=\"line\">      hooks[currentHook] = hooks[currentHook] || initialValue</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">setVal</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">        hooks[currentHook] = value</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">return</span> [hooks[currentHook++], setVal]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    useEffect(callback, deps) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> ifUpdate = !deps</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 判断 Deps 中的依赖是否改变</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> ifDepsChange = hooks[currentHook] ? !hooks[currentHook].every(<span class=\"function\">(<span class=\"params\">r, index</span>) =&gt;</span> r === deps[index]) : <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (ifUpdate || ifDepsChange) &#123;</span><br><span class=\"line\">        callback()</span><br><span class=\"line\"></span><br><span class=\"line\">        hooks[currentHook++] = deps || []</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)()</span><br></pre></td></tr></table></figure>\n\n<p>测试代码如下:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> &#123;useState, useEffect&#125; = React</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Counter</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [count, setCount] = useState(<span class=\"number\">0</span>)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [type, setType] = useState(<span class=\"string\">'hi'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  useEffect(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'useEffect'</span>, count)</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'type'</span>, type)</span><br><span class=\"line\">  &#125;, [count, type])</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    render: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">'render'</span>, count),</span><br><span class=\"line\">    click: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> setCount(count + <span class=\"number\">1</span>),</span><br><span class=\"line\">    noop: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> setCount(count), <span class=\"comment\">// 保持不变, 观察 useEffect 是否被调用</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 如下 mock 执行了 useEffect、render; 这里使用 React.render 的原因是为了重置 currentHook 的值 */</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> comp = React.render(Counter) <span class=\"comment\">// useEffect 0 type hi render 0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 如下 mock 只执行了 render */</span></span><br><span class=\"line\">comp.noop()</span><br><span class=\"line\">comp = React.render(Counter) <span class=\"comment\">// render 0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 如下 mock 重新执行了 useEffect、render */</span></span><br><span class=\"line\">comp.click()</span><br><span class=\"line\">React.render(Counter) <span class=\"comment\">// useEffect 1, render 1</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"相关资源\"><a href=\"#相关资源\" class=\"headerlink\" title=\"相关资源\"></a>相关资源</h3><ul>\n<li><a href=\"https://github.com/rehooks/awesome-react-hooks\" target=\"_blank\" rel=\"noopener\">awesome-react-hooks</a></li>\n<li><a href=\"https://github.com/gragland/usehooks\" target=\"_blank\" rel=\"noopener\">usehooks</a></li>\n<li><a href=\"https://www.netlify.com/blog/2019/03/11/deep-dive-how-do-react-hooks-really-work/\" target=\"_blank\" rel=\"noopener\">deep-dive-how-do-react-hooks-really-work</a></li>\n<li><a href=\"https://overreacted.io/a-complete-guide-to-useeffect/\" target=\"_blank\" rel=\"noopener\">a-complete-guide-to-useeffect</a>: 推荐 Dan 的这篇文章</li>\n<li><a href=\"https://adamrackis.dev/state-and-use-reducer/\" target=\"_blank\" rel=\"noopener\">Hooks, State, Closures, and useReducer</a>: 作为 <a href=\"https://overreacted.io/a-complete-guide-to-useeffect/#decoupling-updates-from-actions\" target=\"_blank\" rel=\"noopener\">decoupling-updates-from-actions</a> 的补充</li>\n<li><a href=\"https://kentcdodds.com/blog/should-i-usestate-or-usereducer/\" target=\"_blank\" rel=\"noopener\">Should I useState or useReducer</a>:</li>\n</ul>\n","categories":["React","Hooks"],"tags":["React"]},{"title":"React Hooks 深入系列 —— 设计模式","url":"/posts/32fb0f08/","content":"<p><img src=\"http://with.muyunyun.cn/34a60f7edb08afaf6d721708ab21b4d7.jpg-muyy\" alt=\"\"></p>\n<p>本文是 <a href=\"https://github.com/MuYunyun/blog/blob/master/React/React_Hooks深入系列.md\" target=\"_blank\" rel=\"noopener\">React Hooks 深入系列</a>的后续。此篇详细介绍了 Hooks 相对 class 的优势所在, 并介绍了相关 api 的设计思想, 同时对 Hooks 如何对齐 class 的生命周期钩子作了阐述。</p>\n<a id=\"more\"></a>\n\n<h3 id=\"React-Logo-与-Hooks\"><a href=\"#React-Logo-与-Hooks\" class=\"headerlink\" title=\"React Logo 与 Hooks\"></a>React Logo 与 Hooks</h3><p><img src=\"http://with.muyunyun.cn/ddbdcec2fc39ba350fc74647f4fad6f5.jpg-300\" alt=\"\"></p>\n<p>React 的 logo 是一个原子图案, 原子组成了物质的表现。类似的, React 就像原子般构成了页面的表现; 而 Hooks 就如夸克, 其更接近 React 本质的样子, 但是直到 4 年后的今天才被真正设计出来。 —— Dan in React Conf(2018)</p>\n<h3 id=\"why-Hooks\"><a href=\"#why-Hooks\" class=\"headerlink\" title=\"why Hooks?\"></a>why Hooks?</h3><p>一: <code>多个组件间逻辑复用</code>: 在 Class 中使用 React 不能将带有 state 的逻辑给单独抽离成 function, 其只能通过嵌套组件的方式来解决多个组件间逻辑复用的问题, 基于嵌套组件的思想存在 <a href=\"https://github.com/MuYunyun/blog/blob/master/React/从0到1实现React/8.HOC探索.md\" target=\"_blank\" rel=\"noopener\">HOC</a> 与 <code>render props</code> 两种设计模式。但是这两种设计模式是否存在缺陷呢?</p>\n<ul>\n<li>嵌套地狱, 当嵌套层级过多后, 数据源的追溯会变得十分困难, 导致定位 bug 不容易; (hoc、render props)</li>\n<li>性能, 需要额外的组件实例存在额外的开销; (hoc、render props)</li>\n<li>命名重复性, 在一个组件中同时使用多个 hoc, 不排除这些 hoc 里的方法存在命名冲突的问题; (hoc)</li>\n</ul>\n<p>二: <code>单个组件中的逻辑复用</code>: Class 中的生命周期 <code>componentDidMount</code>、<code>componentDidUpdate</code> 甚至 <code>componentWillUnMount</code> 中的大多数逻辑基本是类似的, 必须拆散在不同生命周期中维护相同的逻辑对使用者是不友好的, 这样也造成了组件的代码量增加。</p>\n<p>三: Class 的其它一些问题: 在 React 使用 Class 需要书写大量样板, 用户通常会对 Class 中 Constructor 的 bind 以及 this 的使用感到困惑; 当结合 class 与 TypeScript 一起使用时, 需要对 defaultValue 做额外声明处理; 此外 React Team 表示 Class 在机器编译优化方面也不是很理想。</p>\n<h3 id=\"useState-返回的值为什么是数组而非对象\"><a href=\"#useState-返回的值为什么是数组而非对象\" class=\"headerlink\" title=\"useState 返回的值为什么是数组而非对象?\"></a>useState 返回的值为什么是数组而非对象?</h3><p>原因是数组的解构比对象更加方便, 可以观察以下两种数据结构解构的差异。</p>\n<p>返回数组时, 可以直接解构成任意名字。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">[name, setName] = useState(<span class=\"string\">'路飞'</span>)</span><br><span class=\"line\">[age, setAge] = useState(<span class=\"number\">12</span>)</span><br></pre></td></tr></table></figure>\n\n<p>返回对象时, 却需要多一层的命名。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;<span class=\"attr\">value</span>: name, <span class=\"attr\">setValue</span>: setName&#125; = useState(<span class=\"string\">'路飞'</span>)</span><br><span class=\"line\">&#123;<span class=\"attr\">value</span>: name, <span class=\"attr\">setValue</span>: setName&#125; = useState(<span class=\"number\">12</span>)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Hooks-传递的设计\"><a href=\"#Hooks-传递的设计\" class=\"headerlink\" title=\"Hooks 传递的设计\"></a>Hooks 传递的设计</h3><p>Hooks 是否可以设计成在组件中通过函数传参来使用? 比如进行如下调用?</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> SomeContext = <span class=\"built_in\">require</span>(<span class=\"string\">'./SomeContext)</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">function Example(&#123; someProp &#125;, hooks) &#123;</span></span><br><span class=\"line\"><span class=\"string\">  const contextValue = hooks.useContext(SomeContext)</span></span><br><span class=\"line\"><span class=\"string\">  return &lt;div&gt;&#123;someProp&#125;&#123;contextValue&#125;&lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>使用传递的劣势是会出现冗余的传递。(可以联想 context 解决了什么)</p>\n<h3 id=\"Hooks-与-Class-中调用-setState-有不同的表现差异么\"><a href=\"#Hooks-与-Class-中调用-setState-有不同的表现差异么\" class=\"headerlink\" title=\"Hooks 与 Class 中调用 setState 有不同的表现差异么?\"></a>Hooks 与 Class 中调用 setState 有不同的表现差异么?</h3><p>Hooks 中的 setState 与 Class 中最大区别在于 Hooks 不会对多次 setState 进行合并操作。如果要执行合并操作, 可执行如下操作:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">setState(<span class=\"function\"><span class=\"params\">prevState</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123; ...prevState, ...updateValues &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>此外可以对 class 与 Hooks 之间 <code>setState</code> 是异步还是同步的表现进行对比, 可以先对以下 4 种情形 render 输出的个数进行观察分析:</p>\n<h3 id=\"是否能使用-React-Hooks-替代-Redux\"><a href=\"#是否能使用-React-Hooks-替代-Redux\" class=\"headerlink\" title=\"是否能使用 React Hooks 替代 Redux\"></a>是否能使用 React Hooks 替代 Redux</h3><p>在 React 16.8 版本之后, 针对<code>不是特别复杂</code>的业务场景, 可以使用 React 提供的 <code>useContext</code>、<code>useReducer</code> 实现自定义简化版的 redux, 可见 <a href=\"https://github.com/MuYunyun/todoList\" target=\"_blank\" rel=\"noopener\">todoList</a> 中的运用。核心代码如下:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; createContext, useContext, useReducer &#125; <span class=\"keyword\">from</span> <span class=\"string\">\"react\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建 StoreContext</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> StoreContext = createContext()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 构建 Provider 容器层</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> StoreProvider = <span class=\"function\">(<span class=\"params\">&#123;reducer, initialState, children&#125;</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;StoreContext.Provider value=&#123;useReducer(reducer, initialState)&#125;&gt;</span><br><span class=\"line\">      &#123;children&#125;</span><br><span class=\"line\">    &lt;<span class=\"regexp\">/StoreContext.Provider&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  )</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">/</span><span class=\"regexp\">/ 在子组件中调用 useStoreContext, 从而取得 Provider 中的 value</span></span><br><span class=\"line\"><span class=\"regexp\">export const useStoreContext = () =&gt; useContext(StoreContext)</span></span><br></pre></td></tr></table></figure>\n\n<p>但是针对特别复杂的场景目前不建议使用此模式, 因为 context 的机制会有性能问题。具体原因可见 <a href=\"https://github.com/reduxjs/react-redux/issues/1177\" target=\"_blank\" rel=\"noopener\">react-redux v7 回退到订阅的原因</a></p>\n<h3 id=\"Hooks-中如何获取先前的-props-以及-state\"><a href=\"#Hooks-中如何获取先前的-props-以及-state\" class=\"headerlink\" title=\"Hooks 中如何获取先前的 props 以及 state\"></a>Hooks 中如何获取先前的 props 以及 state</h3><p>React 官方在未来很可能会提供一个 <code>usePrevious</code> 的 hooks 来获取之前的 props 以及 state。</p>\n<p><code>usePrevious</code> 的核心思想是用 ref 来存储先前的值。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">usePrevous</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> ref = useRef()</span><br><span class=\"line\">  useEffect(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    ref.current = value</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ref.current</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Hooks-中如何调用实例上的方法\"><a href=\"#Hooks-中如何调用实例上的方法\" class=\"headerlink\" title=\"Hooks 中如何调用实例上的方法\"></a>Hooks 中如何调用实例上的方法</h3><p>在 Hooks 中使用 useRef() 等价于在 Class 中使用 this.something。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* in a function */</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> X = useRef()</span><br><span class=\"line\">X.current <span class=\"comment\">// can read or write</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* in a Class */</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>.X    <span class=\"comment\">// can read or write</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><a href=\"https://reactjs.org/docs/hooks-faq.html#is-there-something-like-instance-variables\" target=\"_blank\" rel=\"noopener\">Is there something like instance variables</a></p>\n</blockquote>\n<h3 id=\"Hooks-中-getDerivedStateFromProps-的替代方案\"><a href=\"#Hooks-中-getDerivedStateFromProps-的替代方案\" class=\"headerlink\" title=\"Hooks 中 getDerivedStateFromProps 的替代方案\"></a>Hooks 中 getDerivedStateFromProps 的替代方案</h3><p>在 <a href=\"https://github.com/MuYunyun/blog/blob/master/React/React暗器百解.md\" target=\"_blank\" rel=\"noopener\">React 暗器百解</a> 中提到了 <code>getDerivedStateFromProps</code> 是一种反模式, 但是极少数情况还是用得到该钩子, Hooks 没有该 api, 那其如何达到 getDerivedStateFromProps 的效果呢?</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ScrollView</span>(<span class=\"params\">&#123;row&#125;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [isScrollingDown, setISScrollingDown] = setState(<span class=\"literal\">false</span>)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [prevRow, setPrevRow] = setState(<span class=\"literal\">null</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 核心是创建一个 prevRow state 与父组件传进来的 row 进行比较</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (row !== prevRow) &#123;</span><br><span class=\"line\">    setISScrollingDown(prevRow !== <span class=\"literal\">null</span> &amp;&amp; row &gt; prevRow)</span><br><span class=\"line\">    setPrevRow(row)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">`Scrolling down <span class=\"subst\">$&#123;isScrollingDown&#125;</span>`</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Hooks-中-forceUpdate-的替代方案\"><a href=\"#Hooks-中-forceUpdate-的替代方案\" class=\"headerlink\" title=\"Hooks 中 forceUpdate 的替代方案\"></a>Hooks 中 forceUpdate 的替代方案</h3><p>可以使用 <code>useReducer</code> 来 hack <code>forceUpdate</code>, 但是尽量避免 forceUpdate 的使用。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> [ignored, forceUpdate] = useReduce(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> x + <span class=\"number\">1</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handleClick</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  forceUpdate()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Hooks-中-shouldComponentUpdate-的替代方案\"><a href=\"#Hooks-中-shouldComponentUpdate-的替代方案\" class=\"headerlink\" title=\"Hooks 中 shouldComponentUpdate 的替代方案\"></a>Hooks 中 shouldComponentUpdate 的替代方案</h3><p>在 Hooks 中可以使用 <code>useMemo</code> 来作为 <code>shouldComponentUpdate</code> 的替代方案, 但 <code>useMemo</code> 只对 props 进行浅比较。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">React.useMemo(<span class=\"function\">(<span class=\"params\">props</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// your component</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"useMemo-与-useCallback-的区别\"><a href=\"#useMemo-与-useCallback-的区别\" class=\"headerlink\" title=\"useMemo 与 useCallback 的区别\"></a>useMemo 与 useCallback 的区别</h4><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">useMemo(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">component</span> /&gt;</span></span>) 等价于 useCallback(<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">component</span> /&gt;</span></span>)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>useCallback: 一般用于缓存函数</li>\n<li>useMemo: 一般用于缓存组件</li>\n</ul>\n<h4 id=\"依赖列表中移除函数是否是安全的\"><a href=\"#依赖列表中移除函数是否是安全的\" class=\"headerlink\" title=\"依赖列表中移除函数是否是安全的?\"></a>依赖列表中移除函数是否是安全的?</h4><p>通常来说依赖列表中移除函数是不安全的。观察如下 demo</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123; useState, useEffect &#125; = React</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Example</span>(<span class=\"params\">&#123; someProp &#125;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doSomething</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(someProp) <span class=\"comment\">// 这里只输出 1, 点击按钮的 2 并没有输出。</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  useEffect(</span><br><span class=\"line\">    () =&gt; &#123;</span><br><span class=\"line\">      doSomething()</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    [] <span class=\"comment\">// 🔴 这是不安全的, 因为在 doSomething 函数中使用了 someProps 属性</span></span><br><span class=\"line\">  )</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>example<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [value, setValue] = useState(<span class=\"number\">1</span>)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;&gt;</span><br><span class=\"line\">      &lt;Example someProp=&#123;value&#125; /&gt;</span><br><span class=\"line\">      &lt;Button onClick=&#123;() =&gt; setValue(<span class=\"number\">2</span>)&#125;&gt;button&lt;<span class=\"regexp\">/Button&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;/</span>&gt;</span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在该 demo 中, 点击 button 按钮, 并没有打印出 2。解决上述问题有两种方法。</p>\n<p>方法一: 将函数放入 <code>useEffect</code> 中, 同时将相关属性放入依赖项中。因为在依赖中改变的相关属性一目了然, 所以这也是首推的做法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Example</span>(<span class=\"params\">&#123; someProp &#125;</span>) </span>&#123;</span><br><span class=\"line\">  useEffect(</span><br><span class=\"line\">    () =&gt; &#123;</span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doSomething</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(someProp)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      doSomething()</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    [someProps] <span class=\"comment\">// 相关属性改变一目了然</span></span><br><span class=\"line\">  )</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>example<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>方法二: 把函数加入依赖列表中</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Example</span>(<span class=\"params\">&#123; someProp &#125;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doSomething</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(someProp)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  useEffect(</span><br><span class=\"line\">    () =&gt; &#123;</span><br><span class=\"line\">      doSomething()</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    [doSomething]</span><br><span class=\"line\">  )</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>example<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>方案二基本上不会单独使用, 它一般结合 <code>useCallback</code> 一起使用来处理某些函数计算量较大的函数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Example</span>(<span class=\"params\">&#123; someProp &#125;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> doSomething = useCallback(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(someProp)</span><br><span class=\"line\">  &#125;, [someProp])</span><br><span class=\"line\"></span><br><span class=\"line\">  useEffect(</span><br><span class=\"line\">    doSomething(),</span><br><span class=\"line\">    [doSomething]</span><br><span class=\"line\">  )</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>example<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"如何避免重复创建昂贵的对象\"><a href=\"#如何避免重复创建昂贵的对象\" class=\"headerlink\" title=\"如何避免重复创建昂贵的对象\"></a>如何避免重复创建昂贵的对象</h4><ul>\n<li>方法一: 使用 <code>useState</code> 的懒初始化, 用法如下</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> [value, setValue] = useState(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> createExpensiveObj)</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>见 <a href=\"https://reactjs.org/docs/hooks-reference.html#lazy-initial-state\" target=\"_blank\" rel=\"noopener\">lazy-initial-state</a>;</p>\n</blockquote>\n<ul>\n<li>方法二: 使用自定义 useRef 函数</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Image</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> ref = useRef(<span class=\"literal\">null</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getExpensiveObj</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ref.current === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      ref.current = ExpensiveObj</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ref.current</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// if need ExpensiveObj, call getExpensiveObj()</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"相关资料\"><a href=\"#相关资料\" class=\"headerlink\" title=\"相关资料\"></a>相关资料</h3><ul>\n<li><a href=\"https://github.com/reactjs/rfcs/pull/68#issuecomment-439314884\" target=\"_blank\" rel=\"noopener\">Hooks RFCS</a></li>\n<li><a href=\"https://reactjs.org/docs/hooks-faq.html\" target=\"_blank\" rel=\"noopener\">Hooks FAQ</a></li>\n<li><a href=\"https://medium.com/@dan_abramov/making-sense-of-react-hooks-fdbde8803889\" target=\"_blank\" rel=\"noopener\">Making Sense of React Hooks</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/68477600\" target=\"_blank\" rel=\"noopener\">Vue Function-based API RFC</a></li>\n</ul>\n","categories":["React"],"tags":["React","Hooks"]},{"title":"React 在服务端渲染的实现","url":"/posts/2d678a6/","content":"<p><img src=\"http://with.muyunyun.cn/f82f7765b1171459d9fa593df836c658.jpg-muyy\" alt=\"\"></p>\n<blockquote>\n<ul>\n<li>原文地址：<a href=\"https://css-tricks.com/server-side-react-rendering/\" target=\"_blank\" rel=\"noopener\">Server-Side React Rendering</a></li>\n</ul>\n</blockquote>\n<p>React是最受欢迎的客户端 JavaScript 框架，但你知道吗(可以试试)，你可以使用 React 在服务器端进行渲染？</p>\n<a id=\"more\"></a>\n\n<h2 id=\"React-在服务端渲染的实现\"><a href=\"#React-在服务端渲染的实现\" class=\"headerlink\" title=\"React 在服务端渲染的实现\"></a>React 在服务端渲染的实现</h2><p>假设你已经在客户端使用 React 构建了一个事件列表 app。该应用程序使用了您最喜欢的服务器端工具构建的API。几周后，用户告诉您，他们的页面没有显示在 Google 上，发布到 Facebook 时也显示不出来。 这些问题似乎是可以解决的，对吧？</p>\n<p>您会发现，要解决这个问题，需要在初始加载时从服务器渲染 React 页面，以便来自搜索引擎和社交媒体网站的爬虫工具可以读取您的标记。有证据表明，Google 有时会执行 javascript 程序并且对生成的内容进行索引，但并不总是的。因此，如果您希望确保与其他服​​务（如Facebook，Twitter）有良好的SEO兼容性，那么始终建议使用服务器端渲染。</p>\n<p>在本教程中，我们将逐步介绍服务器端的呈现示例。包括围绕与API交流的React应用程序的共同路障。<br>在本教程中，我们将逐步向您介绍服务器端的渲染示例。包括围绕着 APIS 交流一些在服务端渲染 React 应用程序的共同障碍。</p>\n<h2 id=\"服务端渲染的优势\"><a href=\"#服务端渲染的优势\" class=\"headerlink\" title=\"服务端渲染的优势\"></a>服务端渲染的优势</h2><p>可能您的团队谈论到服务端渲染的好处是首先会想到 SEO，但这并不是唯一的潜在好处。</p>\n<p>更大的好处如下：服务器端渲染能更快地显示页面。使用服务器端渲染，您的服务器对浏览器进行响应是在您的 HTML 页面可以渲染的时候，因此浏览器可以不用等待所有的 JavaScript 被下载和执行就可以开始渲染。当浏览器下载并执行页面所需的 JavaScript 和其他资源时，不会出现 “白屏” 现象，而 “白屏” 这是在完全有客户端呈现的 React 网站中可能发生的情况。</p>\n<h2 id=\"入门\"><a href=\"#入门\" class=\"headerlink\" title=\"入门\"></a>入门</h2><p>接下来让我们来看看如何将服务器端渲染添加到一个基本的客户端渲染的使用Babel和Webpack的React应用程序中。我们的应用程序将增加从第三方 API 获取数据的复杂性。我们在GitHub上提供了<a href=\"https://github.com/ButterCMS/react-ssr-example/releases/tag/starter-code\" target=\"_blank\" rel=\"noopener\">相关代码</a>，您可以在其中看到完整的示例。</p>\n<p>提供的代码中只有一个 React 组件，`hello.js`，这个文件将向 <a href=\"https://buttercms.com/\" target=\"_blank\" rel=\"noopener\">ButterCMS</a> 发出异步请求，并渲染返回的 JSON 列表的博文。ButterCMS 是一个基于API的博客引擎，可供个人使用，因此它非常适合测试现实生活中的用例。启动代码中连接着一个 API token，如果你想使用你自己的 API token 可以<a href=\"https://buttercms.com/home/\" target=\"_blank\" rel=\"noopener\">使用你的 GitHub 账号登入 ButterCMS</a>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> Butter <span class=\"keyword\">from</span> <span class=\"string\">'buttercms'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> butter = Butter(<span class=\"string\">'b60a008584313ed21803780bc9208557b3b49fbb'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> Hello = React.createClass(&#123;</span><br><span class=\"line\">  getInitialState: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;<span class=\"attr\">loaded</span>: <span class=\"literal\">false</span>&#125;;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  componentWillMount: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    butter.post.list().then(<span class=\"function\">(<span class=\"params\">resp</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">        loaded: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        resp: resp.data</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  render: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.state.loaded) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">          &#123;<span class=\"keyword\">this</span>.state.resp.data.map(<span class=\"function\">(<span class=\"params\">post</span>) =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (</span><br><span class=\"line\">              &lt;div key=&#123;post.slug&#125;&gt;&#123;post.title&#125;&lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">            )</span></span><br><span class=\"line\"><span class=\"regexp\">          &#125;)&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;/</span>div&gt;</span><br><span class=\"line\">      );</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>Loading...<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> Hello;</span><br></pre></td></tr></table></figure>\n\n<p>启动器代码中包含以下内容：</p>\n<ul>\n<li>package.json - 依赖项</li>\n<li>Webpack 和 Babel 配置</li>\n<li>index.html - app 的 HTML 文件</li>\n<li>index.js - 加载 React 并渲染 Hello 组件</li>\n</ul>\n<p>要使应用运行，请先克隆资源库：</p>\n<figure class=\"highlight gams\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">git</span></span> clone ...</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">cd</span></span> ..</span><br></pre></td></tr></table></figure>\n\n<p>安装依赖:</p>\n<figure class=\"highlight cmake\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm <span class=\"keyword\">install</span></span><br></pre></td></tr></table></figure>\n\n<p>然后启动服务器:</p>\n<figure class=\"highlight dockerfile\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm <span class=\"keyword\">run</span><span class=\"bash\"> start</span></span><br></pre></td></tr></table></figure>\n\n<p>浏览器输入 <a href=\"http://localhost:8000\" target=\"_blank\" rel=\"noopener\">http://localhost:8000</a> 可以看到这个 app: (这里译者进行补充，package.json 里的 start 命令改为如下：<code>&quot;start&quot;: webpack-dev-server --watch</code>)</p>\n<p><img src=\"https://res.cloudinary.com/css-tricks/image/upload/c_scale,w_1000,f_auto,q_auto/v1497358286/localhost_r84tot.png\" alt=\"\"></p>\n<p>如果您查看渲染页面的源代码，您将看到发送到浏览器的标记只是一个到 JavaScript 文件的链接。这意味着页面的内容不能保证被搜索引擎和社交媒体平台抓取:</p>\n<p><img src=\"https://res.cloudinary.com/css-tricks/image/upload/c_scale,w_1000,f_auto,q_auto/v1497358332/some-html_mrmpfj.png\" alt=\"\"></p>\n<h2 id=\"增加服务器端渲染\"><a href=\"#增加服务器端渲染\" class=\"headerlink\" title=\"增加服务器端渲染\"></a>增加服务器端渲染</h2><p>接下来，我们将实现服务器端渲染，以便将完全生成的HTML发送到浏览器。如果要同时查看所有更改，请查看<a href=\"https://github.com/ButterCMS/react-ssr-example/commit/525c625b0f65489050983ed03b52bb7770ce6b7a\" target=\"_blank\" rel=\"noopener\">GitHub上的差异</a>。</p>\n<p>开始前，让我们安装 Express，一个 Node.js 的服务器端应用程序框架：</p>\n<figure class=\"highlight maxima\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install <span class=\"built_in\">express</span> --<span class=\"built_in\">save</span></span><br></pre></td></tr></table></figure>\n\n<p>我们要创建一个渲染我们的 React 组件的服务器：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> express <span class=\"keyword\">from</span> <span class=\"string\">'express'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> fs <span class=\"keyword\">from</span> <span class=\"string\">'fs'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> path <span class=\"keyword\">from</span> <span class=\"string\">'path'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> ReactDOMServer <span class=\"keyword\">from</span> <span class=\"string\">'react-dom/server'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> Hello <span class=\"keyword\">from</span> <span class=\"string\">'./Hello.js'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handleRender</span>(<span class=\"params\">req, res</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 把 Hello 组件渲染成 HTML 字符串</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> html = ReactDOMServer.renderToString(<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Hello</span> /&gt;</span></span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 加载 index.html 的内容</span></span><br><span class=\"line\">  fs.readFile(<span class=\"string\">'./index.html'</span>, <span class=\"string\">'utf8'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, data</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err) <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 把渲染后的 React HTML 插入到 div 中</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"built_in\">document</span> = data.replace(<span class=\"regexp\">/&lt;div id=\"app\"&gt;&lt;\\/div&gt;/</span>, <span class=\"string\">`&lt;div id=\"app\"&gt;<span class=\"subst\">$&#123;html&#125;</span>&lt;/div&gt;`</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 把响应传回给客户端</span></span><br><span class=\"line\">    res.send(<span class=\"built_in\">document</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> app = express();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 服务器使用 static 中间件构建 build 路径</span></span><br><span class=\"line\">app.use(<span class=\"string\">'/build'</span>, express.static(path.join(__dirname, <span class=\"string\">'build'</span>)));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用我们的 handleRender 中间件处理服务端请求</span></span><br><span class=\"line\">app.get(<span class=\"string\">'*'</span>, handleRender);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 启动服务器</span></span><br><span class=\"line\">app.listen(<span class=\"number\">3000</span>);</span><br></pre></td></tr></table></figure>\n\n<p>让我们分解下程序看看发生了什么事情…</p>\n<p><code>handleRender</code> 函数处理所有请求。在文件顶部导入的 <a href=\"https://facebook.github.io/react/docs/react-dom-server.html\" target=\"_blank\" rel=\"noopener\">ReactDOMServer 类</a>提供了将 React 节点渲染成其初始 HTML 的 renderToString() 方法</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">ReactDOMServer.renderToString(<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Hello</span> /&gt;</span></span>);</span><br></pre></td></tr></table></figure>\n\n<p>这将返回 Hello 组件的 HTML ，我们将其注入到 index.html 的 HTML 中，从而生成服务器上页面的完整 HTML 。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"built_in\">document</span> = data.replace(<span class=\"regexp\">/&lt;div id=\"app\"&gt;&lt;\\/div&gt;/</span>,<span class=\"string\">`&lt;div id=\"app\"&gt;<span class=\"subst\">$&#123;html&#125;</span>&lt;/div&gt;`</span>);</span><br></pre></td></tr></table></figure>\n\n<p>要启动服务器，请更新 `package.json` 中的起始脚本，然后运行 <code>npm run start</code> :</p>\n<figure class=\"highlight 1c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"scripts\"</span>: &#123;</span><br><span class=\"line\">  <span class=\"string\">\"start\"</span>: <span class=\"string\">\"webpack &amp;&amp; babel-node server.js\"</span></span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n\n<p>浏览 <code>http://localhost:3000</code> 查看应用程序。瞧！您的页面现在正在从服务器渲染出来了。但是有个问题，<br>如果您在浏览器中查看页面源码，您会注意到博客文章仍未包含在回复中。这是怎么回事？如果我们在Chrome中打开网络标签，我们会看到客户端上发生API请求。</p>\n<p><img src=\"https://res.cloudinary.com/css-tricks/image/upload/c_scale,w_1000,f_auto,q_auto/v1497358447/devtools_qx5y1o.png\" alt=\"\"></p>\n<p>虽然我们在服务器上渲染了 React 组件，但是 API 请求在 componentWillMount 中异步生成，并且组件在请求完成之前渲染。所以即使我们已经在服务器上完成渲染，但我们只是完成了部分。事实上，<a href=\"https://github.com/facebook/react/issues/1739\" target=\"_blank\" rel=\"noopener\">React repo 有一个 issue</a>，超过 100 条评论讨论了这个问题和各种解决方法。</p>\n<h2 id=\"在渲染之前获取数据\"><a href=\"#在渲染之前获取数据\" class=\"headerlink\" title=\"在渲染之前获取数据\"></a>在渲染之前获取数据</h2><p>要解决这个问题，我们需要在渲染 Hello 组件之前确保 API 请求完成。这意味着要使 API 请求跳出 React 的组件渲染循环，并在渲染组件之前获取数据。我们将逐步介绍这一步，但您可以在<a href=\"https://github.com/ButterCMS/react-ssr-example/commit/5fdd453e31ab08dfdc8b44261696d4ed89fbb719\" target=\"_blank\" rel=\"noopener\">GitHub上查看完整的差异</a>。</p>\n<p>要在渲染之前获取数据，我们需安装 <a href=\"https://github.com/RickWong/react-transmit\" target=\"_blank\" rel=\"noopener\">react-transmit</a>：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm <span class=\"keyword\">install</span> react-transmit <span class=\"comment\">--save</span></span><br></pre></td></tr></table></figure>\n\n<p>React Transmit 给了我们优雅的包装器组件（通常称为“高阶组件”），用于获取在客户端和服务器上工作的数据。</p>\n<p>这是我们使用 react-transmit 后的组件的代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> Butter <span class=\"keyword\">from</span> <span class=\"string\">'buttercms'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Transmit <span class=\"keyword\">from</span> <span class=\"string\">'react-transmit'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> butter = Butter(<span class=\"string\">'b60a008584313ed21803780bc9208557b3b49fbb'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> Hello = React.createClass(&#123;</span><br><span class=\"line\">  render: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.props.posts) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">          &#123;<span class=\"keyword\">this</span>.props.posts.data.map(<span class=\"function\">(<span class=\"params\">post</span>) =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (</span><br><span class=\"line\">              &lt;div key=&#123;post.slug&#125;&gt;&#123;post.title&#125;&lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">            )</span></span><br><span class=\"line\"><span class=\"regexp\">          &#125;)&#125;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;/</span>div&gt;</span><br><span class=\"line\">      );</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>Loading...<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> Transmit.createContainer(Hello, &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 必须设定 initiallVariables 和 ftagments ,否则渲染时会报错</span></span><br><span class=\"line\">  initialVariables: &#123;&#125;,</span><br><span class=\"line\">  <span class=\"comment\">// 定义的方法名将成为 Transmit props 的名称</span></span><br><span class=\"line\">  fragments: &#123;</span><br><span class=\"line\">    posts() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> butter.post.list().then(<span class=\"function\">(<span class=\"params\">resp</span>) =&gt;</span> resp.data);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>我们已经使用 <code>Transmit.createContainer</code> 将我们的组件包装在一个高级组件中，该组件可以用来获取数据。我们在 React 组件中删除了生命周期方法，因为无需两次获取数据。同时我们把 render 方法中的 state 替换成 props，因为 React Transmit 将数据作为 props 传递给组件。</p>\n<p>为了确保服务器在渲染之前获取数据，我们导入 Transmit 并使用 <code>Transmit.renderToString</code> 而不是 <code>ReactDOM.renderToString</code> 方法</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> express <span class=\"keyword\">from</span> <span class=\"string\">'express'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> fs <span class=\"keyword\">from</span> <span class=\"string\">'fs'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> path <span class=\"keyword\">from</span> <span class=\"string\">'path'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> ReactDOMServer <span class=\"keyword\">from</span> <span class=\"string\">'react-dom/server'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> Hello <span class=\"keyword\">from</span> <span class=\"string\">'./Hello.js'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> Transmit <span class=\"keyword\">from</span> <span class=\"string\">'react-transmit'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handleRender</span>(<span class=\"params\">req, res</span>) </span>&#123;</span><br><span class=\"line\">  Transmit.renderToString(Hello).then(<span class=\"function\">(<span class=\"params\">&#123;reactString, reactData&#125;</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    fs.readFile(<span class=\"string\">'./index.html'</span>, <span class=\"string\">'utf8'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, data</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (err) <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">const</span> <span class=\"built_in\">document</span> = data.replace(<span class=\"regexp\">/&lt;div id=\"app\"&gt;&lt;\\/div&gt;/</span>, <span class=\"string\">`&lt;div id=\"app\"&gt;<span class=\"subst\">$&#123;reactString&#125;</span>&lt;/div&gt;`</span>);</span><br><span class=\"line\">      <span class=\"keyword\">const</span> output = Transmit.injectIntoMarkup(<span class=\"built_in\">document</span>, reactData, [<span class=\"string\">'/build/client.js'</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">      res.send(<span class=\"built_in\">document</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> app = express();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 服务器使用 static 中间件构建 build 路径</span></span><br><span class=\"line\">app.use(<span class=\"string\">'/build'</span>, express.static(path.join(__dirname, <span class=\"string\">'build'</span>)));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用我们的 handleRender 中间件处理服务端请求</span></span><br><span class=\"line\">app.get(<span class=\"string\">'*'</span>, handleRender);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 启动服务器</span></span><br><span class=\"line\">app.listen(<span class=\"number\">3000</span>);</span><br></pre></td></tr></table></figure>\n\n<p>重新启动服务器浏览到 <code>http://localhost：3000</code>。查看页面源代码，您将看到该页面现在完全呈现在服务器上！</p>\n<p><img src=\"https://res.cloudinary.com/css-tricks/image/upload/c_scale,w_1000,f_auto,q_auto/v1497358548/rendered-react_t5neam.png\" alt=\"\"></p>\n<h2 id=\"更进一步\"><a href=\"#更进一步\" class=\"headerlink\" title=\"更进一步\"></a>更进一步</h2><p>我们做到了！在服务器上使用 React 可能很棘手，尤其是从 API 获取数据时。幸运的是，React社区正在蓬勃发展，并创造了许多有用的工具。如果您对构建在客户端和服务器上渲染的大型 React 应用程序的框架感兴趣，请查看 Walmart Labs 的 <a href=\"https://github.com/electrode-io/electrode\" target=\"_blank\" rel=\"noopener\">Electrode</a> 或 <a href=\"https://github.com/zeit/next.js\" target=\"_blank\" rel=\"noopener\">Next.js</a>。或者如果要在 Ruby 中渲染 React ，请查看 AirBnB 的 <a href=\"https://github.com/airbnb/hypernova\" target=\"_blank\" rel=\"noopener\">Hypernova</a> 。</p>\n","categories":["React"],"tags":["React","SEO"]},{"title":"深度理解 React Suspense","url":"/posts/44b01006/","content":"<p><img src=\"http://with.muyunyun.cn/7e992292f9fac2209d9e74499cea1840.jpg-muyy\" alt=\"\"></p>\n<p>本文介绍与 <code>Suspense</code> 在三种情景下使用方法，并结合源码进行相应解析。欢迎关注<a href=\"https://github.com/MuYunyun/blog\" target=\"_blank\" rel=\"noopener\">个人博客</a>。</p>\n<a id=\"more\"></a>\n\n<h3 id=\"Code-Spliting\"><a href=\"#Code-Spliting\" class=\"headerlink\" title=\"Code Spliting\"></a>Code Spliting</h3><p>在 16.6 版本之前，<code>code-spliting</code> 通常是由第三方库来完成的，比如 <a href=\"https://github.com/jamiebuilds/react-loadable\" target=\"_blank\" rel=\"noopener\">react-loadble</a>(核心思路为: 高阶组件 + webpack dynamic import), 在 16.6 版本中提供了 <code>Suspense</code> 和 <code>lazy</code> 这两个钩子, 因此在之后的版本中便可以使用其来实现 <code>Code Spliting</code>。</p>\n<blockquote>\n<p>目前阶段, 服务端渲染中的 <code>code-spliting</code> 还是得使用 <code>react-loadable</code>, 可查阅 <a href=\"https://reactjs.org/docs/code-splitting.html#reactlazy\" target=\"_blank\" rel=\"noopener\">React.lazy</a>, 暂时先不探讨原因。</p>\n</blockquote>\n<p><code>Code Spliting</code> 在 <code>React</code> 中的使用方法是在 <code>Suspense</code> 组件中使用 <code>&lt;LazyComponent&gt;</code> 组件:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; Suspense, lazy &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> DemoA = lazy(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"keyword\">import</span>(<span class=\"string\">'./demo/a'</span>))</span><br><span class=\"line\"><span class=\"keyword\">const</span> DemoB = lazy(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"keyword\">import</span>(<span class=\"string\">'./demo/b'</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;Suspense&gt;</span><br><span class=\"line\">  &lt;NavLink to=<span class=\"string\">\"/demoA\"</span>&gt;DemoA&lt;<span class=\"regexp\">/NavLink&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  &lt;NavLink to=\"/</span>demoB<span class=\"string\">\"&gt;DemoB&lt;/NavLink&gt;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">  &lt;Router&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;DemoA path=\"</span>/demoA<span class=\"string\">\" /&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;DemoB path=\"</span>/demoB<span class=\"string\">\" /&gt;</span></span><br><span class=\"line\"><span class=\"string\">  &lt;/Router&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;/Suspense&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>源码中 <code>lazy</code> 将传入的参数封装成一个 <code>LazyComponent</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">lazy</span>(<span class=\"params\">ctor</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    $$<span class=\"keyword\">typeof</span>: REACT_LAZY_TYPE, <span class=\"comment\">// 相关类型</span></span><br><span class=\"line\">    _ctor: ctor,</span><br><span class=\"line\">    _status: <span class=\"number\">-1</span>,   <span class=\"comment\">// dynamic import 的状态</span></span><br><span class=\"line\">    _result: <span class=\"literal\">null</span>, <span class=\"comment\">// 存放加载文件的资源</span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>观察 <a href=\"https://github.com/MuYunyun/react/blob/29b7b775f2ecf878eaf605be959d959030598b07/packages/react-reconciler/src/ReactFiberLazyComponent.js#L30-L87\" target=\"_blank\" rel=\"noopener\">readLazyComponentType</a> 后可以发现 <code>dynamic import</code> 本身类似 <code>Promise</code> 的执行机制, 也具有 <code>Pending</code>、<code>Resolved</code>、<code>Rejected</code> 三种状态, 这就比较好理解为什么 <code>LazyComponent</code> 组件需要放在 <code>Suspense</code> 中执行了(<code>Suspense</code> 中提供了相关的捕获机制, 下文会进行模拟实现`), 相关源码如下:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">readLazyComponentType</span>(<span class=\"params\">lazyComponent</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> status = lazyComponent._status;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> result = lazyComponent._result;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (status) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> Resolved: &#123; <span class=\"comment\">// Resolve 时，呈现相应资源</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> Component = result;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> Component;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> Rejected: &#123; <span class=\"comment\">// Rejected 时，throw 相应 error</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> error = result;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> error;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> Pending: &#123;  <span class=\"comment\">// Pending 时, throw 相应 thenable</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> thenable = result;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> thenable;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">default</span>: &#123; <span class=\"comment\">// 第一次执行走这里</span></span><br><span class=\"line\">      lazyComponent._status = Pending;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> ctor = lazyComponent._ctor;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> thenable = ctor(); <span class=\"comment\">// 可以看到和 Promise 类似的机制</span></span><br><span class=\"line\">      thenable.then(</span><br><span class=\"line\">        moduleObject =&gt; &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (lazyComponent._status === Pending) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> defaultExport = moduleObject.default;</span><br><span class=\"line\">            lazyComponent._status = Resolved;</span><br><span class=\"line\">            lazyComponent._result = defaultExport;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        error =&gt; &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (lazyComponent._status === Pending) &#123;</span><br><span class=\"line\">            lazyComponent._status = Rejected;</span><br><span class=\"line\">            lazyComponent._result = error;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">      );</span><br><span class=\"line\">      <span class=\"comment\">// Handle synchronous thenables.</span></span><br><span class=\"line\">      <span class=\"keyword\">switch</span> (lazyComponent._status) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> Resolved:</span><br><span class=\"line\">          <span class=\"keyword\">return</span> lazyComponent._result;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> Rejected:</span><br><span class=\"line\">          <span class=\"keyword\">throw</span> lazyComponent._result;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      lazyComponent._result = thenable;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> thenable;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Async-Data-Fetching\"><a href=\"#Async-Data-Fetching\" class=\"headerlink\" title=\"Async Data Fetching\"></a>Async Data Fetching</h3><p>为了解决获取的数据在不同时刻进行展现的问题(在 <a href=\"https://github.com/demos-platform/suspenseDemo\" target=\"_blank\" rel=\"noopener\">suspenseDemo</a> 中有相应演示), <code>Suspense</code> 给出了解决方案。</p>\n<p>下面放两段代码，可以从中直观地感受在 <code>Suspense</code> 中使用 <code>Async Data Fetching</code> 带来的便利。</p>\n<ul>\n<li>一般进行数据获取的代码如下:</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  state = &#123;</span><br><span class=\"line\">    data: <span class=\"literal\">null</span>,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  componentDidMount() &#123;</span><br><span class=\"line\">    fetchAPI(<span class=\"string\">`/api/demo/<span class=\"subst\">$&#123;<span class=\"keyword\">this</span>.props.id&#125;</span>`</span>).then(<span class=\"function\">(<span class=\"params\">data</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.setState(&#123; data &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; data &#125; = <span class=\"keyword\">this</span>.state;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (data == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Spinner</span> /&gt;</span></span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; name &#125; = data;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div&gt;&#123;name&#125;&lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    );</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>在 <code>Suspense</code> 中进行数据获取的代码如下:</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> resource = unstable_createResource(<span class=\"function\">(<span class=\"params\">id</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> fetchAPI(<span class=\"string\">`/api/demo`</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Demo</span> </span>&#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> data = resource.read(<span class=\"keyword\">this</span>.props.id)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; name &#125; = data;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div&gt;&#123;name&#125;&lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    );</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>可以看到在 <code>Suspense</code> 中进行数据获取的代码量相比正常的进行数据获取的代码少了将近一半！少了哪些地方呢?</p>\n<ul>\n<li>减少了 <code>loading</code> 状态的维护(在最外层的 Suspense 中统一维护子组件的 loading)</li>\n<li>减少了不必要的生命周期的书写</li>\n</ul>\n<h3 id=\"总结-如何在-Suspense-中使用-Data-Fetching\"><a href=\"#总结-如何在-Suspense-中使用-Data-Fetching\" class=\"headerlink\" title=\"总结: 如何在 Suspense 中使用 Data Fetching\"></a>总结: 如何在 Suspense 中使用 Data Fetching</h3><p>当前 <code>Suspense</code> 的使用分为三个部分:</p>\n<p>第一步: 用 <code>Suspens</code> 组件包裹子组件</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; Suspense &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span></span><br><span class=\"line\"></span><br><span class=\"line\">&lt;Suspense fallback=&#123;&lt;Loading /&gt;&#125;&gt;</span><br><span class=\"line\">  &lt;ChildComponent&gt;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/Suspense&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>第二步: 在子组件中使用 <code>unstable_createResource</code>:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; unstable_createResource &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-cache'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> resource = unstable_createResource(<span class=\"function\">(<span class=\"params\">id</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> fetch(<span class=\"string\">`/demo/<span class=\"subst\">$&#123;id&#125;</span>`</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>第三步: 在 <code>Component</code> 中使用第一步创建的 <code>resource</code>:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> data = resource.read(<span class=\"string\">'demo'</span>)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"相关思路解读\"><a href=\"#相关思路解读\" class=\"headerlink\" title=\"相关思路解读\"></a>相关思路解读</h3><p>来看下源码中 <code>unstable_createResource</code> 的部分会比较清晰:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">unstable_createResource</span>(<span class=\"params\">fetch, maybeHashInput</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> resource = &#123;</span><br><span class=\"line\">    read(input) &#123;</span><br><span class=\"line\">      ...</span><br><span class=\"line\">      <span class=\"keyword\">const</span> result = accessResult(resource, fetch, input, key);</span><br><span class=\"line\">      <span class=\"keyword\">switch</span> (result.status) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> Pending: &#123;</span><br><span class=\"line\">          <span class=\"keyword\">const</span> suspender = result.value;</span><br><span class=\"line\">          <span class=\"keyword\">throw</span> suspender;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> Resolved: &#123;</span><br><span class=\"line\">          <span class=\"keyword\">const</span> value = result.value;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> Rejected: &#123;</span><br><span class=\"line\">          <span class=\"keyword\">const</span> error = result.value;</span><br><span class=\"line\">          <span class=\"keyword\">throw</span> error;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">default</span>:</span><br><span class=\"line\">          <span class=\"comment\">// Should be unreachable</span></span><br><span class=\"line\">          <span class=\"keyword\">return</span> (<span class=\"literal\">undefined</span>: any);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> resource;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>结合该部分源码, 进行如下推测:</p>\n<ol>\n<li>第一次请求没有缓存, 子组件 <code>throw</code> 一个 <code>thenable</code> 对象, <code>Suspense</code> 组件内的 <code>componentDidCatch</code> 捕获之, 此时展示 <code>Loading</code> 组件;</li>\n<li>当 <code>Promise</code> 态的对象变为完成态后, 页面刷新此时 <code>resource.read()</code> 获取到相应完成态的值;</li>\n<li>之后如果相同参数的请求, 则走 <code>LRU</code> 缓存算法, 跳过 <code>Loading</code> 组件返回结果(缓存算法见后记);</li>\n</ol>\n<p>官方作者是说法如下:</p>\n<p><img src=\"http://with.muyunyun.cn/22849313e0b8b19e833df9a9a59a8546.jpg-400\" alt=\"\"></p>\n<p>所以说法大致相同, 下面实现一个简单版的 <code>Suspense</code>:</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Suspense</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  state = &#123;</span><br><span class=\"line\">    promise: <span class=\"literal\">null</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  componentDidCatch(e) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (e <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Promise</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">        promise: e</span><br><span class=\"line\">      &#125;, () =&gt; &#123;</span><br><span class=\"line\">        e.then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">            promise: <span class=\"literal\">null</span></span><br><span class=\"line\">          &#125;)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; fallback, children &#125; = <span class=\"keyword\">this</span>.props</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; promise &#125; = <span class=\"keyword\">this</span>.state</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">      &#123; promise ? fallback : children &#125;</span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;/&gt;</span></span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>进行如下调用</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;Suspense fallback=&#123;&lt;div&gt;loading...&lt;<span class=\"regexp\">/div&gt;&#125;&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  &lt;PromiseThrower /</span>&gt;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/Suspense&gt;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">let cache = \"\";</span></span><br><span class=\"line\"><span class=\"regexp\">let returnData = cache;</span></span><br><span class=\"line\"><span class=\"regexp\">const fetch = () =&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  new Promise(resolve =&gt; &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    setTimeout(() =&gt; &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">      resolve(\"数据加载完毕\");</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;, 2000);</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;);</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">class PromiseThrower extends React.Component &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  getData = () =&gt; &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    const getData = fetch();</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">    getData.then(data =&gt; &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">      returnData = data;</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;);</span></span><br><span class=\"line\"><span class=\"regexp\">    if (returnData === cache) &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">      throw getData;</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">    return returnData;</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">  render() &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    return &lt;&gt;&#123;this.getData()&#125;&lt;/</span>&gt;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"http://with.muyunyun.cn/90586c1edf33c7d143f2a3ec59667ab4.gif\" alt=\"\"></p>\n<p>效果调试可以点击<a href=\"https://codesandbox.io/s/1zy82mm0j4\" target=\"_blank\" rel=\"noopener\">这里</a>, 在 <code>16.6</code> 版本之后, <code>componentDidCatch</code> 只能捕获 <code>commit phase</code> 的异常。所以在 <code>16.6</code> 版本之后实现的 <code>&lt;PromiseThrower&gt;</code> 又有一些差异(即将 <code>throw thenable</code> 移到 <code>componentDidMount</code> 中进行)。</p>\n<h3 id=\"ConcurrentMode-Suspense\"><a href=\"#ConcurrentMode-Suspense\" class=\"headerlink\" title=\"ConcurrentMode + Suspense\"></a>ConcurrentMode + Suspense</h3><p>当网速足够快, 数据立马就获取到了，此时页面存在的 <code>Loading</code> 按钮就显得有些多余了。(在 <a href=\"https://github.com/demos-platform/suspenseDemo\" target=\"_blank\" rel=\"noopener\">suspenseDemo</a> 中有相应演示), <code>Suspense</code> 在 <code>Concurrent Mode</code> 下给出了相应的解决方案, 其提供了 <code>maxDuration</code> 参数。用法如下:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;Suspense maxDuration=&#123;<span class=\"number\">500</span>&#125; fallback=&#123;&lt;Loading /&gt;&#125;&gt;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&lt;<span class=\"regexp\">/Suspense&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>该 Demo 的效果为当获取数据的时间大于(是否包含等于还没确认) 500 毫秒, 显示自定义的 <code>&lt;Loading /&gt;</code> 组件, 当获取数据的时间小于 500 毫秒, 略过 <code>&lt;Loading&gt;</code> 组件直接展示用户的数据。<a href=\"https://github.com/MuYunyun/react/blob/29b7b775f2ecf878eaf605be959d959030598b07/packages/react-reconciler/src/ReactFiberUnwindWork.js#L232-L242\" target=\"_blank\" rel=\"noopener\">相关源码</a>。</p>\n<p>需要注意的是 <code>maxDuration</code> 属性只有在 <code>Concurrent Mode</code> 下才生效, 可参考<a href=\"https://github.com/MuYunyun/react/blob/29b7b775f2ecf878eaf605be959d959030598b07/packages/react-reconciler/src/ReactFiberUnwindWork.js#L270-L277\" target=\"_blank\" rel=\"noopener\">源码中的注释</a>。在 Sync 模式下, <code>maxDuration</code> 始终为 0。</p>\n<h3 id=\"后记-缓存算法\"><a href=\"#后记-缓存算法\" class=\"headerlink\" title=\"后记: 缓存算法\"></a>后记: 缓存算法</h3><ul>\n<li><code>LRU</code> 算法: <code>Least Recently Used</code> 最近最少使用算法(根据时间);</li>\n<li><code>LFU</code> 算法: <code>Least Frequently Used</code> 最近最少使用算法(根据次数);</li>\n</ul>\n<blockquote>\n<p><a href=\"https://juejin.im/post/5c0392656fb9a049fb4366fa\" target=\"_blank\" rel=\"noopener\">漫画：什么是 LRU 算法</a></p>\n</blockquote>\n<p>若数据的长度限定是 3, 访问顺序为 <code>set(2,2),set(1,1),get(2),get(1),get(2),set(3,3),set(4,4)</code>, 则根据 <code>LRU</code> 算法删除的是 <code>(3, 3)</code>, 根据 <code>LFU</code> 算法删除的是 <code>(1, 1)</code>。</p>\n<p><code>react-cache</code> 采用的是 <code>LRU</code> 算法。</p>\n<h3 id=\"相关资料\"><a href=\"#相关资料\" class=\"headerlink\" title=\"相关资料\"></a>相关资料</h3><ul>\n<li><a href=\"https://github.com/demos-platform/suspenseDemo\" target=\"_blank\" rel=\"noopener\">suspenseDemo</a>: 文字相关案例都集成在该 demo 中</li>\n<li><a href=\"https://github.com/facebook/react/issues/13206\" target=\"_blank\" rel=\"noopener\">Releasing Suspense</a>: <code>Suspense</code> 开发进度</li>\n<li><a href=\"https://medium.com/@ryanflorence/the-suspense-is-killing-redux-e888f9692430\" target=\"_blank\" rel=\"noopener\">the suspense is killing redux</a></li>\n</ul>\n","categories":["React"],"tags":["React"]},{"title":"hexo 摸爬滚打之进阶教程","url":"/posts/f55182c5/","content":"<p><img src=\"http://with.muyunyun.cn/d6b051baa29bb75e6b5f691313a82c33.jpg-muyy\" alt=\"\"></p>\n<p>写博客有三个层次，第一层次是借鉴居多的博文，第二层次是借鉴后经过消化后有一定量产出的博文，第三层次是原创好文居多的博文。在参考了大量前辈搭建hexo的心得后，此文尽量把一些别人未提到的点以及比较好用的点给提出来。所以你在参考本文的时候，应该已经过完了<a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">hexo</a>。本文有以下内容:</p>\n<ul>\n<li>快速实现博客压缩</li>\n<li>文章链接唯一化</li>\n<li>添加酷炫的打赏二维码</li>\n<li>自定义JS和CSS</li>\n<li>添加酷炫的歌单模块以及播放器</li>\n<li>github分支管理博客思路</li>\n<li>秒传图片到七牛云并展现在博客中</li>\n<li>将博客同时部署到github和coding<a id=\"more\"></a>\n\n</li>\n</ul>\n<h2 id=\"快速实现博客压缩\"><a href=\"#快速实现博客压缩\" class=\"headerlink\" title=\"快速实现博客压缩\"></a>快速实现博客压缩</h2><p>项目压缩也叫<code>代码丑化</code>, 分别对 html、css、js、images进行优化，即把重复的代码合并，把多余的空格去掉，用算法把 images 进行压缩。压缩后的博客，加载速度会有较大的提升，自然能留住更多游客。</p>\n<p>蛮多朋友使用了<code>gulp</code>对博客进行压缩，这也是一个办法，但在社区逛了下，找到了一个比较好用的模块<a href=\"https://github.com/chenzhutian/hexo-all-minifier\" target=\"_blank\" rel=\"noopener\">hexo-all-minifier</a>，这个模块集成了对 html、css、js、image 的优化。安装上此模块后，只要在根目录下的_config.yml文件中加上如下字段就可对博客所有内容进行压缩。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">html_minifier:</span><br><span class=\"line\">  enable: <span class=\"literal\">true</span></span><br><span class=\"line\">  ignore_error: <span class=\"literal\">false</span></span><br><span class=\"line\">  exclude:</span><br><span class=\"line\"></span><br><span class=\"line\">css_minifier:</span><br><span class=\"line\">  enable: <span class=\"literal\">true</span></span><br><span class=\"line\">  exclude:</span><br><span class=\"line\">    - <span class=\"string\">'*.min.css'</span></span><br><span class=\"line\"></span><br><span class=\"line\">js_minifier:</span><br><span class=\"line\">  enable: <span class=\"literal\">true</span></span><br><span class=\"line\">  mangle: <span class=\"literal\">true</span></span><br><span class=\"line\">  output:</span><br><span class=\"line\">  compress:</span><br><span class=\"line\">  exclude:</span><br><span class=\"line\">    - <span class=\"string\">'*.min.js'</span></span><br><span class=\"line\"></span><br><span class=\"line\">image_minifier:</span><br><span class=\"line\">  enable: <span class=\"literal\">true</span></span><br><span class=\"line\">  interlaced: <span class=\"literal\">false</span></span><br><span class=\"line\">  multipass: <span class=\"literal\">false</span></span><br><span class=\"line\">  optimizationLevel: <span class=\"number\">2</span></span><br><span class=\"line\">  pngquant: <span class=\"literal\">false</span></span><br><span class=\"line\">  progressive: <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"文章链接唯一化\"><a href=\"#文章链接唯一化\" class=\"headerlink\" title=\"文章链接唯一化\"></a>文章链接唯一化</h2><p>也许你会数次更改文章题目或者变更文章发布时间，在默认设置下，文章链接都会改变，不利于搜索引擎收录，也不利于分享。唯一永久链接才是更好的选择。</p>\n<p>安装</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure>\n<p>在<code>站点配置文件</code>中查找代码<code>permalink</code>，将其更改为:</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\">permalink: posts/:abbrlink/  # “posts/” 可自行更换</span><br></pre></td></tr></table></figure>\n\n<p>这里有个知识点：</p>\n<blockquote>\n<p>百度蜘蛛抓取网页的规则:  对于蜘蛛说网页权重越高、信用度越高抓取越频繁，例如网站的首页和内页。蜘蛛先抓取网站的首页，因为首页权重更高，并且大部分的链接都是指向首页。然后通过首页抓取网站的内页，并不是所有内页蜘蛛都会去抓取。</p>\n</blockquote>\n<p>搜索引擎认为对于一般的中小型站点，3层足够承受所有的内容了，所以蜘蛛经常抓取的内容是前三层，而超过三层的内容蜘蛛认为那些内容并不重要，所以不经常爬取。出于这个原因所以permalink后面跟着的最好不要超过2个斜杠。</p>\n<p>然后在<code>站点配置文件</code>中添加如下代码:</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\"># abbrlink config</span><br><span class=\"line\">abbrlink:</span><br><span class=\"line\">  alg: crc32  # 算法：crc16(default) and crc32</span><br><span class=\"line\">  rep: hex    # 进制：dec(default) and hex</span><br></pre></td></tr></table></figure>\n\n<p>可选择模式：</p>\n<ul>\n<li>crc16 &amp; hex</li>\n<li>crc16 &amp; dec</li>\n<li>crc32 &amp; hex</li>\n<li>crc32 &amp; dec</li>\n</ul>\n<h2 id=\"添加酷炫的打赏二维码\"><a href=\"#添加酷炫的打赏二维码\" class=\"headerlink\" title=\"添加酷炫的打赏二维码\"></a>添加酷炫的打赏二维码</h2><p>看了好些博客，支付宝的收款码和微信的收款码都是分开的，且是没有美化过的二维码，让人打赏的欲望自然就下降了。来看一下我的赞赏二维码(支持微信和支付宝支付哟)<br><img src=\"http://with.muyunyun.cn/134f61fc3181e90acfa945aad72a04a6.png-400\" alt=\"\"></p>\n<p>实现这个酷炫二维码的流程如下：</p>\n<ul>\n<li>首先，分别获得支付宝和微信的收款码</li>\n<li>接着到<a href=\"https://www.hotapp.cn/shouqian\" target=\"_blank\" rel=\"noopener\">芝麻二维码</a>里将两张二维码合并</li>\n<li>最后到<a href=\"http://www.9thws.com/\" target=\"_blank\" rel=\"noopener\">第九工场</a>生成自己喜欢的造型</li>\n</ul>\n<p>讲生成的图片pay.png放到根目录的source文件中，并在主题配置文件中加上</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">alipay: <span class=\"regexp\">/pay.png</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"打赏字体不闪动\"><a href=\"#打赏字体不闪动\" class=\"headerlink\" title=\"打赏字体不闪动\"></a>打赏字体不闪动</h3><p>修改文件<code>next/source/css/_common/components/post/post-reward.styl</code>，然后注释其中的函数<code>wechat:hover</code>和<code>alipay:hover</code>，如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 注释文字闪动函数</span></span><br><span class=\"line\"><span class=\"comment\"> #wechat:hover p&#123;</span></span><br><span class=\"line\"><span class=\"comment\">    animation: roll 0.1s infinite linear;</span></span><br><span class=\"line\"><span class=\"comment\">    -webkit-animation: roll 0.1s infinite linear;</span></span><br><span class=\"line\"><span class=\"comment\">    -moz-animation: roll 0.1s infinite linear;</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> #alipay:hover p&#123;</span></span><br><span class=\"line\"><span class=\"comment\">   animation: roll 0.1s infinite linear;</span></span><br><span class=\"line\"><span class=\"comment\">    -webkit-animation: roll 0.1s infinite linear;</span></span><br><span class=\"line\"><span class=\"comment\">    -moz-animation: roll 0.1s infinite linear;</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"自定义JS和CSS\"><a href=\"#自定义JS和CSS\" class=\"headerlink\" title=\"自定义JS和CSS\"></a>自定义JS和CSS</h2><p>博主用的是next主题，别的主题目录结构可能不太一样，但是整个框架是一样的，生成方式是一样的，所以引用方式也是相同的</p>\n<h3 id=\"添加自定义js样式\"><a href=\"#添加自定义js样式\" class=\"headerlink\" title=\"添加自定义js样式\"></a>添加自定义js样式</h3><ul>\n<li>首先把js文件放在<code>\\themes\\next\\source\\js\\src</code>文件目录下</li>\n<li>然后找到<code>\\themes\\next\\layout</code>目录下的布局文件<code>_layout.swig</code></li>\n<li>把script引用代码加入到该文件中即可</li>\n</ul>\n<p><code>&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/js文件名.js&quot;&gt;&lt;/script&gt;</code></p>\n<h3 id=\"添加自定义css样式\"><a href=\"#添加自定义css样式\" class=\"headerlink\" title=\"添加自定义css样式\"></a>添加自定义css样式</h3><p>添加外部css样式和引用自定义js代码是一样的，在对应css文件夹内添加自定义外部css样式文件，然后在layout文件中添加引用即可。也可以在<code>\\themes\\next\\source\\css\\_custom\\custom.styl</code>文件中进行样式的添加。</p>\n<h2 id=\"添加酷炫的歌单模块以及播放器\"><a href=\"#添加酷炫的歌单模块以及播放器\" class=\"headerlink\" title=\"添加酷炫的歌单模块以及播放器\"></a>添加酷炫的歌单模块以及播放器</h2><p>这个模块借鉴了@<a href=\"http://www.barretlee.com/entry/\" target=\"_blank\" rel=\"noopener\">小胡子哥</a>。根据上面的自定义JS和CSS的知识点不难实现歌单模块以及播放器。效果如下图：<br><img src=\"http://with.muyunyun.cn/502d78856e46095253e59fd11396b2a4.jpg\" alt=\"\"><br>核心代码在<code>\\themes\\next\\source\\js\\src\\music\\nmlist</code>中，<a href=\"https://github.com/MuYunyun/MuYunyun.githubio/blob/muyy/themes/next/source/js/src/music/nmlist.js\" target=\"_blank\" rel=\"noopener\">点击看源码</a>，其核心思路就是通过jsonp的方式对定义好的歌单进行调用。</p>\n<p>在调试的过程中，发现了小胡子哥代码的一个bug：当点击一个专辑暂停后，再点击其他的专辑，这时候点击暂停、播放的控制逻辑有错误。经过排查在nmlist.js文件中的bind方法中加上了<code>$(&quot;#nmPlayer&quot;).removeAttr(&quot;data-paused&quot;)</code>解决了这个bug。</p>\n<p><img src=\"http://with.muyunyun.cn/73d9f4070b81bbdab8f80db388af4a40.jpg\" alt=\"\"></p>\n<p>再接着玩的话，可以给播放器加上歌词的功能。这里有一篇<a href=\"http://frankorz.com/2016/09/30/Hexo-patch/#歌词\" target=\"_blank\" rel=\"noopener\">相关文章</a>, 有机会可以去把玩一番。</p>\n<h2 id=\"github分支管理博客思路\"><a href=\"#github分支管理博客思路\" class=\"headerlink\" title=\"github分支管理博客思路\"></a>github分支管理博客思路</h2><p>有一个问题，如果我电脑坏了怎么办，因为在github中的我们github.io项目是只有编译后的文件的，没有源文件的，也就是说，如果我们的电脑坏了，打不开了，我们的博客就不能进行更新了，所以我们要把我们的源文件也上传到github上。这个时候我可以选择新建一个仓库来存放源文件，也可以把源文件 push 到 user.github.io 的其他分支。我选择了后者。</p>\n<h3 id=\"创建muyy-任意-分支\"><a href=\"#创建muyy-任意-分支\" class=\"headerlink\" title=\"创建muyy(任意)分支\"></a>创建muyy(任意)分支</h3><p>创建两个分支：master 与 muyy,（这个muyy分支就是存放我们源文件的分支，我们只需要更新muyy分支上的内容据就好，master上的分支hexo编译的时候会更新的）</p>\n<h3 id=\"初始化仓库\"><a href=\"#初始化仓库\" class=\"headerlink\" title=\"初始化仓库\"></a>初始化仓库</h3><p>然后我们再初始化仓库，重新对我们的代码进行版本控制</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">git init</span><br><span class=\"line\">git remote add origin &lt;server&gt;</span><br></pre></td></tr></table></figure>\n<p><code>&lt;server&gt;</code>是指在线仓库的地址。origin是本地分支,remote add操作会将本地仓库映射到云端</p>\n<h3 id=\"将博客源文件上传至muyy分支\"><a href=\"#将博客源文件上传至muyy分支\" class=\"headerlink\" title=\"将博客源文件上传至muyy分支\"></a>将博客源文件上传至muyy分支</h3><p>.gitignore文件作用是声明不被git记录的文件，blog根目录下的.gitignore是hexo初始化带来的，可以先删除或者直接编辑，对hexo不会有影响。建议.gitignore内添加以下内容：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">/.deploy_git</span><br><span class=\"line\">/public</span><br><span class=\"line\">/_config.yml</span><br></pre></td></tr></table></figure>\n<p>.deploy_git是hexo默认的.git配置文件夹，不需要同步<br>public内文件是根据source文件夹内容自动生成，不需要备份，不然每次改动内容太多<br>即使是私有仓库，除去在线服务商员工可以看到的风险外，还有云服务商被攻击造成泄漏等可能，所以不建议将配置文件传上去</p>\n<p>依次执行</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">git add .</span><br><span class=\"line\">git commit -m <span class=\"string\">\"...\"</span></span><br><span class=\"line\">git push origin muyy</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"秒传图片到七牛云并展现在博客中\"><a href=\"#秒传图片到七牛云并展现在博客中\" class=\"headerlink\" title=\"秒传图片到七牛云并展现在博客中\"></a>秒传图片到七牛云并展现在博客中</h2><p>在markdown中写blog的朋友，想必这点是最烦恼的吧，一般来说都要手动上传图片到七牛云，再把链接写到markdown中。逛了逛社区，有人用phthon实现一个自动上传的脚本，但是我觉得还不是特别方便，这时在github上找到一个一键贴图工具<a href=\"https://github.com/jiwenxing/qiniu-image-tool\" target=\"_blank\" rel=\"noopener\">qiniu-image-tool</a>，它支持本地文件、截图、网络图片一键上传七牛云并返回图片引用。Mac 是基于 Alfred 的，其 windows 也有相应版本<a href=\"http://jverson.com/2017/05/28/qiniu-image-v2/\" target=\"_blank\" rel=\"noopener\">windows版本</a>。</p>\n<p>按照其要求配置好以后，用截图软件截图后，或者本地图片后 copy，然后直接按设置好的 command+option+v，然后在图片成功上传到七牛云图床上，剪贴板上也有相应的连接。<br><img src=\"https://raw.githubusercontent.com/jiwenxing/qiniu-image-tool/master/res/local.gif\" alt=\"\"></p>\n<h2 id=\"将博客同时部署到-github-和-coding\"><a href=\"#将博客同时部署到-github-和-coding\" class=\"headerlink\" title=\"将博客同时部署到 github 和 coding\"></a>将博客同时部署到 github 和 coding</h2><p>通常我们把hexo托管在github，但是毕竟github是国外的，访问速度上还是有点慢，所以想也部署一套在国内的托管平台，目前gitcafe已经被coding收购了，所以就决定部署到coding。但是coding有个不好的地方就是访问自定义域名的站点时，不充值的话会有广告跳转页，所以我现在也是处于观望的态度，先把coding的环境代码也先布置好，等它哪一天广告跳转页没了，就把域名指过去。</p>\n<h3 id=\"coding-上创建一个新项目\"><a href=\"#coding-上创建一个新项目\" class=\"headerlink\" title=\"coding 上创建一个新项目\"></a>coding 上创建一个新项目</h3><p>这里只介绍 coding 上面如何创建项目，以及把本地 hexo 部署到 coding 上面<br><img src=\"http://with.muyunyun.cn/41b27d98189a9164d2b2a47ccbafdbfa.jpg\" alt=\"\"></p>\n<h3 id=\"同步本地-hexo-到-coding-上\"><a href=\"#同步本地-hexo-到-coding-上\" class=\"headerlink\" title=\"同步本地 hexo 到 coding 上\"></a>同步本地 hexo 到 coding 上</h3><p>把获取到了ssh配置_config.yml文件中的deploy下，如果是第一次使用 coding 的话，需要设置SSH公钥，生成的方法可以参考<a href=\"https://coding.net/help/doc/git/ssh-key.html\" target=\"_blank\" rel=\"noopener\">coding帮助中心</a>, 其实和 github 配置一模一样的。</p>\n<p>本地打开 <code>id_rsa.pub</code> 文件，复制其中全部内容，填写到<code>SSH_RSA公钥</code>key下的一栏，公钥名称可以随意起名字。完成后点击“添加”，然后输入密码或动态码即可添加完成。</p>\n<p>添加后，在git bash命令输入：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">ssh -T git@git.coding.net</span><br></pre></td></tr></table></figure>\n<p>如果得到下面提示就表示公钥添加成功了：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">Coding.net Tips : [Hello ! You<span class=\"string\">'ve conected to Coding.net by SSH successfully! ]</span></span><br></pre></td></tr></table></figure>\n<p>想要同时部署到2个平台，就要修改博客根目录下面的_config.yml文件中的deploy如下<br>根据Hexo官方文档需要修改成下面的形式</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  type: git</span><br><span class=\"line\">  message: [message]</span><br><span class=\"line\">  repo:</span><br><span class=\"line\">    github: <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">repository</span> <span class=\"attr\">url</span>&gt;</span>,[branch]</span></span><br><span class=\"line\">    gitcafe: &lt;repository url&gt;,[branch]</span><br></pre></td></tr></table></figure>\n<p>所以我是这样的</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">- type: git</span><br><span class=\"line\">  repo:</span><br><span class=\"line\">    github: https:<span class=\"comment\">//github.com/MuYunyun/MuYunyun.github.io.git,master</span></span><br><span class=\"line\">    coding: git@git.coding.net:muyunyun/muyunyun.git,master</span><br></pre></td></tr></table></figure>\n<p>最后使用部署命令就能把博客同步到coding上面：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">hexo deploy -g</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"pages服务方式部署\"><a href=\"#pages服务方式部署\" class=\"headerlink\" title=\"pages服务方式部署\"></a>pages服务方式部署</h3><p>将代码上传至coding之后我们就要开启pages服务了，在pages页面我们只需要将部署来源选择为master分支，然后将自定义域名填写我们自己购买的域名就可以了</p>\n<h3 id=\"设置域名解析\"><a href=\"#设置域名解析\" class=\"headerlink\" title=\"设置域名解析\"></a>设置域名解析</h3><p>现在要实现国内的走coding，海外的走github，只要配置2个CNAME就行。域名解析如下：<br><img src=\"http://with.muyunyun.cn/c2337ab8ed97d0f825703e8ea80a4123.jpg\" alt=\"\"></p>\n<h3 id=\"添加评论\"><a href=\"#添加评论\" class=\"headerlink\" title=\"添加评论\"></a>添加评论</h3><p>目前使用的评论系统是 <a href=\"https://github.com/imsun/gitment\" target=\"_blank\" rel=\"noopener\">gitment</a>, 其存储评论的数据在 github 相应的仓库中。</p>\n<blockquote>\n<p><a href=\"https://github.com/imsun/gitment/issues/175#issuecomment-570030753\" target=\"_blank\" rel=\"noopener\">解决证书过期的问题</a>, 初步分析是项目的证书过期了, 导致存储在项目的 cdn 引用失败。后续如果还有问题的话, 考虑自行维护。</p>\n</blockquote>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"http://www.barretlee.com/entry/\" target=\"_blank\" rel=\"noopener\">小胡子哥</a></li>\n<li><a href=\"http://www.vitah.net/posts/20f300cc/\" target=\"_blank\" rel=\"noopener\">Hexo Next主题设置和优化</a></li>\n<li><a href=\"http://frankorz.com/2016/09/30/Hexo-patch/\" target=\"_blank\" rel=\"noopener\">Hexo 博客补丁</a></li>\n<li><a href=\"http://www.cduyzh.com/page/3/\" target=\"_blank\" rel=\"noopener\">Water Sister’s Blog</a></li>\n<li><a href=\"http://blog.ynxiu.com/2016/hexo-next-theme-optimize.html\" target=\"_blank\" rel=\"noopener\">Hexo+NexT主题配置备忘</a></li>\n<li><a href=\"http://www.cherryblog.site/\" target=\"_blank\" rel=\"noopener\">Cherry’s Blog</a></li>\n<li><a href=\"http://lovenight.github.io/2015/11/10/Hexo-3-1-1-%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/\" target=\"_blank\" rel=\"noopener\">Hexo 3.1.1 静态博客搭建指南</a></li>\n<li><a href=\"http://shenzekun.cn/hexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B.html\" target=\"_blank\" rel=\"noopener\">hexo的next主题个性化教程:打造炫酷网站</a></li>\n<li><a href=\"http://tengj.github.io/2016/03/06/hexo4/\" target=\"_blank\" rel=\"noopener\">将hexo博客同时托管到github和coding</a></li>\n</ul>\n","categories":["git"],"tags":["hexo","blog"]},{"title":"从 0 到 1 实现 React 系列 —— 2.组件和 state|props","url":"/posts/a40f0b93/","content":"<p><img src=\"http://with.muyunyun.cn/9c461a61924ed0fecb6024a256671251.jpg-muyy\" alt=\"\"></p>\n<p>本系列文章在实现一个 cpreact 的同时帮助大家理顺 React 框架的核心内容(JSX/虚拟DOM/组件/生命周期/diff算法/setState/PureComponent/HOC/…) <a href=\"https://github.com/MuYunyun/cpreact\" target=\"_blank\" rel=\"noopener\">项目地址</a></p>\n<a id=\"more\"></a>\n\n<ul>\n<li><a href=\"https://github.com/MuYunyun/blog/issues/24\" target=\"_blank\" rel=\"noopener\">从 0 到 1 实现 React 系列 —— JSX 和 Virtual DOM</a></li>\n<li><a href=\"https://github.com/MuYunyun/blog/issues/25\" target=\"_blank\" rel=\"noopener\">从 0 到 1 实现 React 系列 —— 组件和 state|props</a></li>\n<li><a href=\"https://github.com/MuYunyun/blog/issues/26\" target=\"_blank\" rel=\"noopener\">从 0 到 1 实现 React 系列 —— 生命周期和 diff 算法</a></li>\n<li><a href=\"https://github.com/MuYunyun/blog/issues/27\" target=\"_blank\" rel=\"noopener\">从 0 到 1 实现 React 系列 —— 优化 setState 和 ref 的实现</a></li>\n<li><a href=\"https://github.com/MuYunyun/blog/issues/29\" target=\"_blank\" rel=\"noopener\">从 0 到 1 实现 React 系列 —— PureComponent 实现 &amp;&amp; HOC 探幽</a></li>\n</ul>\n<h3 id=\"组件即函数\"><a href=\"#组件即函数\" class=\"headerlink\" title=\"组件即函数\"></a>组件即函数</h3><p>在上一篇 <a href=\"https://github.com/MuYunyun/blog/issues/24\" target=\"_blank\" rel=\"noopener\">JSX 和 Virtual DOM</a> 中，解释了 JSX 渲染到界面的过程并实现了相应代码，代码调用如下所示：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> ReactDOM <span class=\"keyword\">from</span> <span class=\"string\">'react-dom'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> element = (</span><br><span class=\"line\">  &lt;div className=<span class=\"string\">\"title\"</span>&gt;</span><br><span class=\"line\">    hello&lt;span className=<span class=\"string\">\"content\"</span>&gt;world!&lt;<span class=\"regexp\">/span&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">  &lt;/</span>div&gt;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">ReactDOM.render(</span><br><span class=\"line\">  element,</span><br><span class=\"line\">  <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'root'</span>)</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p>本小节，我们接着探究组件渲染到界面的过程。在此我们引入组件的概念，<code>组件本质上就是一个函数</code>，如下就是一段标准组件代码：</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 写法 1：</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>I'm componentA<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 写法 2：无状态组件</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> A = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>I'm componentA<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">ReactDOM.render(<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">A</span> /&gt;</span></span>, <span class=\"built_in\">document</span>.body)</span><br></pre></td></tr></table></figure>\n\n<p><code>&lt;A name=&quot;componentA&quot; /&gt;</code> 是 JSX 的写法，和<a href=\"https://github.com/MuYunyun/blog/issues/24\" target=\"_blank\" rel=\"noopener\">上一篇</a>同理，babel 将其转化为 React.createElement() 的形式，<a href=\"https://babeljs.io/en/repl#?babili=false&browsers=&build=&builtIns=false&spec=false&loose=false&code_lz=MYGwhgzhAECC0FMAeAXBA7AJjAwgewFsAHPdDFaAbwCgBIAJw0wXoAoBKKuhhFAV3rpoAHkwBLAG4A-AJIByAlRQALMRAB0ReniIb0YAggC-wgPTjpAbjpHqt6sPj7DAXgBEwQiTLoUsN9CmUtRAA&debug=false&forceAllTransforms=false&shippedProposals=false&circleciRepo=&evaluate=false&fileSize=false&sourceType=module&lineWrap=true&presets=react&prettier=false&targets=&version=6.26.0&envVersion=\" target=\"_blank\" rel=\"noopener\">转化结果</a>如下所示：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">React.createElement(A, <span class=\"literal\">null</span>)</span><br></pre></td></tr></table></figure>\n\n<p>可以看到当 JSX 中是自定义组件的时候，createElement 后接的第一个参数变为了函数，在 <a href=\"https://preactjs.com/repl\" target=\"_blank\" rel=\"noopener\">repl</a> 打印 <code>&lt;A name=&quot;componentA&quot; /&gt;</code>，结果如下：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attribute\">attributes</span>: undefined,</span><br><span class=\"line\">  children: [],</span><br><span class=\"line\">  key: undefined,</span><br><span class=\"line\">  nodeName: ƒ <span class=\"built_in\">A</span>()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意这时返回的 Virtual DOM 中的 nodeName 也变为了函数。根据这些线索，我们对之前的 <code>render</code> 函数进行改造。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">render</span>(<span class=\"params\">vdom, container</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (_.isFunction(vdom.nodeName)) &#123; <span class=\"comment\">// 如果 JSX 中是自定义组件</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> component, returnVdom</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (vdom.nodeName.prototype.render) &#123;</span><br><span class=\"line\">      component = <span class=\"keyword\">new</span> vdom.nodeName()</span><br><span class=\"line\">      returnVdom = component.render()</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      returnVdom = vdom.nodeName() <span class=\"comment\">// 针对无状态组件：const A = () =&gt; &lt;div&gt;I'm componentsA&lt;/div&gt;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render(returnVdom, container)</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>至此，我们完成了对组件的处理逻辑。</p>\n<h3 id=\"props-和-state-的实现\"><a href=\"#props-和-state-的实现\" class=\"headerlink\" title=\"props 和 state 的实现\"></a>props 和 state 的实现</h3><p>在上个小节组件 A 中，是没有引入任何属性和状态的，我们希望组件间能进行属性的传递(props)以及组件内能进行状态的记录(state)。</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>I'm &#123;this.props.name&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">ReactDOM.render(<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">A</span> <span class=\"attr\">name</span>=<span class=\"string\">\"componentA\"</span> /&gt;</span></span>, <span class=\"built_in\">document</span>.body)</span><br></pre></td></tr></table></figure>\n\n<p>在上面这段代码中，看到 A 函数继承自 Component。我们来构造这个父类 Component，并在其添加 state、props、setState 等属性方法，从而让子类继承到它们。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Component</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.props = props</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.state = <span class=\"keyword\">this</span>.state || &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>首先，我们将组件外的 props 传进组件内，修改 render 函数中以下代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">render</span>(<span class=\"params\">vdom, container</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (_.isFunction(vdom.nodeName)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> component, returnVdom</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (vdom.nodeName.prototype.render) &#123;</span><br><span class=\"line\">      component = <span class=\"keyword\">new</span> vdom.nodeName(vdom.attributes) <span class=\"comment\">// 将组件外的 props 传进组件内</span></span><br><span class=\"line\">      returnVdom = component.render()</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      returnVdom = vdom.nodeName(vdom.attributes) \t<span class=\"comment\">// 处理无状态组件：const A = (props) =&gt; &lt;div&gt;I'm &#123;props.name&#125;&lt;/div&gt;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实现完组件间 props 的传递后，再来聊聊 state，在 react 中是通过 setState 来完成组件状态的改变的，后续章节会对这个 api（异步）深入探究，这里简单实现如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Component</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.props = props</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.state = <span class=\"keyword\">this</span>.state || &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Component.prototype.setState = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.state = <span class=\"built_in\">Object</span>.assign(&#123;&#125;, <span class=\"keyword\">this</span>.state, updateObj) <span class=\"comment\">// 这里简单实现，后续篇章会深入探究</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> returnVdom = <span class=\"keyword\">this</span>.render() <span class=\"comment\">// 重新渲染</span></span><br><span class=\"line\">  <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'root'</span>).innerHTML = <span class=\"literal\">null</span></span><br><span class=\"line\">  render(returnVdom, <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'root'</span>))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>此时虽然已经实现了 setState 的功能，但是 <code>document.getElementById(&#39;root&#39;)</code> 节点写死在 setState 中显然不是我们希望的，我们将 dom 节点相关转移到 _render 函数中：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">Component.prototype.setState = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">updateObj</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.state = <span class=\"built_in\">Object</span>.assign(&#123;&#125;, <span class=\"keyword\">this</span>.state, updateObj)</span><br><span class=\"line\">  _render(<span class=\"keyword\">this</span>) <span class=\"comment\">// 重新渲染</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>自然地，重构与之相关的 render 函数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">render</span>(<span class=\"params\">vdom, container</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> component</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (_.isFunction(vdom.nodeName)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (vdom.nodeName.prototype.render) &#123;</span><br><span class=\"line\">      component = <span class=\"keyword\">new</span> vdom.nodeName(vdom.attributes)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      component = vdom.nodeName(vdom.attributes) <span class=\"comment\">// 处理无状态组件：const A = (props) =&gt; &lt;div&gt;I'm &#123;props.name&#125;&lt;/div&gt;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  component ? _render(component, container) : _render(vdom, container)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在 render 函数中分离出 _render 函数的目的是为了让 setState 函数中也能调用 _render 逻辑。完整 _render 函数如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">_render</span>(<span class=\"params\">component, container</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> vdom = component.render ? component.render() : component</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (_.isString(vdom) || _.isNumber(vdom)) &#123;</span><br><span class=\"line\">    container.innerText = container.innerText + vdom</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> dom = <span class=\"built_in\">document</span>.createElement(vdom.nodeName)</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> attr <span class=\"keyword\">in</span> vdom.attributes) &#123;</span><br><span class=\"line\">    setAttribute(dom, attr, vdom.attributes[attr])</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  vdom.children.forEach(<span class=\"function\"><span class=\"params\">vdomChild</span> =&gt;</span> render(vdomChild, dom))</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (component.container) &#123;  <span class=\"comment\">// 注意：调用 setState 方法时是进入这段逻辑，从而实现我们将 dom 的逻辑与 setState 函数分离的目标；知识点: new 出来的同一个实例</span></span><br><span class=\"line\">    component.container.innerHTML = <span class=\"literal\">null</span></span><br><span class=\"line\">    component.container.appendChild(dom)</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  component.container = container</span><br><span class=\"line\">  container.appendChild(dom)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>让我们用下面这个用例跑下写好的 react 吧！</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(props)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;</span><br><span class=\"line\">      count: <span class=\"number\">1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  click() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">      count: ++<span class=\"keyword\">this</span>.state.count</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;button onClick=&#123;<span class=\"keyword\">this</span>.click.bind(<span class=\"keyword\">this</span>)&#125;&gt;Click Me!&lt;<span class=\"regexp\">/button&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;div&gt;&#123;this.props.name&#125;:&#123;this.state.count&#125;&lt;/</span>div&gt;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    )</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">ReactDOM.render(</span></span><br><span class=\"line\"><span class=\"regexp\">  &lt;A name=\"count\" /</span>&gt;,</span><br><span class=\"line\">  <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'root'</span>)</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p>效果图如下：</p>\n<p><img src=\"http://with.muyunyun.cn/reactsetstate.gif\" alt=\"\"></p>\n<p>至此，我们实现了 props 和 state 部分的逻辑。</p>\n<h3 id=\"forceUpdate-的实现\"><a href=\"#forceUpdate-的实现\" class=\"headerlink\" title=\"forceUpdate 的实现\"></a>forceUpdate 的实现</h3><blockquote>\n<p>声明：这部分为补充章节，可以选择性阅读。涉及到后文<a href=\"https://github.com/MuYunyun/blog/blob/master/BasicSkill/从0到1实现React/3.生命周期.md\" target=\"_blank\" rel=\"noopener\">生命周期</a>、<a href=\"https://github.com/MuYunyun/blog/blob/master/BasicSkill/从0到1实现React/5.setState.md\" target=\"_blank\" rel=\"noopener\">setState</a> 章节的知识点。</p>\n</blockquote>\n<p>当没有使用 setState 更新 state 状态时，通常要结合 forceUpdate 一起使用，例子如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(props)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;</span><br><span class=\"line\">      count: &#123;</span><br><span class=\"line\">        value: <span class=\"number\">1</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  shouldComponentUpdate() &#123; <span class=\"comment\">// 当使用 forceUpdate() 时，shouldComponentUpdate() 会失效</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  click() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state.count.value = ++<span class=\"keyword\">this</span>.state.count.value <span class=\"comment\">// 没有使用 setState 更新 state 状态时，通常要结合 forceUpdate 一起使用</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.forceUpdate()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;button onClick=&#123;<span class=\"keyword\">this</span>.click.bind(<span class=\"keyword\">this</span>)&#125;&gt;Click Me!&lt;<span class=\"regexp\">/button&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;div&gt;&#123;this.state.count.value&#125;&lt;/</span>div&gt;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    )</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>这里要注意一个点<code>当使用 forceUpdate() 时，shouldComponentUpdate() 会失效</code>，下面我们来补充 forceUpdate() 的代码逻辑：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// force to update</span></span><br><span class=\"line\">Component.prototype.forceUpdate = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">cb</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.allowShouldComponentUpdate = <span class=\"literal\">false</span> <span class=\"comment\">// 不允许 allowShouldComponentUpdate 执行</span></span><br><span class=\"line\">  asyncRender(&#123;&#125;, <span class=\"keyword\">this</span>, cb)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>相应的在 render.js 中加上 allowShouldComponentUpdate 的判断条件：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">renderComponent</span>(<span class=\"params\">component</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (component.base &amp;&amp; component.shouldComponentUpdate &amp;&amp; component.allowShouldComponentUpdate !== <span class=\"literal\">false</span>) &#123; <span class=\"comment\">// 加上 allowShouldComponentUpdate 的判断条件</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> bool = component.shouldComponentUpdate(component.props, component.state)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!bool &amp;&amp; bool !== <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span> <span class=\"comment\">// shouldComponentUpdate() 返回 false，则生命周期终止</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>组件即函数；当 JSX 中是自定义组件时，经过 babel 转化后的 React.createElement(fn, ..) 后中的第一个参数变为了函数，除此之外其它逻辑与 JSX 中为 html 元素的时候相同；</p>\n<p>此外我们将 state/props/setState 等 api 封装进了父类 React.Component 中，从而在子类中能调用这些属性和方法。</p>\n<p>在下篇，我们会继续实现生命周期机制，如有疏漏，欢迎斧正。</p>\n<h3 id=\"鸣谢\"><a href=\"#鸣谢\" class=\"headerlink\" title=\"鸣谢\"></a>鸣谢</h3><p>Especially thank <a href=\"https://github.com/hujiulong/simple-react\" target=\"_blank\" rel=\"noopener\">simple-react</a> for the guidance function of this library. At the meantime，respect for <a href=\"https://github.com/developit/preact\" target=\"_blank\" rel=\"noopener\">preact</a> and <a href=\"https://github.com/facebook/react\" target=\"_blank\" rel=\"noopener\">react</a></p>\n","categories":["React"],"tags":["React"]},{"title":"从 0 到 1 实现 React 系列 —— 3.生命周期和 diff 算法","url":"/posts/dc5976f1/","content":"<p><img src=\"http://with.muyunyun.cn/9c461a61924ed0fecb6024a256671251.jpg-muyy\" alt=\"\"></p>\n<p>本系列文章在实现一个 cpreact 的同时帮助大家理顺 React 框架的核心内容(JSX/虚拟DOM/组件/生命周期/diff算法/setState/PureComponent/HOC/…) <a href=\"https://github.com/MuYunyun/cpreact\" target=\"_blank\" rel=\"noopener\">项目地址</a></p>\n<a id=\"more\"></a>\n\n<ul>\n<li><a href=\"https://github.com/MuYunyun/blog/issues/24\" target=\"_blank\" rel=\"noopener\">从 0 到 1 实现 React 系列 —— JSX 和 Virtual DOM</a></li>\n<li><a href=\"https://github.com/MuYunyun/blog/issues/25\" target=\"_blank\" rel=\"noopener\">从 0 到 1 实现 React 系列 —— 组件和 state|props</a></li>\n<li><a href=\"https://github.com/MuYunyun/blog/issues/26\" target=\"_blank\" rel=\"noopener\">从 0 到 1 实现 React 系列 —— 生命周期和 diff 算法</a></li>\n<li><a href=\"https://github.com/MuYunyun/blog/issues/27\" target=\"_blank\" rel=\"noopener\">从 0 到 1 实现 React 系列 —— 优化 setState 和 ref 的实现</a></li>\n<li><a href=\"https://github.com/MuYunyun/blog/issues/29\" target=\"_blank\" rel=\"noopener\">从 0 到 1 实现 React 系列 —— PureComponent 实现 &amp;&amp; HOC 探幽</a></li>\n</ul>\n<h3 id=\"生命周期\"><a href=\"#生命周期\" class=\"headerlink\" title=\"生命周期\"></a>生命周期</h3><p>先来回顾 React 的生命周期，用流程图表示如下：</p>\n<p><img src=\"http://with.muyunyun.cn/77e8b5ceaa1d697f280053be91a87bb3.jpg\" alt=\"\"></p>\n<p>该流程图比较清晰地呈现了 react 的生命周期。其分为 3 个阶段 —— 生成期，存在期，销毁期。</p>\n<p>因为生命周期钩子函数存在于自定义组件中，将之前 _render 函数作些调整如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 原来的 _render 函数，为了将职责拆分得更细，将 virtual dom 转为 real dom 的函数单独抽离出来</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">vdomToDom</span>(<span class=\"params\">vdom</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (_.isFunction(vdom.nodeName)) &#123;        <span class=\"comment\">// 为了更加方便地书写生命周期逻辑，将解析自定义组件逻辑和一般 html 标签的逻辑分离开</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> component = createComponent(vdom) <span class=\"comment\">// 构造组件</span></span><br><span class=\"line\">    setProps(component)                     <span class=\"comment\">// 更改组件 props</span></span><br><span class=\"line\">    renderComponent(component)              <span class=\"comment\">// 渲染组件，将 dom 节点赋值到 component</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> component.base                   <span class=\"comment\">// 返回真实 dom</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们可以在 setProps 函数内（渲染前）加入 <code>componentWillMount</code>，<code>componentWillReceiveProps</code> 方法，setProps 函数如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">setProps</span>(<span class=\"params\">component</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (component &amp;&amp; component.componentWillMount) &#123;</span><br><span class=\"line\">    component.componentWillMount()</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (component.base &amp;&amp; component.componentWillReceiveProps) &#123;</span><br><span class=\"line\">    component.componentWillReceiveProps(component.props) <span class=\"comment\">// 后面待实现</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>而后我们在 renderComponent 函数内加入 <code>componentDidMount</code>、<code>shouldComponentUpdate</code>、<code>componentWillUpdate</code>、<code>componentDidUpdate</code> 方法</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">renderComponent</span>(<span class=\"params\">component</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (component.base &amp;&amp; component.shouldComponentUpdate) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> bool = component.shouldComponentUpdate(component.props, component.state)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!bool &amp;&amp; bool !== <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span> <span class=\"comment\">// shouldComponentUpdate() 返回 false，则生命周期终止</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (component.base &amp;&amp; component.componentWillUpdate) &#123;</span><br><span class=\"line\">    component.componentWillUpdate()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> rendered = component.render()</span><br><span class=\"line\">  <span class=\"keyword\">const</span> base = vdomToDom(rendered)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (component.base &amp;&amp; component.componentDidUpdate) &#123;</span><br><span class=\"line\">    component.componentDidUpdate()</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (component &amp;&amp; component.componentDidMount) &#123;</span><br><span class=\"line\">    component.componentDidMount()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (component.base &amp;&amp; component.base.parentNode) &#123; <span class=\"comment\">// setState 进入此逻辑</span></span><br><span class=\"line\">    component.base.parentNode.replaceChild(base, component.base)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  component.base = base  <span class=\"comment\">// 标志符</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"测试生命周期\"><a href=\"#测试生命周期\" class=\"headerlink\" title=\"测试生命周期\"></a>测试生命周期</h4><p>测试如下用例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  componentWillReceiveProps(props) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'componentWillReceiveProps'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div&gt;&#123;<span class=\"keyword\">this</span>.props.count&#125;&lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    )</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">class B extends Component &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  constructor(props) &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    super(props)</span></span><br><span class=\"line\"><span class=\"regexp\">    this.state = &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">      count: 1</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">  componentWillMount() &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    console.log('componentWillMount')</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">  componentDidMount() &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    console.log('componentDidMount')</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">  shouldComponentUpdate(nextProps, nextState) &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    console.log('shouldComponentUpdate', nextProps, nextState)</span></span><br><span class=\"line\"><span class=\"regexp\">    return true</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">  componentWillUpdate() &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    console.log('componentWillUpdate')</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">  componentDidUpdate() &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    console.log('componentDidUpdate')</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">  click() &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    this.setState(&#123;</span></span><br><span class=\"line\"><span class=\"regexp\">      count: ++this.state.count</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;)</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">  render() &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    console.log('render')</span></span><br><span class=\"line\"><span class=\"regexp\">    return (</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;button onClick=&#123;this.click.bind(this)&#125;&gt;Click Me!&lt;/</span>button&gt;</span><br><span class=\"line\">        &lt;A count=&#123;<span class=\"keyword\">this</span>.state.count&#125; /&gt;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    )</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">ReactDOM.render(</span></span><br><span class=\"line\"><span class=\"regexp\">  &lt;B /</span>&gt;,</span><br><span class=\"line\">  <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'root'</span>)</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p>页面加载时输出结果如下：</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">componentWillMount</span></span><br><span class=\"line\"><span class=\"attribute\">render</span></span><br><span class=\"line\"><span class=\"attribute\">componentDidMount</span></span><br></pre></td></tr></table></figure>\n\n<p>点击按钮时输出结果如下：</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">shouldComponentUpdate</span></span><br><span class=\"line\"><span class=\"attribute\">componentWillUpdate</span></span><br><span class=\"line\"><span class=\"attribute\">render</span></span><br><span class=\"line\"><span class=\"attribute\">componentDidUpdate</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"diff-的实现\"><a href=\"#diff-的实现\" class=\"headerlink\" title=\"diff 的实现\"></a>diff 的实现</h3><p>在 react 中，diff 实现的思路是将新老 virtual dom 进行比较，将比较后的 patch（补丁）渲染到页面上，从而实现局部刷新；本文借鉴了 <a href=\"https://github.com/developit/preact\" target=\"_blank\" rel=\"noopener\">preact</a> 和 <a href=\"https://github.com/hujiulong/simple-react\" target=\"_blank\" rel=\"noopener\">simple-react</a> 中的 diff 实现，总体思路是将旧的 dom 节点和新的 virtual dom 节点进行了比较，根据不同的比较类型（文本节点、非文本节点、自定义组件）调用相应的逻辑，从而实现页面的局部渲染。代码总体结构如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 比较旧的 dom 节点和新的 virtual dom 节点：</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;*&#125;</span> </span>oldDom  旧的 dom 节点</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param <span class=\"type\">&#123;*&#125;</span> </span>newVdom 新的 virtual dom 节点</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">diff</span>(<span class=\"params\">oldDom, newVdom</span>) </span>&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (_.isString(newVdom)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> diffTextDom(oldDom, newVdom)   <span class=\"comment\">// 对比文本 dom 节点</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (oldDom.nodeName.toLowerCase() !== newVdom.nodeName) &#123;</span><br><span class=\"line\">    diffNotTextDom(oldDom, newVdom)       <span class=\"comment\">// 对比非文本 dom 节点</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (_.isFunction(newVdom.nodeName)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> diffComponent(oldDom, newVdom) <span class=\"comment\">// 对比自定义组件</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  diffAttribute(oldDom, newVdom)          <span class=\"comment\">// 对比属性</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (newVdom.children.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    diffChild(oldDom, newVdom)            <span class=\"comment\">// 遍历对比子节点</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> oldDom</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>下面根据不同比较类型实现相应逻辑。</p>\n<h4 id=\"对比文本节点\"><a href=\"#对比文本节点\" class=\"headerlink\" title=\"对比文本节点\"></a>对比文本节点</h4><p>首先进行较为简单的文本节点的比较，代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 对比文本节点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">diffTextDom</span>(<span class=\"params\">oldDom, newVdom</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> dom = oldDom</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (oldDom &amp;&amp; oldDom.nodeType === <span class=\"number\">3</span>) &#123;  <span class=\"comment\">// 如果老节点是文本节点</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldDom.textContent !== newVdom) &#123; <span class=\"comment\">// 这里一个细节：textContent/innerHTML/innerText 的区别</span></span><br><span class=\"line\">      oldDom.textContent = newVdom</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;                                <span class=\"comment\">// 如果旧 dom 元素不为文本节点</span></span><br><span class=\"line\">    dom = <span class=\"built_in\">document</span>.createTextNode(newVdom)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldDom &amp;&amp; oldDom.parentNode) &#123;</span><br><span class=\"line\">      oldDom.parentNode.replaceChild(dom, oldDom)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> dom</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"对比非文本节点\"><a href=\"#对比非文本节点\" class=\"headerlink\" title=\"对比非文本节点\"></a>对比非文本节点</h4><p>对比非文本节点，其思路为将同层级的旧节点替换为新节点，代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 对比非文本节点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">diffNotTextDom</span>(<span class=\"params\">oldDom, newVdom</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> newDom = <span class=\"built_in\">document</span>.createElement(newVdom.nodeName);</span><br><span class=\"line\">  [...oldDom.childNodes].map(newDom.appendChild) <span class=\"comment\">// 将旧节点下的元素添加到新节点下</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (oldDom &amp;&amp; oldDom.parentNode) &#123;</span><br><span class=\"line\">    oldDom.parentNode.replaceChild(oldDom, newDom)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"对比自定义组件\"><a href=\"#对比自定义组件\" class=\"headerlink\" title=\"对比自定义组件\"></a>对比自定义组件</h4><p>对比自定义组件的思路为：如果新老组件不同，则直接将新组件替换老组件；如果新老组件相同，则将新组件的 props 赋到老组件上，然后再对获得新 props 前后的老组件做 diff 比较。代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 对比自定义组件</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">diffComponent</span>(<span class=\"params\">oldDom, newVdom</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (oldDom._component &amp;&amp; (oldDom._component.constructor !== newVdom.nodeName)) &#123; <span class=\"comment\">// 如果新老组件不同，则直接将新组件替换老组件</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> newDom = vdomToDom(newVdom)</span><br><span class=\"line\">    oldDom._component.parentNode.insertBefore(newDom, oldDom._component)</span><br><span class=\"line\">    oldDom._component.parentNode.removeChild(oldDom._component)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    setProps(oldDom._component, newVdom.attributes) <span class=\"comment\">// 如果新老组件相同，则将新组件的 props 赋到老组件上</span></span><br><span class=\"line\">    renderComponent(oldDom._component)              <span class=\"comment\">// 对获得新 props 前后的老组件做 diff 比较（renderComponent 中调用了 diff）</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"遍历对比子节点\"><a href=\"#遍历对比子节点\" class=\"headerlink\" title=\"遍历对比子节点\"></a>遍历对比子节点</h4><p>遍历对比子节点的策略有两个：一是只比较同层级的节点，二是给节点加上 key 属性。它们的目的都是降低空间复杂度。代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 对比子节点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">diffChild</span>(<span class=\"params\">oldDom, newVdom</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> keyed = &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> children = []</span><br><span class=\"line\">  <span class=\"keyword\">const</span> oldChildNodes = oldDom.childNodes</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; oldChildNodes.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldChildNodes[i].key) &#123; <span class=\"comment\">// 将含有 key 的节点存进对象 keyed</span></span><br><span class=\"line\">      keyed[oldChildNodes[i].key] = oldChildNodes[i]</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;                    <span class=\"comment\">// 将不含有 key 的节点存进数组 children</span></span><br><span class=\"line\">      children.push(oldChildNodes[i])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> newChildNodes = newVdom.children</span><br><span class=\"line\">  <span class=\"keyword\">let</span> child</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; newChildNodes.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (keyed[newChildNodes[i].key]) &#123;  <span class=\"comment\">// 对应上面存在 key 的情形</span></span><br><span class=\"line\">      child = keyed[newChildNodes[i].key]</span><br><span class=\"line\">      keyed[newChildNodes[i].key] = <span class=\"literal\">undefined</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;                            <span class=\"comment\">// 对应上面不存在 key 的情形</span></span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; children.length; j++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isSameNodeType(children[i], newChildNodes[i])) &#123; <span class=\"comment\">// 如果不存在 key，则优先找到节点类型相同的元素</span></span><br><span class=\"line\">          child = children[i]</span><br><span class=\"line\">          children[i] = <span class=\"literal\">undefined</span></span><br><span class=\"line\">          <span class=\"keyword\">break</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    diff(child, newChildNodes[i]) <span class=\"comment\">// 递归比较</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h3><p>在生命周期的小节中，componentWillReceiveProps 方法还未跑通，稍加修改 setProps 函数即可：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 更改属性，componentWillMount 和 componentWillReceiveProps 方法</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">setProps</span>(<span class=\"params\">component, attributes</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (attributes) &#123;</span><br><span class=\"line\">    component.props = attributes <span class=\"comment\">// 这段逻辑对应上文自定义组件比较中新老组件相同时 setProps 的逻辑</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (component &amp;&amp; component.base &amp;&amp; component.componentWillReceiveProps) &#123;</span><br><span class=\"line\">    component.componentWillReceiveProps(component.props)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (component &amp;&amp; component.componentWillMount) &#123;</span><br><span class=\"line\">    component.componentWillMount()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>来测试下生命周期小节中最后的测试用例：</p>\n<ul>\n<li>生命周期测试</li>\n</ul>\n<p><img src=\"http://with.muyunyun.cn/react%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%B5%8B%E8%AF%951.gif\" alt=\"\"></p>\n<ul>\n<li>diff 测试</li>\n</ul>\n<p><img src=\"http://with.muyunyun.cn/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9Fdiff%E6%B5%8B%E8%AF%951.gif\" alt=\"\"></p>\n<h3 id=\"鸣谢\"><a href=\"#鸣谢\" class=\"headerlink\" title=\"鸣谢\"></a>鸣谢</h3><p>Especially thank <a href=\"https://github.com/hujiulong/simple-react\" target=\"_blank\" rel=\"noopener\">simple-react</a> for the guidance function of this library. At the meantime，respect for <a href=\"https://github.com/developit/preact\" target=\"_blank\" rel=\"noopener\">preact</a> and <a href=\"https://github.com/facebook/react\" target=\"_blank\" rel=\"noopener\">react</a></p>\n","categories":["React"],"tags":["React"]},{"title":"从 0 到 1 实现 React 系列 —— 5.PureComponent 实现 && HOC 探幽","url":"/posts/92dc08c6/","content":"<p><img src=\"http://with.muyunyun.cn/9c461a61924ed0fecb6024a256671251.jpg-muyy\" alt=\"\"></p>\n<p>本系列文章在实现一个 cpreact 的同时帮助大家理顺 React 框架的核心内容(JSX/虚拟DOM/组件/生命周期/diff算法/setState/PureComponent/HOC/…) <a href=\"https://github.com/MuYunyun/cpreact\" target=\"_blank\" rel=\"noopener\">项目地址</a></p>\n<a id=\"more\"></a>\n\n<ul>\n<li><a href=\"https://github.com/MuYunyun/blog/issues/24\" target=\"_blank\" rel=\"noopener\">从 0 到 1 实现 React 系列 —— JSX 和 Virtual DOM</a></li>\n<li><a href=\"https://github.com/MuYunyun/blog/issues/25\" target=\"_blank\" rel=\"noopener\">从 0 到 1 实现 React 系列 —— 组件和 state|props</a></li>\n<li><a href=\"https://github.com/MuYunyun/blog/issues/26\" target=\"_blank\" rel=\"noopener\">从 0 到 1 实现 React 系列 —— 生命周期和 diff 算法</a></li>\n<li><a href=\"https://github.com/MuYunyun/blog/issues/27\" target=\"_blank\" rel=\"noopener\">从 0 到 1 实现 React 系列 —— 优化 setState 和 ref 的实现</a></li>\n<li><a href=\"https://github.com/MuYunyun/blog/issues/29\" target=\"_blank\" rel=\"noopener\">从 0 到 1 实现 React 系列 —— PureComponent 实现 &amp;&amp; HOC 探幽</a></li>\n</ul>\n<h3 id=\"PureComponent-精髓\"><a href=\"#PureComponent-精髓\" class=\"headerlink\" title=\"PureComponent 精髓\"></a>PureComponent 精髓</h3><p>使用 PureComponent 是优化 React 性能的一种常用手段，相较于 Component, PureComponent 会在 render 之前自动执行一次 shouldComponentUpdate() 函数，根据返回的 bool 值判断是否进行 render。其中有个重点是 PureComponent 在 shouldComponentUpdate() 的时候会进行 shallowEqual(浅比较)。</p>\n<p>PureComponent 的浅比较策略如下：</p>\n<p>对 prevState/nextState 以及 prevProps/nextProps 这两组数据进行浅比较：</p>\n<p>1.对象第一层数据未发生改变，render 方法不会触发；<br>2.对象第一层数据发生改变(包括第一层数据引用的改变)，render 方法会触发;</p>\n<h4 id=\"PureComponent-的实现\"><a href=\"#PureComponent-的实现\" class=\"headerlink\" title=\"PureComponent 的实现\"></a>PureComponent 的实现</h4><p>照着上述思路我们来实现 PureComponent 的逻辑</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">PureComponent</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.props = props || &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.state = &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  isShouldComponentUpdate.call(<span class=\"keyword\">this</span>) <span class=\"comment\">// 为每个 PureComponent 绑定 shouldComponentUpdate 方法</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">PureComponent.prototype.setState = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">updater, cb</span>) </span>&#123;</span><br><span class=\"line\">  isShouldComponentUpdate.call(<span class=\"keyword\">this</span>) <span class=\"comment\">// 调用 setState 时，让 this 指向子类的实例，目的取到子类的 this.state</span></span><br><span class=\"line\">  asyncRender(updater, <span class=\"keyword\">this</span>, cb)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isShouldComponentUpdate</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> cpState = <span class=\"keyword\">this</span>.state</span><br><span class=\"line\">  <span class=\"keyword\">const</span> cpProps = <span class=\"keyword\">this</span>.props</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.shouldComponentUpdate = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">nextProps, nextState</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!shallowEqual(cpState, nextState) || !shallowEqual(cpProps, nextProps)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">true</span>  <span class=\"comment\">// 只要 state 或 props 浅比较不等的话，就进行渲染</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span> <span class=\"comment\">// 浅比较相等的话，不渲染</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 浅比较逻辑</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> shallowEqual = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">oldState, nextState</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> oldKeys = <span class=\"built_in\">Object</span>.keys(oldState)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> newKeys = <span class=\"built_in\">Object</span>.keys(nextState)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (oldKeys.length !== newKeys.length) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> flag = <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; oldKeys.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!nextState.hasOwnProperty(oldKeys[i])) &#123;</span><br><span class=\"line\">      flag = <span class=\"literal\">false</span></span><br><span class=\"line\">      <span class=\"keyword\">break</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nextState[oldKeys[i]] !== oldState[oldKeys[i]]) &#123;</span><br><span class=\"line\">      flag = <span class=\"literal\">false</span></span><br><span class=\"line\">      <span class=\"keyword\">break</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> flag</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"测试用例\"><a href=\"#测试用例\" class=\"headerlink\" title=\"测试用例\"></a>测试用例</h4><p>测试用例用 在 React 上提的一个 <a href=\"https://github.com/facebook/react/issues/13438#issuecomment-414128918\" target=\"_blank\" rel=\"noopener\">issue</a> 中的案例，我们期望点击增加按钮后，页面上显示的值能够加 1。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> <span class=\"keyword\">extends</span> <span class=\"title\">PureComponent</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(props) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(props)</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = &#123;</span><br><span class=\"line\">      count: <span class=\"number\">0</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.click = <span class=\"keyword\">this</span>.click.bind(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  click() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">      count: ++<span class=\"keyword\">this</span>.state.count,</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;button onClick=&#123;<span class=\"keyword\">this</span>.click&#125;&gt;增加&lt;<span class=\"regexp\">/button&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        &lt;div&gt;&#123;this.state.count&#125;&lt;/</span>div&gt;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    )</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>然而，我们点击上述代码，页面上显示的 0 分毫不动！！！</p>\n<p>揭秘如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">click() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> t = ++<span class=\"keyword\">this</span>.state.count</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(t === <span class=\"keyword\">this</span>.state.count) <span class=\"comment\">// true</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">    count: t,</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当点击增加按钮，控制台显示 <code>t === this.state.count</code> 为 true, 也就说明了 setState 前后的状态是统一的，所以 shallowEqual(浅比较) 返回的是 true，致使 shouldComponentUpdate 返回了 false，页面因此没有渲染。</p>\n<p>类似的，如下写法也是达不到目标的，留给读者思考了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">click() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">    count: <span class=\"keyword\">this</span>.state.count++,</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那么如何达到我们期望的目标呢。揭秘如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">click() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">    count: <span class=\"keyword\">this</span>.state.count + <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>感悟：小小的一行代码里蕴藏着无数的 bug。</p>\n<h3 id=\"HOC-实践\"><a href=\"#HOC-实践\" class=\"headerlink\" title=\"HOC 实践\"></a>HOC 实践</h3><p>高阶组件(Higher Order Component) 不属于 React API 范畴，但是它在 React 中也是一种实用的技术，<code>它可以将常见任务抽象成一个可重用的部分</code>。这个小节算是番外篇，会结合 <a href=\"https://github.com/MuYunyun/cpreact\" target=\"_blank\" rel=\"noopener\">cpreact</a>(前文实现的类 react 轮子) 与 HOC 进行相关的实践。</p>\n<p>它可以用如下公式表示：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">y = f(x),</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// x：原有组件</span></span><br><span class=\"line\"><span class=\"comment\">// y：高阶组件</span></span><br><span class=\"line\"><span class=\"comment\">// f()：</span></span><br></pre></td></tr></table></figure>\n\n<p><code>f()</code> 的实现有两种方法，下面进行实践。</p>\n<h4 id=\"属性代理-Props-Proxy\"><a href=\"#属性代理-Props-Proxy\" class=\"headerlink\" title=\"属性代理(Props Proxy)\"></a>属性代理(Props Proxy)</h4><p>这类实现也是装饰器模式的一种运用，通过装饰器函数给原来函数赋能。下面例子在装饰器函数中给被装饰的组件传递了额外的属性 { a: 1, b: 2 }。</p>\n<blockquote>\n<p>声明：下文所展示的 demo 均已在 <a href=\"https://github.com/MuYunyun/cpreact\" target=\"_blank\" rel=\"noopener\">cpreact</a> 测试通过</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ppHOC</span>(<span class=\"params\">WrappedComponent</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> obj = &#123; <span class=\"attr\">a</span>: <span class=\"number\">1</span>, <span class=\"attr\">b</span>: <span class=\"number\">2</span> &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        &lt;WrappedComponent &#123; ...this.props &#125; &#123; ...obj &#125; /&gt;</span><br><span class=\"line\">      )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@ppHOC</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &#123; <span class=\"keyword\">this</span>.props.a + <span class=\"keyword\">this</span>.props.b &#125; &#123; <span class=\"comment\">/* 输出 3 */</span> &#125;</span><br><span class=\"line\">      &lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    )</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>要是将 { a: 1, b: 2 } 替换成全局共享对象，那么不就是 react-redux 中的 Connect 了么?</p>\n<p>改进上述 demo，我们就可以实现可插拔的<a href=\"https://reactjs.org/docs/forms.html#controlled-components\" target=\"_blank\" rel=\"noopener\">受控组件</a>，代码示意如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ppDecorate</span>(<span class=\"params\">WrappedComponent</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">super</span>()</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.state = &#123;</span><br><span class=\"line\">        value: <span class=\"string\">''</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.onChange = <span class=\"keyword\">this</span>.onChange.bind(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    onChange(e) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.setState(&#123;</span><br><span class=\"line\">        value: e.target.value</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">        onChange: <span class=\"keyword\">this</span>.onChange,</span><br><span class=\"line\">        value: <span class=\"keyword\">this</span>.state.value,</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        &lt;WrappedComponent &#123; ...this.props &#125; &#123; ...obj &#125; /&gt;</span><br><span class=\"line\">      )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@ppDecorate</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;input &#123; ...this.props &#125; /&gt;</span><br><span class=\"line\">        &lt;div&gt;&#123; <span class=\"keyword\">this</span>.props.value &#125;&lt;<span class=\"regexp\">/div&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;/</span>div&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>效果如下图：</p>\n<p><img src=\"http://with.muyunyun.cn/hoc%E6%8E%A2%E7%B4%A2%E4%B9%8B%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6.gif\" alt=\"\"></p>\n<p>这里有个坑点，当我们在输入框输入字符的时候，并不会立马触发 onChange 事件(我们想要让事件立即触发，然而现在要按下回车键或者点下鼠标才触发)，在 react 中有个<a href=\"https://reactjs.org/docs/events.html\" target=\"_blank\" rel=\"noopener\">合成事件</a> 的知识点，下篇文章会进行探究。</p>\n<p>顺带一提在这个 demo 中似乎看到了双向绑定的效果，但是实际中 React 并没有双向绑定的概念，但是我们可以运用 HOC 的知识点结合 setState 在 React 表单中实现伪双向绑定的效果。</p>\n<h4 id=\"继承反转-Inheritance-Inversion\"><a href=\"#继承反转-Inheritance-Inversion\" class=\"headerlink\" title=\"继承反转(Inheritance Inversion)\"></a>继承反转(Inheritance Inversion)</h4><p>继承反转的核心是：传入 HOC 的组件会作为返回类的父类来使用。然后在 render 中调用 <code>super.render()</code> 来调用父类的 render 方法。</p>\n<blockquote>\n<p>在 <a href=\"https://github.com/MuYunyun/blog/blob/master/BasicSkill/readES6/继承.md#作为对象调用的-super\" target=\"_blank\" rel=\"noopener\">《ES6 继承与 ES5 继承的差异》</a>中我们提到了作为对象使用的 super 指向父类的实例。</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">iiHOC</span>(<span class=\"params\">WrappedComponent</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"keyword\">extends</span> <span class=\"title\">WrappedComponent</span> </span>&#123;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> parentRender = <span class=\"keyword\">super</span>.render()</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (parentRender.nodeName === <span class=\"string\">'span'</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (</span><br><span class=\"line\">          &lt;span&gt;继承反转&lt;<span class=\"regexp\">/span&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">        )</span></span><br><span class=\"line\"><span class=\"regexp\">      &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">    &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">  &#125;</span></span><br><span class=\"line\"><span class=\"regexp\">&#125;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">@iiHOC</span></span><br><span class=\"line\"><span class=\"regexp\">class B extends Component &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">  render() &#123;</span></span><br><span class=\"line\"><span class=\"regexp\">    return (</span></span><br><span class=\"line\"><span class=\"regexp\">      &lt;span&gt;Inheritance Inversion&lt;/</span>span&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在这个 demo 中，在 HOC 内实现了渲染劫持，页面上最终显示如下：</p>\n<p><img src=\"http://with.muyunyun.cn/e7dbedcefd9a61dcd12fbcff89dc19ef.jpg-200\" alt=\"\"></p>\n<blockquote>\n<p>可能会有疑惑，使用<code>属性代理</code>的方式貌似也能实现渲染劫持呀，但是那样做没有<code>继承反转</code>这种方式纯粹。</p>\n</blockquote>\n<h3 id=\"鸣谢\"><a href=\"#鸣谢\" class=\"headerlink\" title=\"鸣谢\"></a>鸣谢</h3><p>Especially thank <a href=\"https://github.com/hujiulong/simple-react\" target=\"_blank\" rel=\"noopener\">simple-react</a> for the guidance function of this library. At the meantime，respect for <a href=\"https://github.com/developit/preact\" target=\"_blank\" rel=\"noopener\">preact</a> and <a href=\"https://github.com/facebook/react\" target=\"_blank\" rel=\"noopener\">react</a></p>\n<h3 id=\"相关链接\"><a href=\"#相关链接\" class=\"headerlink\" title=\"相关链接\"></a>相关链接</h3><ul>\n<li><a href=\"https://github.com/facebook/react/issues/13438\" target=\"_blank\" rel=\"noopener\">A doubt behaviour using the PureComponent</a></li>\n<li><a href=\"https://juejin.im/post/59cdaaccf265da066f6ac83b\" target=\"_blank\" rel=\"noopener\">React 的性能优化（一）当 PureComponent 遇上 ImmutableJS</a></li>\n<li><a href=\"https://juejin.im/post/5b1caceb5188257d63226743\" target=\"_blank\" rel=\"noopener\">React性能优化方案之PureComponent</a></li>\n<li><a href=\"https://juejin.im/post/59818a485188255694568ff2\" target=\"_blank\" rel=\"noopener\">带着三个问题深入浅出React高阶组件</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/24776678?refer=FrontendMagazine\" target=\"_blank\" rel=\"noopener\">深入理解 React 高阶组件</a></li>\n</ul>\n","categories":["React"],"tags":["React"]},{"title":"从 JavaScript 到 TypeScript","url":"/posts/66a54fc2/","content":"<p><img src=\"http://with.muyunyun.cn/5e7b640325806920160f538d7c50f5d7.jpg-muyy\" alt=\"\"></p>\n<blockquote>\n<p>文中的案例代码已经上传到 <a href=\"https://github.com/MuYunyun/TypeScript\" target=\"_blank\" rel=\"noopener\">TypeScript</a></p>\n</blockquote>\n<p>TypeScript 并不是一个完全新的语言, 它是 JavaScript 的超集，为 JavaScript 的生态增加了类型机制，并最终将代码编译为纯粹的 JavaScript 代码。</p>\n<a id=\"more\"></a>\n<h2 id=\"TypeScript-简介\"><a href=\"#TypeScript-简介\" class=\"headerlink\" title=\"TypeScript 简介\"></a>TypeScript 简介</h2><p>TypeScript 由 Microsoft(算上 Angular 2 的话加上 Google)开发和维护的一种开源编程语言。 它支持 JavaScript 的所有语法和语义，同时通过作为 ECMAScript 的超集来提供一些额外的功能，如类型检测和更丰富的语法。下图显示了 TypeScript 与 ES5，ES2015，ES2016 之间的关系。</p>\n<p><img src=\"http://with.muyunyun.cn/da62039bf146c2ebd615ef1d11a1a808.jpg\" alt=\"\"></p>\n<h2 id=\"使用-TypeScript-的原因\"><a href=\"#使用-TypeScript-的原因\" class=\"headerlink\" title=\"使用 TypeScript 的原因\"></a>使用 TypeScript 的原因</h2><p>JavaScript 是一门弱类型语言，变量的数据类型具有动态性，只有执行时才能确定变量的类型，这种后知后觉的认错方法会让开发者成为调试大师，但无益于编程能力的提升，还会降低开发效率。TypeScript 的类型机制可以有效杜绝由变量类型引起的误用问题，而且开发者可以控制对类型的监控程度，是严格限制变量类型还是宽松限制变量类型，都取决于开发者的开发需求。添加类型机制之后，副作用主要有两个：增大了开发人员的学习曲线，增加了设定类型的开发时间。总体而言，这些付出相对于代码的健壮性和可维护性，都是值得的。</p>\n<p>此外，类型注释是 TypeScript 的内置功能之一，允许文本编辑器和 IDE 可以对我们的代码执行更好的静态分析。 这意味着我们可以通过自动编译工具的帮助，在编写代码时减少错误，从而提高我们的生产力。</p>\n<p>对 TypeScript 的简介到此，接下来对其特有的知识点进行简单概括总结，(网上很多教程实际上把 ES6， ES7 的知识点也算进 ts 的知识点了，当然这没错~)</p>\n<h2 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h2><h3 id=\"String-类型\"><a href=\"#String-类型\" class=\"headerlink\" title=\"String 类型\"></a>String 类型</h3><p>一个保存字符串的文本，类型声明为 string。可以发现类型声明可大写也可小写，后文同理。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> name: <span class=\"built_in\">string</span> = <span class=\"string\">'muyy'</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> name2: <span class=\"built_in\">String</span> = <span class=\"string\">'muyy'</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Boolen-类型\"><a href=\"#Boolen-类型\" class=\"headerlink\" title=\"Boolen 类型\"></a>Boolen 类型</h3><p>boolean是 true 或 false 的值，所以 <code>let isBool3: boolean = new Boolean(1)</code> 就会编译报错，因为 new Boolean(1) 生成的是一个 Bool 对象。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> isBool1: <span class=\"built_in\">boolean</span> = <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Number-类型\"><a href=\"#Number-类型\" class=\"headerlink\" title=\"Number 类型\"></a>Number 类型</h3><figure class=\"highlight ts\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> <span class=\"built_in\">number</span>: <span class=\"built_in\">number</span> = <span class=\"number\">10</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Array-类型\"><a href=\"#Array-类型\" class=\"headerlink\" title=\"Array 类型\"></a>Array 类型</h3><p>数组是 Array 类型。然而，因为数组是一个集合，我们还需要指定在数组中的元素的类型。我们通过 <code>Array&lt;type&gt;</code> or <code>type[]</code> 语法为数组内的元素指定类型</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr:<span class=\"built_in\">number</span>[] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> arr2:<span class=\"built_in\">Array</span>&lt;<span class=\"built_in\">number</span>&gt; = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> arr3:<span class=\"built_in\">string</span>[] = [<span class=\"string\">\"1\"</span>,<span class=\"string\">\"2\"</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> arr4:<span class=\"built_in\">Array</span>&lt;<span class=\"built_in\">string</span>&gt; = [<span class=\"string\">\"1\"</span>,<span class=\"string\">\"2\"</span>];</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Enums-类型\"><a href=\"#Enums-类型\" class=\"headerlink\" title=\"Enums 类型\"></a>Enums 类型</h3><p>列出所有可用值，一个枚举的默认初始值是0。你可以调整一开始的范围：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> Role &#123;Employee = <span class=\"number\">3</span>, Manager, Admin&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> role: Role = Role.Employee</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(role) <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Any-类型\"><a href=\"#Any-类型\" class=\"headerlink\" title=\"Any 类型\"></a>Any 类型</h3><p>any 是默认的类型，其类型的变量允许任何类型的值：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> notSure:<span class=\"built_in\">any</span> = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> notSure2:<span class=\"built_in\">any</span>[] = [<span class=\"number\">1</span>,<span class=\"string\">\"2\"</span>,<span class=\"literal\">false</span>];</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Void-类型\"><a href=\"#Void-类型\" class=\"headerlink\" title=\"Void 类型\"></a>Void 类型</h3><p>JavaScript 没有空值 Void 的概念，在 TypeScirpt 中，可以用 void 表示没有任何返回值的函数：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">alertName</span>(<span class=\"params\"></span>): <span class=\"title\">void</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'My name is muyy'</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h2><h3 id=\"为函数定义类型\"><a href=\"#为函数定义类型\" class=\"headerlink\" title=\"为函数定义类型\"></a>为函数定义类型</h3><p>我们可以给每个参数添加类型之后再为函数本身添加返回值类型。 TypeScript能够根据返回语句自动推断出返回值类型，因此我们通常省略它。下面函数 add, add2, add3 的效果是一样的，其中是 add3 函数是函数完整类型。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">x: <span class=\"built_in\">string</span>, y: <span class=\"built_in\">string</span></span>): <span class=\"title\">string</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"Hello TypeScript\"</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> add2 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x: <span class=\"built_in\">string</span>, y: <span class=\"built_in\">string</span></span>): <span class=\"title\">string</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"Hello TypeScript\"</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> add3: <span class=\"function\">(<span class=\"params\">x: <span class=\"built_in\">string</span>, y: <span class=\"built_in\">string</span></span>) =&gt;</span> <span class=\"built_in\">string</span> = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x: <span class=\"built_in\">string</span>, y: <span class=\"built_in\">string</span></span>): <span class=\"title\">string</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"Hello TypeScript\"</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"可选参数和默认参数\"><a href=\"#可选参数和默认参数\" class=\"headerlink\" title=\"可选参数和默认参数\"></a>可选参数和默认参数</h3><p>JavaScript 里，每个参数都是可选的，可传可不传。 没传参的时候，它的值就是 undefined 。 在 TypeScript 里我们可以在参数名旁使用?实现可选参数的功能。 比如，我们想让 lastname 是可选的：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">buildName</span>(<span class=\"params\">firstName: <span class=\"built_in\">string</span>, lastname?: <span class=\"built_in\">string</span></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(lastname ? firstName + <span class=\"string\">\"\"</span> + lastname : firstName)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> res1 = buildName(<span class=\"string\">\"鸣\"</span>,<span class=\"string\">\"人\"</span>); <span class=\"comment\">// 鸣人</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> res2 = buildName(<span class=\"string\">\"鸣\"</span>); <span class=\"comment\">// 鸣</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> res3 = buildName(<span class=\"string\">\"鸣\"</span>, <span class=\"string\">\"人\"</span>, <span class=\"string\">\"君\"</span>); <span class=\"comment\">// Supplied parameters do not match any signature of call target.</span></span><br></pre></td></tr></table></figure>\n<p>如果带默认值的参数出现在必须参数前面，用户必须明确的传入 undefined 值来获得默认值。 例如，我们重写上例子，让 firstName 是带默认值的参数：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">buildName2</span>(<span class=\"params\">firstName = \"鸣\", lastName?: <span class=\"built_in\">string</span></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(firstName + <span class=\"string\">\"\"</span> + lastName)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> res4 = buildName2(<span class=\"string\">\"人\"</span>); <span class=\"comment\">// undefined人</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> res5 = buildName2(<span class=\"literal\">undefined</span>, <span class=\"string\">\"人\"</span>); <span class=\"comment\">// 鸣人</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"类\"><a href=\"#类\" class=\"headerlink\" title=\"类\"></a>类</h2><p>传统的JavaScript程序使用函数和基于原型的继承来创建可重用的组件，但对于熟悉使用面向对象方式的程序员来讲就有些棘手，因为他们用的是基于类的继承并且对象是由类构建出来的。 从ECMAScript 2015，也就是ECMAScript 6开始，JavaScript程序员将能够使用基于类的面向对象的方式。 使用TypeScript，我们允许开发者现在就使用这些特性，并且编译后的JavaScript可以在所有主流浏览器和平台上运行，而不需要等到下个JavaScript版本。</p>\n<h3 id=\"类-1\"><a href=\"#类-1\" class=\"headerlink\" title=\"类\"></a>类</h3><figure class=\"highlight ts\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Person&#123;</span><br><span class=\"line\">    name:<span class=\"built_in\">string</span>; <span class=\"comment\">// 这个是对后文this.name类型的定义</span></span><br><span class=\"line\">    age:<span class=\"built_in\">number</span>;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(<span class=\"params\">name:<span class=\"built_in\">string</span>,age:<span class=\"built_in\">number</span></span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    print()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name + <span class=\"keyword\">this</span>.age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> person:Person = <span class=\"keyword\">new</span> Person(<span class=\"string\">'muyy'</span>,<span class=\"number\">23</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person.print()) <span class=\"comment\">// muyy23</span></span><br></pre></td></tr></table></figure>\n<p>我们在引用任何一个类成员的时候都用了 this。 它表示我们访问的是类的成员。其实这本质上还是 ES6 的知识，只是在 ES6 的基础上多上了对 this 字段和引用参数的类型声明。</p>\n<h3 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h3><figure class=\"highlight ts\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Person&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> name:<span class=\"built_in\">string</span>;  <span class=\"comment\">// public、private、static 是 typescript 中的类访问修饰符</span></span><br><span class=\"line\">    age:<span class=\"built_in\">number</span>;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(<span class=\"params\">name:<span class=\"built_in\">string</span>,age:<span class=\"built_in\">number</span></span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    tell()&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name + <span class=\"keyword\">this</span>.age);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> Student <span class=\"keyword\">extends</span> Person&#123;</span><br><span class=\"line\">    gender:<span class=\"built_in\">string</span>;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(<span class=\"params\">gender:<span class=\"built_in\">string</span></span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(<span class=\"string\">\"muyy\"</span>,<span class=\"number\">23</span>);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.gender = gender;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    tell()&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name + <span class=\"keyword\">this</span>.age + <span class=\"keyword\">this</span>.gender);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> student = <span class=\"keyword\">new</span> Student(<span class=\"string\">\"male\"</span>);</span><br><span class=\"line\">student.tell();  <span class=\"comment\">// muyy23male</span></span><br></pre></td></tr></table></figure>\n<p>这个例子展示了 TypeScript 中继承的一些特征，可以看到其实也是 ES6 的知识上加上类型声明。不过这里多了一个知识点 —— 公共，私有，以及受保护的修饰符。TypeScript 里，成员默认为 public ；当成员被标记成 private 时，它就不能在声明它的类的外部访问；protected 修饰符与private 修饰符的行为很相似，但有一点不同，protected 成员在派生类中仍然可以访问。</p>\n<h3 id=\"存储器\"><a href=\"#存储器\" class=\"headerlink\" title=\"存储器\"></a>存储器</h3><p>TypeScript 支持通过 getters/setters 来截取对对象成员的访问。 它能帮助你有效的控制对对象成员的访问。</p>\n<p>对于存取器有下面几点需要注意的：<br>首先，存取器要求你将编译器设置为输出 ECMAScript 5 或更高。 不支持降级到 ECMAScript 3。 其次，只带有 get 不带有 set 的存取器自动被推断为 readonly。 这在从代码生成 .d.ts 文件时是有帮助的，因为利用这个属性的用户会看到不允许够改变它的值。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Hello&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> _name: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> _age: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">    <span class=\"keyword\">get</span> name(): <span class=\"built_in\">string</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>._name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">set</span> name(value: <span class=\"built_in\">string</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._name = value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">get</span> age(): <span class=\"built_in\">number</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>._age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">set</span> age(age: <span class=\"built_in\">number</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(age&gt;<span class=\"number\">0</span> &amp;&amp; age&lt;<span class=\"number\">100</span>)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">\"年龄在0-100之间\"</span>); <span class=\"comment\">// 年龄在0-100之间</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._age = age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> hello = <span class=\"keyword\">new</span> Hello();</span><br><span class=\"line\">hello.name = <span class=\"string\">\"muyy\"</span>;</span><br><span class=\"line\">hello.age = <span class=\"number\">23</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(hello.name); <span class=\"comment\">// muyy</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h2><h3 id=\"接口-1\"><a href=\"#接口-1\" class=\"headerlink\" title=\"接口\"></a>接口</h3><p>TypeScript的核心原则之一是对值所具有的结构进行类型检查。在TypeScript里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> LabelValue&#123;</span><br><span class=\"line\">    label: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">printLabel</span>(<span class=\"params\">labelObj: LabelValue</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(labelObj.label);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> myObj = &#123;</span><br><span class=\"line\">    <span class=\"string\">\"label\"</span>:<span class=\"string\">\"hello Interface\"</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">printLabel(myObj);</span><br></pre></td></tr></table></figure>\n<p>LabelledValue 接口就好比一个名字，它代表了有一个 label 属性且类型为 string 的对象。只要传入的对象满足上述必要条件，那么它就是被允许的。</p>\n<p>另外，类型检查器不会去检查属性的顺序，只要相应的属性存在并且类型也是对的就可以。</p>\n<h3 id=\"可选属性\"><a href=\"#可选属性\" class=\"headerlink\" title=\"可选属性\"></a>可选属性</h3><p>带有可选属性的接口与普通的接口定义差不多，只是在可选属性名字定义的后面加一个 ? 符号。可选属性的好处之一是可以对可能存在的属性进行预定义，好处之二是可以捕获引用了不存在的属性时的错误。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Person&#123;</span><br><span class=\"line\">    name?:<span class=\"built_in\">string</span>;</span><br><span class=\"line\">    age?:<span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">printInfo</span>(<span class=\"params\">info:Person</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(info);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> info = &#123;</span><br><span class=\"line\">    <span class=\"string\">\"name\"</span>:<span class=\"string\">\"muyy\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"age\"</span>:<span class=\"number\">23</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">printInfo(info); <span class=\"comment\">// &#123;\"name\": \"muyy\", \"age\": 23&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> info2 = &#123;</span><br><span class=\"line\">    <span class=\"string\">\"name\"</span>:<span class=\"string\">\"muyy\"</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">printInfo(info2); <span class=\"comment\">// &#123;\"name\": \"muyy\"&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"函数类型\"><a href=\"#函数类型\" class=\"headerlink\" title=\"函数类型\"></a>函数类型</h3><p>接口能够描述 JavaScript 中对象拥有的各种各样的外形。 除了描述带有属性的普通对象外，接口也可以描述函数类型。定义的函数类型接口就像是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型。定义后完成后，我们可以像使用其它接口一样使用这个函数类型的接口。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> SearchFunc&#123;</span><br><span class=\"line\">    (source: <span class=\"built_in\">string</span>, subString: <span class=\"built_in\">string</span>): <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> mySearch: SearchFunc;</span><br><span class=\"line\">mySearch = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">source: <span class=\"built_in\">string</span>,subString: <span class=\"built_in\">string</span></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> source.search(subString) !== <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(mySearch(<span class=\"string\">\"鸣人\"</span>,<span class=\"string\">\"鸣\"</span>)); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(mySearch(<span class=\"string\">\"鸣人\"</span>,<span class=\"string\">\"缨\"</span>)); <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"可索引类型\"><a href=\"#可索引类型\" class=\"headerlink\" title=\"可索引类型\"></a>可索引类型</h3><p>与使用接口描述函数类型差不多，我们也可以描述那些能够“通过索引得到”的类型，比如 <code>a[10]</code> 或 <code>ageMap[&quot;daniel&quot;]</code>。 可索引类型具有一个索引签名，它描述了对象索引的类型，还有相应的索引返回值类型。 让我们看如下例子：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> StringArray&#123;</span><br><span class=\"line\">    [index: <span class=\"built_in\">number</span>]: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> MyArray: StringArray;</span><br><span class=\"line\">MyArray = [<span class=\"string\">\"是\"</span>,<span class=\"string\">\"云\"</span>,<span class=\"string\">\"随\"</span>,<span class=\"string\">\"风\"</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(MyArray[<span class=\"number\">2</span>]); <span class=\"comment\">// 随</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"类类型\"><a href=\"#类类型\" class=\"headerlink\" title=\"类类型\"></a>类类型</h3><p>与 C# 或 Java 里接口的基本作用一样，TypeScript 也能够用它来明确的强制一个类去符合某种契约。</p>\n<p>我们可以在接口中描述一个方法，在类里实现它，如同下面的 <code>setTime</code> 方法一样：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> ClockInterface&#123;</span><br><span class=\"line\">    currentTime: <span class=\"built_in\">Date</span>;</span><br><span class=\"line\">    setTime(d: <span class=\"built_in\">Date</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> Clock <span class=\"keyword\">implements</span> ClockInterface&#123;</span><br><span class=\"line\">    currentTime: <span class=\"built_in\">Date</span>;</span><br><span class=\"line\">    setTime(d: <span class=\"built_in\">Date</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.currentTime = d;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(<span class=\"params\">h: <span class=\"built_in\">number</span>, m: <span class=\"built_in\">number</span></span>) &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"继承接口\"><a href=\"#继承接口\" class=\"headerlink\" title=\"继承接口\"></a>继承接口</h3><p>和类一样，接口也可以相互继承。 这让我们能够从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> Shape&#123;</span><br><span class=\"line\">    color: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> PenStroke&#123;</span><br><span class=\"line\">    penWidth: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">interface</span> Square <span class=\"keyword\">extends</span> Shape,PenStroke&#123;</span><br><span class=\"line\">    sideLength: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> s = &lt;Square&gt;&#123;&#125;;</span><br><span class=\"line\">s.color = <span class=\"string\">\"blue\"</span>;</span><br><span class=\"line\">s.penWidth = <span class=\"number\">100</span>;</span><br><span class=\"line\">s.sideLength = <span class=\"number\">10</span>;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"模块\"><a href=\"#模块\" class=\"headerlink\" title=\"模块\"></a>模块</h2><p>TypeScript 与 ECMAScript 2015 一样，任何包含顶级 import 或者 export 的文件都被当成一个模块。</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">interface</span> StringValidator&#123;</span><br><span class=\"line\">    isAcceptable(s:<span class=\"built_in\">string</span>): <span class=\"built_in\">boolean</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> strReg = <span class=\"regexp\">/^[A-Za-z]+$/</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> numReg = <span class=\"regexp\">/^[0-9]+$/</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> letterValidator <span class=\"keyword\">implements</span> StringValidator&#123;</span><br><span class=\"line\">    isAcceptable(s:<span class=\"built_in\">string</span>): <span class=\"built_in\">boolean</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> strReg.test(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> zipCode <span class=\"keyword\">implements</span> StringValidator&#123;</span><br><span class=\"line\">    isAcceptable(s: <span class=\"built_in\">string</span>): <span class=\"built_in\">boolean</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> s.length == <span class=\"number\">5</span> &amp;&amp; numReg.test(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"泛型\"><a href=\"#泛型\" class=\"headerlink\" title=\"泛型\"></a>泛型</h2><p>软件工程中，我们不仅要创建一致的定义良好的 API ，同时也要考虑可重用性。 组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能。<br>在像 C# 和 Java 这样的语言中，可以使用泛型来创建可重用的组件，一个组件可以支持多种类型的数据。 这样用户就可以以自己的数据类型来使用组件。</p>\n<h3 id=\"初探泛型\"><a href=\"#初探泛型\" class=\"headerlink\" title=\"初探泛型\"></a>初探泛型</h3><p>如下代码，我们给 Hello 函数添加了类型变量 T ，T 帮助我们捕获用户传入的类型（比如：string）。我们把这个版本的 Hello 函数叫做泛型，因为它可以适用于多个类型。 代码中 <code>output</code> 和 <code>output2</code> 是效果是相同的，第二种方法更加普遍，利用了类型推论 —— 即编译器会根据传入的参数自动地帮助我们确定T的类型：</p>\n<figure class=\"highlight ts\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Hello</span>&lt;<span class=\"title\">T</span>&gt;(<span class=\"params\">arg:T</span>):<span class=\"title\">T</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arg;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> outPut = Hello&lt;<span class=\"built_in\">string</span>&gt;(<span class=\"string\">'Hello Generic'</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> output2 = Hello(<span class=\"string\">'Hello Generic'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(outPut);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(outPut2);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://www.gitbook.com/book/zhongsp/typescript-handbook/details\" target=\"_blank\" rel=\"noopener\">TypeScript 中文文档</a></li>\n<li><a href=\"http://pinggod.com/2016/Typescript/\" target=\"_blank\" rel=\"noopener\">TypeScript</a></li>\n<li><a href=\"http://naywinmyint.com/typescript-for-angular-2-part-1/\" target=\"_blank\" rel=\"noopener\">TypeScript for Angular 2 - Part 1 (An Introduction)</a></li>\n</ul>\n","categories":["TypeScript"],"tags":["JavaScript","TypeScript"]},{"title":"你不知道的 requestIdleCallback","url":"/posts/ba7c84ae/","content":"<p><img src=\"http://with.muyunyun.cn/7558dee9cbc163226d4a821596c00245.jpg-muyy\" alt=\"\"></p>\n<p>本文副标题是 <code>Request Schedule 源码解析一</code>。在本章中会介绍 <code>requestIdleCallback</code> 的用法以及其缺陷, 接着对 React 团队对该 api 的 hack 部分的源码进行剖析。在下一篇中会结合优先级对 React 的调度算法进行宏观的解释, 欢迎关注<a href=\"https://github.com/MuYunyun/blog\" target=\"_blank\" rel=\"noopener\">个人博客</a>。</p>\n<a id=\"more\"></a>\n\n<p><code>React 调度算法</code> 与 <code>requestIdleCallback</code> 这个 api 息息相关。<code>requestIdleCallback</code> 的作用是是在浏览器一帧的剩余空闲时间内执行优先度相对较低的任务, 其用法如下:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> tasksNum = <span class=\"number\">10000</span></span><br><span class=\"line\"></span><br><span class=\"line\">requestIdleCallback(unImportWork)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">unImportWork</span>(<span class=\"params\">deadline</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (deadline.timeRemaining() &amp;&amp; tasksNum &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`执行了<span class=\"subst\">$&#123;<span class=\"number\">10000</span> - tasksNum + <span class=\"number\">1</span>&#125;</span>个任务`</span>)</span><br><span class=\"line\">    tasksNum--</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (tasksNum &gt; <span class=\"number\">0</span>) &#123; <span class=\"comment\">// 在未来的帧中继续执行</span></span><br><span class=\"line\">    requestIdleCallback(unImportWork)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>deadline</code> 有两个参数</p>\n<ul>\n<li><code>timeRemaining()</code>: 当前帧还剩下多少时间</li>\n<li><code>didTimeout</code>: 是否超时</li>\n</ul>\n<p>另外 <code>requestIdleCallback</code> 后如果跟上第二个参数 <code>{timeout: ...}</code> 则会强制浏览器在当前帧执行完后执行。</p>\n<h3 id=\"requestIdleCallback-的缺陷\"><a href=\"#requestIdleCallback-的缺陷\" class=\"headerlink\" title=\"requestIdleCallback 的缺陷\"></a>requestIdleCallback 的缺陷</h3><blockquote>\n<p>requestIdleCallback is called only 20 times per second - Chrome on my 6x2 core Linux machine, it’s not really useful for UI work。—— from <a href=\"https://github.com/facebook/react/issues/13206#issuecomment-418923831\" target=\"_blank\" rel=\"noopener\">Releasing Suspense</a></p>\n</blockquote>\n<p>也就是说 <code>requestIdleCallback</code> 的 FPS 只有 <code>20</code>, 这远远低于页面流畅度的要求！(一般 FPS 为 60 时对用户来说是感觉流程的, 即一帧时间为 16.7 ms), 这也是 React 需要自己实现 <code>requestIdleCallback</code> 的原因。</p>\n<h3 id=\"源码解析之-requestIdleCallback\"><a href=\"#源码解析之-requestIdleCallback\" class=\"headerlink\" title=\"源码解析之 requestIdleCallback\"></a>源码解析之 requestIdleCallback</h3><h4 id=\"非-DOM-环境\"><a href=\"#非-DOM-环境\" class=\"headerlink\" title=\"非 DOM 环境\"></a>非 DOM 环境</h4><p>在不能操作 DOM 的环境下, 可以借助 <code>setTimeout</code> 来模拟 <code>requestIdleCallback</code> 的实现。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">requestIdleCallback = <span class=\"function\">(<span class=\"params\">callback</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  setTimeout(callback(&#123;</span><br><span class=\"line\">    timeRemaining() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">Infinity</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>下面将 React 源码中关于服务端的实现也呈现出来:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> _callback = <span class=\"literal\">null</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> _flushCallback = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">didTimeout</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (_callback !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      _callback(didTimeout);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">      _callback = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">requestHostCallback = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">cb</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (_callback !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果 _callback 不为空, 则将 requestHostCallback 放到下一个事件队列中再次执行</span></span><br><span class=\"line\">    setTimeout(requestHostCallback, <span class=\"number\">0</span>, cb);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    _callback = cb;</span><br><span class=\"line\">    setTimeout(_flushCallback, <span class=\"number\">0</span>, <span class=\"literal\">false</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">cancelHostCallback = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  _callback = <span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">shouldYieldToHost = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"DOM-环境\"><a href=\"#DOM-环境\" class=\"headerlink\" title=\"DOM 环境\"></a>DOM 环境</h4><p>在浏览器端的环境下, 介绍一个与 <code>requestIdleCallback</code> 功能相近的 api —— <code>requestAnimationFrame(callback)</code>, 其会在下次重绘前执行指定的回调函数，因此这个 api 在动效领域得到了广泛的使用。下面通过一个简单的 demo 来认识它:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> frame</span><br><span class=\"line\"><span class=\"keyword\">let</span> n = <span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">callback</span>(<span class=\"params\">timeStamp</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(timeStamp) <span class=\"comment\">// 开始执行回调的时间戳</span></span><br><span class=\"line\">\t<span class=\"comment\">// 如果想要产生循环动画的效果, 需在回调函数中再次调用 requestAnimationFrame()</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (n &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    requestAnimationFrame(callback)</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'测试执行顺序'</span>)</span><br><span class=\"line\">\t\tn--</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">frame = requestAnimationFrame(callback) <span class=\"comment\">// 在下次重绘之前调用回调</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 如果想要销毁该回调, 可以执行 cancelAnimationFrame(frame)</span></span><br></pre></td></tr></table></figure>\n\n<p>执行上述代码, 控制台(chrome)打印如下数据:</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"code\"><pre><span class=\"line\">先输出 <span class=\"number\">5</span> 次 <span class=\"string\">'测试执行顺序'</span></span><br><span class=\"line\"><span class=\"number\">1795953.649</span></span><br><span class=\"line\"><span class=\"number\">1795970.318</span></span><br><span class=\"line\"><span class=\"number\">1795986.987</span></span><br><span class=\"line\"><span class=\"number\">1796003.656</span></span><br><span class=\"line\"><span class=\"number\">1796020.325</span></span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>可以看到在浏览器上一帧的时间大致为 <code>16ms</code>。同时可以看到 <code>requestAnimation(callback)</code> 中的 callback 也是异步的(只不过它是基于帧与帧间的异步), 所以上述打印结果是先打印出 5 次 ‘测试执行顺序’ 后再依次打印出 5 个时间戳。</p>\n<p><code>requestHostCallback</code>(也就是 requestIdleCallback) 这部分源码的实现比较复杂, 可以将其分解为以下几个重要的步骤(有一些细节点可以看注释):</p>\n<ol>\n<li>步骤一: 如果有优先级更高的任务, 则通过 <code>postMessage</code> 触发步骤四, 否则如果 <code>requestAnimationFrame</code> 在当前帧没有安排任务, 则开始一个帧的流程;</li>\n<li>步骤二: 在一个帧的流程中调用 <code>requestAnimationFrameWithTimeout</code> 函数, 该函数调用了 <code>requestAnimationFrame</code>, 并对执行时间超过 <code>100ms</code> 的任务用 <code>setTimeout</code> 放到下一个事件队列中处理;</li>\n<li>步骤三: 执行 <code>requestAnimationFrame</code> 中的回调函数 <code>animationTick</code>, 在该回调函数中得到当前帧的截止时间 <code>frameDeadline</code>, 并通过 <code>postMessage</code> 触发步骤四;</li>\n<li>步骤四: 通过 <code>onmessage</code> 接受 <code>postMessage</code> 指令, 触发消息事件的执行。在 <code>onmessage</code> 函数中根据 <code>frameDeadline - currentTime &lt;= 0</code> 判断任务是否可以在当前帧执行，如果可以的话执行该任务, 否则进入下一帧的调用。</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">let</span> requestHostCallback;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">let</span> cancelHostCallback;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">let</span> shouldYieldToHost;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">let</span> getCurrentTime;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> ANIMATION_FRAME_TIMEOUT = <span class=\"number\">100</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> rAFID;</span><br><span class=\"line\"><span class=\"keyword\">let</span> rAFTimeoutID;</span><br><span class=\"line\"><span class=\"comment\">// ② 调用 requestAnimationFrame, 并对执行时间超过 100 ms 的任务用 setTimeout 进行处理</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> requestAnimationFrameWithTimeout = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">callback</span>) </span>&#123;</span><br><span class=\"line\">  rAFID = requestAnimationFrame(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">timestamp</span>) </span>&#123;</span><br><span class=\"line\">    clearTimeout(rAFTimeoutID);</span><br><span class=\"line\">    callback(timestamp); <span class=\"comment\">// 一帧中任务调用的核心流程的实现, 接着看第 ③ 步</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"comment\">// 如果在一帧中某个任务执行时间超过 100 ms 则终止该帧的执行并将该任务放入下一个事件队列中</span></span><br><span class=\"line\">  rAFTimeoutID = setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    cancelAnimationFrame(rAFID);</span><br><span class=\"line\">    callback(getCurrentTime());</span><br><span class=\"line\">  &#125;, ANIMATION_FRAME_TIMEOUT);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">getCurrentTime = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> performance.now();</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> scheduledHostCallback = <span class=\"literal\">null</span>; <span class=\"comment\">// 调度器回调函数</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> isMessageEventScheduled = <span class=\"literal\">false</span>; <span class=\"comment\">// 消息事件是否执行</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> timeoutTime = <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> isAnimationFrameScheduled = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> isFlushingHostCallback = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> frameDeadline = <span class=\"number\">0</span>; <span class=\"comment\">// 当前帧的截止时间</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 假设最开始的 FPS(feet per seconds) 为 30, 但这个值会随着动画帧调用的频率而动态变化</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> previousFrameTime = <span class=\"number\">33</span>; <span class=\"comment\">// 一帧的时间: 1000 / 30 ≈ 33</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> activeFrameTime = <span class=\"number\">33</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">shouldYieldToHost = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> frameDeadline &lt;= getCurrentTime();</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> channel = <span class=\"keyword\">new</span> MessageChannel();</span><br><span class=\"line\"><span class=\"keyword\">const</span> port = channel.port2;</span><br><span class=\"line\"><span class=\"comment\">// ④ 接受 `postMessage` 指令, 触发消息事件的执行。在其中判断任务是否在当前帧执行，如果在的话执行该任务</span></span><br><span class=\"line\">channel.port1.onmessage = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">  isMessageEventScheduled = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> prevScheduledCallback = scheduledHostCallback;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> prevTimeoutTime = timeoutTime;</span><br><span class=\"line\">  scheduledHostCallback = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  timeoutTime = <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> currentTime = getCurrentTime();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> didTimeout = <span class=\"literal\">false</span>; <span class=\"comment\">// 是否超时</span></span><br><span class=\"line\">  <span class=\"comment\">// 如果当前帧已经没有时间剩余, 检查是否有 timeout 参数，如果有的话是否已经超过这个时间</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (frameDeadline - currentTime &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (prevTimeoutTime !== <span class=\"number\">-1</span> &amp;&amp; prevTimeoutTime &lt;= currentTime) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// didTimeout 为 true 后, 在当前帧中执行(针对优先级较高的任务)</span></span><br><span class=\"line\">      didTimeout = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 在下一帧中执行</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!isAnimationFrameScheduled) &#123;</span><br><span class=\"line\">        isAnimationFrameScheduled = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        requestAnimationFrameWithTimeout(animationTick);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      scheduledHostCallback = prevScheduledCallback;</span><br><span class=\"line\">      timeoutTime = prevTimeoutTime;</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (prevScheduledCallback !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    isFlushingHostCallback = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      prevScheduledCallback(didTimeout);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">      isFlushingHostCallback = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ③ requestAnimationFrame 的回调函数。传入的 rafTime 为执行该帧的时间戳。</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> animationTick = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">rafTime</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 如果存在调度器回调函数则在一帧的开头急切地安排下一帧的动画回调(急切是因为如果在帧的后半段安排动画回调的话, 就会增大下一帧超过 100ms 的几率, 从而会浪费一个帧的利用, 可以结合步骤②来理解这句话), 如果不存在调度器回调函数否则立马终止执行。</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (scheduledHostCallback !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    requestAnimationFrameWithTimeout(animationTick);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    isAnimationFrameScheduled = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> nextFrameTime = rafTime - frameDeadline + activeFrameTime; <span class=\"comment\">// 当前帧开始调用动画的时间 - 上一帧调用动画的截止时间 + 当前帧执行的时间，这里的 nextFrameTime 仅仅是临时变量</span></span><br><span class=\"line\">  <span class=\"comment\">// 如果连续两帧的时间都小于当前帧的时间, 则说明得调高 FPS</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (nextFrameTime &lt; activeFrameTime &amp;&amp; previousFrameTime &lt; activeFrameTime) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 将 activeFrameTime 的值减小相当于调高 FPS。同时取 nextFrameTime 与 previousFrameTime 中较大的一个以让前后两帧都不出问题。</span></span><br><span class=\"line\">    activeFrameTime =</span><br><span class=\"line\">      nextFrameTime &lt; previousFrameTime ? previousFrameTime : nextFrameTime;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    previousFrameTime = nextFrameTime;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  frameDeadline = rafTime + activeFrameTime; <span class=\"comment\">// 当前帧的截止时间(上面几行代码的目的是得到该 frameDeadline 值, 该值在 postMessage 会用来判断)</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!isMessageEventScheduled) &#123;</span><br><span class=\"line\">    isMessageEventScheduled = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    port.postMessage(<span class=\"literal\">undefined</span>); <span class=\"comment\">// 最后进入第④步, 通过 postMessage 触发消息事件。</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// DOM 环境下 requestIdleCallback 的实现, 这里第二个参数在最新的 requestIdleCallback 中因为对象类型</span></span><br><span class=\"line\">requestHostCallback = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">callback, absoluteTimeout</span>) </span>&#123;</span><br><span class=\"line\">  scheduledHostCallback = callback; <span class=\"comment\">// 这里的 callback 为调度器回调函数</span></span><br><span class=\"line\">  timeoutTime = absoluteTimeout;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (isFlushingHostCallback || absoluteTimeout &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 针对优先级较高的任务不等下一个帧，在当前帧通过 postMessage 尽快执行</span></span><br><span class=\"line\">    port.postMessage(<span class=\"literal\">undefined</span>);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!isAnimationFrameScheduled) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ① 如果 rAF 在当前帧没有安排任务, 则开始一个帧的流程</span></span><br><span class=\"line\">    isAnimationFrameScheduled = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    requestAnimationFrameWithTimeout(animationTick);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">cancelHostCallback = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  scheduledHostCallback = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  isMessageEventScheduled = <span class=\"literal\">false</span>;</span><br><span class=\"line\">  timeoutTime = <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"相关资料\"><a href=\"#相关资料\" class=\"headerlink\" title=\"相关资料\"></a>相关资料</h3><ul>\n<li><a href=\"https://github.com/facebook/react/blob/master/packages/scheduler/src/forks/SchedulerHostConfig.default.js\" target=\"_blank\" rel=\"noopener\">requestIdleCallback polyful</a></li>\n</ul>\n","categories":["React"],"tags":["React","Schedule"]},{"title":"使用 React 全家桶搭建一个后台管理系统","url":"/posts/9bfbdbf4/","content":"<p><img src=\"http://with.muyunyun.cn/007a8b596b798249ed85d11307c959cb.jpg-muyy\" alt=\"\"></p>\n<p>使用React技术栈搭建一个后台管理系统最初是为了上手公司的业务，后来发现这个项目还能把平时遇到的有趣的demo给整合进去。此文尝试对相关的技术栈以及如何在该项目中引人Redux进行分析。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"项目地址以及局部展示\"><a href=\"#项目地址以及局部展示\" class=\"headerlink\" title=\"项目地址以及局部展示\"></a>项目地址以及局部展示</h2><ul>\n<li><p><a href=\"https://github.com/MuYunyun/reactSPA\" target=\"_blank\" rel=\"noopener\">项目地址</a></p>\n</li>\n<li><p>小模块展示：<br><img src=\"http://files.cnblogs.com/files/MuYunyun/reactSPA.gif\" alt=\"\"></p>\n</li>\n<li><p>redux在项目中的运用demo展示<br><img src=\"http://files.cnblogs.com/files/MuYunyun/todoList.gif\" alt=\"\"></p>\n</li>\n</ul>\n<h2 id=\"项目目录结构\"><a href=\"#项目目录结构\" class=\"headerlink\" title=\"项目目录结构\"></a>项目目录结构</h2><figure class=\"highlight routeros\"><table><tr><td class=\"code\"><pre><span class=\"line\">├── build.js                   项目打包后的文件</span><br><span class=\"line\">├──<span class=\"built_in\"> config </span>                    webpack配置文件</span><br><span class=\"line\">│   ├──<span class=\"built_in\">..</span>.</span><br><span class=\"line\">│   ├──webpack.config.dev.js   开发环境配置</span><br><span class=\"line\">│   ├──webpack.config.prod.js  生产环境配置</span><br><span class=\"line\">├── node_modules               node模块目录</span><br><span class=\"line\">├── public</span><br><span class=\"line\">│   └──index.html</span><br><span class=\"line\">├── scripts</span><br><span class=\"line\">│   ├── build.js               打包项目文件</span><br><span class=\"line\">│   ├── start.js               启动项目文件</span><br><span class=\"line\">│   └── test.js                测试项目文件</span><br><span class=\"line\">├── src</span><br><span class=\"line\">│   ├──<span class=\"built_in\"> client </span>                汇聚(入口)目录</span><br><span class=\"line\">│   ├── common                 核心目录</span><br><span class=\"line\">│   │   ├── actions            redux中的action</span><br><span class=\"line\">│   │   ├── components         通用功能组件</span><br><span class=\"line\">│   │   ├── container          通用样式组件</span><br><span class=\"line\">│   │   ├── images</span><br><span class=\"line\">│   │   ├── pages              页面模块</span><br><span class=\"line\">│   │   ├── reducers           redux中的reducer</span><br><span class=\"line\">│   │   ├── utils              工具类</span><br><span class=\"line\">│   │   │   ├── config.js      通用配置</span><br><span class=\"line\">│   │   │   ├── menu.js        菜单配置</span><br><span class=\"line\">│   │   │   └── ajax.js        ajax模块(日后用到)</span><br><span class=\"line\">│   │   └── routes.js          前端路由</span><br><span class=\"line\">│   └──<span class=\"built_in\"> server </span>                服务端目录(日后用到)</span><br><span class=\"line\">│       └── controller</span><br><span class=\"line\">├── .gitignore</span><br><span class=\"line\">├── package.json</span><br><span class=\"line\">├── README.md</span><br><span class=\"line\">└── yarn.lock</span><br></pre></td></tr></table></figure>\n<p>项目的初始结构和构造原因已罗列如上，由于过些日子会引人ts，所以项目结构必然还会改动，但肯定基于这基本雏形扩展的。</p>\n<p>下面对目录结构作以下说明</p>\n<ul>\n<li>项目最初始是用 <a href=\"https://github.com/facebookincubator/create-react-app\" target=\"_blank\" rel=\"noopener\">create-react-app</a> 初始化的，create-react-app 是Facebook官方提供的 React 脚手架，也是业界最优秀的 React 应用开发工具之一;</li>\n<li>client 作为入口目录，到时候可以把第三方中间件也放在此处;</li>\n<li>container 和 components 存放的都是 react 组件,区别如下表。但是我把和样式有关的组件就放在container中，把和功能有关的模块(比如自己分装的表格组件、弹出输入框组件等)就放到components中，若日后有需要，container 和 component 组件都是可以在 Redux 数据流中的。</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"center\"></th>\n<th align=\"center\">container</th>\n<th align=\"center\">component</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">目的</td>\n<td align=\"center\">如何工作(数据获取,状态更新)</td>\n<td align=\"center\">如何显示(样式，布局)</td>\n</tr>\n<tr>\n<td align=\"center\">是否在 Redux 数据流中</td>\n<td align=\"center\">是</td>\n<td align=\"center\">否</td>\n</tr>\n<tr>\n<td align=\"center\">读取数据</td>\n<td align=\"center\">从 Redux 获取 state</td>\n<td align=\"center\">从 props 获取数据</td>\n</tr>\n<tr>\n<td align=\"center\">修改数据</td>\n<td align=\"center\">向 Redux 派发 actions</td>\n<td align=\"center\">从 props 调用回调函数</td>\n</tr>\n<tr>\n<td align=\"center\">实现方式</td>\n<td align=\"center\">向react-redux生成</td>\n<td align=\"center\">手写</td>\n</tr>\n<tr>\n<td align=\"center\">* ajax 模块到时候计划用 fetch 封装一个ajax，感觉使用 fetch 还是蛮便利的。</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">* server 层就是作为网关层，日后计划用来写 node 的。</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n<h2 id=\"技术栈相关\"><a href=\"#技术栈相关\" class=\"headerlink\" title=\"技术栈相关\"></a>技术栈相关</h2><p>虽然用到的技术栈众多，但是自己也谈不上熟练运用，多半是边查API边用的，所以只罗列些自己用相关的技术栈解决的点;</p>\n<h3 id=\"webpack-2-x\"><a href=\"#webpack-2-x\" class=\"headerlink\" title=\"webpack(2.x)\"></a>webpack(2.x)</h3><p>4月的时候 create-react-app 还是基于 webpack(1.x) 构建的，5月27号升到了webpack(2.6),于是我也进行了 webpack 的版本升级。</p>\n<h4 id=\"按需加载\"><a href=\"#按需加载\" class=\"headerlink\" title=\"按需加载\"></a>按需加载</h4><p><a href=\"https://github.com/ant-design/babel-plugin-import\" target=\"_blank\" rel=\"noopener\">babel-plugin-import</a> 是一个用于按需加载组件代码和样式的 babel 插件，使用此插件后，在引人 antd 相应模块就能实现按需引人，在config/webpack.config.dev.js 文件中作如下修改:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">        test: <span class=\"regexp\">/\\.(js|jsx)$/</span>,</span><br><span class=\"line\">        include: paths.appSrc,</span><br><span class=\"line\">        loader: <span class=\"built_in\">require</span>.resolve(<span class=\"string\">'babel-loader'</span>),</span><br><span class=\"line\">        options: &#123;</span><br><span class=\"line\">          plugins: [</span><br><span class=\"line\">            <span class=\"string\">\"transform-decorators-legacy\"</span>,  <span class=\"comment\">// 引人 ES7 的装饰器 @</span></span><br><span class=\"line\">            [<span class=\"string\">'import'</span>, [&#123; <span class=\"attr\">libraryName</span>: <span class=\"string\">'antd'</span>, <span class=\"attr\">style</span>: <span class=\"literal\">true</span> &#125;]],</span><br><span class=\"line\">          ],</span><br><span class=\"line\">          cacheDirectory: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">      &#125;,</span><br></pre></td></tr></table></figure>\n<h4 id=\"引人less\"><a href=\"#引人less\" class=\"headerlink\" title=\"引人less\"></a>引人less</h4><p>首先引人 <a href=\"https://github.com/webpack-contrib/less-loader\" target=\"_blank\" rel=\"noopener\">less-loader</a> 来加载 less 样式，同时修改 config/webpack.config.dev.js 文件</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">  test: <span class=\"regexp\">/\\.less$/</span>,</span><br><span class=\"line\">  use: [</span><br><span class=\"line\">    <span class=\"built_in\">require</span>.resolve(<span class=\"string\">'style-loader'</span>),</span><br><span class=\"line\">    <span class=\"built_in\">require</span>.resolve(<span class=\"string\">'css-loader'</span>),</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      loader: <span class=\"built_in\">require</span>.resolve(<span class=\"string\">'postcss-loader'</span>),</span><br><span class=\"line\">      options: &#123;</span><br><span class=\"line\">        ident: <span class=\"string\">'postcss'</span>, <span class=\"comment\">//https://webpack.js.org/guides/migrating/#complex-options</span></span><br><span class=\"line\">        plugins: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> [</span><br><span class=\"line\">          <span class=\"built_in\">require</span>(<span class=\"string\">'postcss-flexbugs-fixes'</span>),</span><br><span class=\"line\">          autoprefixer(&#123;</span><br><span class=\"line\">            browsers: [</span><br><span class=\"line\">              <span class=\"string\">'&gt;1%'</span>,</span><br><span class=\"line\">              <span class=\"string\">'last 4 versions'</span>,</span><br><span class=\"line\">              <span class=\"string\">'Firefox ESR'</span>,</span><br><span class=\"line\">              <span class=\"string\">'not ie &lt; 9'</span>, <span class=\"comment\">// React doesn't support IE8 anyway</span></span><br><span class=\"line\">            ],</span><br><span class=\"line\">            flexbox: <span class=\"string\">'no-2009'</span>,</span><br><span class=\"line\">          &#125;),</span><br><span class=\"line\">        ],</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      loader: <span class=\"built_in\">require</span>.resolve(<span class=\"string\">'less-loader'</span>),</span><br><span class=\"line\">      options: &#123;</span><br><span class=\"line\">        modifyVars: &#123; <span class=\"string\">\"@primary-color\"</span>: <span class=\"string\">\"#1DA57A\"</span> &#125;,  <span class=\"comment\">// 这里利用了 less-loader 的 modifyVars 来进行主题配置， 变量和其他配置方式可以参考 [配置主题](https://ant.design/docs/react/customize-theme-cn) 文档。</span></span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  ],</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n<h4 id=\"一键发布到-gh-pages\"><a href=\"#一键发布到-gh-pages\" class=\"headerlink\" title=\"一键发布到 gh-pages\"></a>一键发布到 gh-pages</h4><p>用到了 <a href=\"https://github.com/tschaub/gh-pages\" target=\"_blank\" rel=\"noopener\">gh-pages</a> ,使用 npm run deploy 一键发布到自己的gh-pages上，姑且把gh-pages当成生产环境吧，所以在修改config/webpack.config.dev.js 文件的同时也要对 config/webpack.config.prod.js 作出一模一样的修改。</p>\n<h4 id=\"引用路径的缩写\"><a href=\"#引用路径的缩写\" class=\"headerlink\" title=\"引用路径的缩写\"></a>引用路径的缩写</h4><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">alias: &#123;</span><br><span class=\"line\">      <span class=\"string\">'react-native'</span>: <span class=\"string\">'react-native-web'</span>,</span><br><span class=\"line\">      components: path.resolve(__dirname, <span class=\"string\">'..'</span>) + <span class=\"string\">'/src/common/components'</span>,</span><br><span class=\"line\">      container: path.resolve(__dirname, <span class=\"string\">'..'</span>) + <span class=\"string\">'/src/common/container'</span>,</span><br><span class=\"line\">      images: path.resolve(__dirname, <span class=\"string\">'..'</span>) + <span class=\"string\">'/src/common/images'</span>,</span><br><span class=\"line\">      pages: path.resolve(__dirname, <span class=\"string\">'..'</span>) + <span class=\"string\">'/src/common/pages'</span>,</span><br><span class=\"line\">      utils: path.resolve(__dirname, <span class=\"string\">'..'</span>) + <span class=\"string\">'/src/common/utils'</span>,</span><br><span class=\"line\">      data: path.resolve(__dirname, <span class=\"string\">'..'</span>) + <span class=\"string\">'/src/server/data'</span>,</span><br><span class=\"line\">      actions: path.resolve(__dirname, <span class=\"string\">'..'</span>) + <span class=\"string\">'/src/common/actions'</span>,</span><br><span class=\"line\">      reducers: path.resolve(__dirname, <span class=\"string\">'..'</span>) + <span class=\"string\">'/src/common/reducers'</span>,</span><br><span class=\"line\">    &#125;,</span><br></pre></td></tr></table></figure>\n<p>配置了引用路径的缩写后，就可以在任意地方如这样引用，比如</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Table <span class=\"keyword\">from</span> <span class=\"string\">'components/table'</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"Antd-2-x\"><a href=\"#Antd-2-x\" class=\"headerlink\" title=\"Antd(2.x)\"></a>Antd(2.x)</h3><p>antd是（蚂蚁金服体验技术部）经过大量的项目实践和总结，沉淀出的一个中台设计语言 Ant Design，使用者包括蚂蚁金服、阿里巴巴、口碑、美团、滴滴等一系列知名公司，而且我从他们的<a href=\"https://ant.design/docs/spec/introduce-cn\" target=\"_blank\" rel=\"noopener\">设计理念</a>也学到了很多关于UI、UX的知识。<br>该项目采用的是antd最新的版本2.10.0,由于2.x的版本和1.x的版本还是相差蛮大的，之前参考的项目(基于1.x)改起来太费劲，所以在组件那块就干脆自己重新封装了一遍。这部分知识点建议多看文档，官方更新还是非常勤快的。</p>\n<h3 id=\"React-router-4-x\"><a href=\"#React-router-4-x\" class=\"headerlink\" title=\"React-router(4.x)\"></a>React-router(4.x)</h3><p>react-router 4.x和2.x的差异又是特别的大，召唤<a href=\"https://reacttraining.com/react-router/web/guides/quick-start\" target=\"_blank\" rel=\"noopener\">文档</a>,网上基本上都还是2.x的教程，看过文档之后，反正简而言之其就是要让使用者更容易上手。印象最深的是以前嵌套路由写法在4.x中写到同层了。如下示例他们的效果是相同的。</p>\n<p>2.x:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;Route path=<span class=\"string\">\"/\"</span> component=&#123;App&#125;&gt;</span><br><span class=\"line\">    &lt;Route path=<span class=\"string\">\"/aaaa\"</span> component=&#123;AAAA&#125; /&gt;</span><br><span class=\"line\">    &lt;Route path=<span class=\"string\">\"/bbbb\"</span> component=&#123;BBBB&#125; /&gt;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/Route&gt;</span></span><br></pre></td></tr></table></figure>\n<p>4.x:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;Route path=<span class=\"string\">\"/\"</span> component=&#123;App&#125; /&gt;</span><br><span class=\"line\">&lt;Route path=<span class=\"string\">\"/aaaa\"</span> component=&#123;AAAA&#125; /&gt;</span><br><span class=\"line\">&lt;Route path=<span class=\"string\">\"/bbbb\"</span> component=&#123;BBBB&#125; /&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Fetch\"><a href=\"#Fetch\" class=\"headerlink\" title=\"Fetch\"></a>Fetch</h3><p>fetch 使用比较简单，基本的 promise 用法如下</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">fetch(url).then(<span class=\"function\"><span class=\"params\">response</span> =&gt;</span> response.json())</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"params\">data</span> =&gt;</span> <span class=\"built_in\">console</span>.log(data))</span><br><span class=\"line\">  .catch(<span class=\"function\"><span class=\"params\">e</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Oops, error\"</span>, e))</span><br></pre></td></tr></table></figure>\n<p>此外还能这样用</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> response = <span class=\"keyword\">await</span> fetch(url);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> data = <span class=\"keyword\">await</span> response.json();</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(data);</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span>(e) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Oops, error\"</span>, e);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但是其简洁的特点是为了让我们可以自定义其扩展，还是其本身就还不完善呢？我在调用 JSONP 的请求时，发现其不支持对 JSONP 的调用，所幸社区还是很给力地找到了 <a href=\"https://www.npmjs.com/package/fetch-jsonp\" target=\"_blank\" rel=\"noopener\">fetch-jsonp</a> 这个模块，实现了对百度音乐接口调用。fetch-jsonp使用也和 fetch 类似，代码如下</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">fetchJsonp(url,&#123;<span class=\"attr\">method</span>: <span class=\"string\">'GET'</span>&#125;)</span><br><span class=\"line\">　　.then(<span class=\"function\">(<span class=\"params\">res</span>) =&gt;</span>res.json())</span><br><span class=\"line\">　　.then(<span class=\"function\">(<span class=\"params\">data</span>) =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Redux\"><a href=\"#Redux\" class=\"headerlink\" title=\"Redux\"></a>Redux</h3><p>使用了redux也已经有段时日了，我对redux的定义就是更好的管理组件的状态，一旦应用的逻辑复杂起来，各种组件状态、界面耦合起来，就容易出岔子，redux就是为了解决这个而诞生的，让我们可以更多地关注UI层，而降低对状态的关注。</p>\n<p><img src=\"http://with.muyunyun.cn/a40c3540ca26a56b28506d14125c04c1.jpg-400\" alt=\"\"></p>\n<p>画了一幅比较简陋的图来说明 redux 的大致流程，假设首先通过鼠标点击页面上的按钮触发了一个行为(action)，这时我们叫了一辆出租车 dispatch() 将这个 action 带到了终点站 store。这时候 store 就会通过 reducer 函数返回一个新的状态 state，从而改变 UI 显示。之前也写了篇<a href=\"http://www.cnblogs.com/MuYunyun/p/6530715.html\" target=\"_blank\" rel=\"noopener\">深入Redux架构</a></p>\n<p>下面通过把 <a href=\"https://github.com/MuYunyun/todoList\" target=\"_blank\" rel=\"noopener\">代办事项</a> 这个demo运用到后台管理系统中来讲解 Redux 在其中的运用。</p>\n<p>首先，在入口目录创建 store</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> store = createStore(rootReducer)</span><br><span class=\"line\"></span><br><span class=\"line\">ReactDOM.render(</span><br><span class=\"line\">  &lt;Provider store=&#123;store&#125;&gt;</span><br><span class=\"line\">    &#123; routes &#125;</span><br><span class=\"line\">  &lt;<span class=\"regexp\">/Provider&gt;,</span></span><br><span class=\"line\"><span class=\"regexp\">  document.getElementById('root')</span></span><br><span class=\"line\"><span class=\"regexp\">);</span></span><br></pre></td></tr></table></figure>\n<p>接着，我使用了 <a href=\"https://github.com/acdlite/redux-actions\" target=\"_blank\" rel=\"noopener\">redux-actions</a> 这个模块。使用 redux-actions 的好处是能简化大量对 action 的声明，以及能简化 reducer 的写法。</p>\n<p>代办事项的 actions 文件片段(拿展示全部任务、已完成任务、未完成任务的 action 举例):</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; createAction &#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux-actions'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> setVisibility = createAction(<span class=\"string\">'SET_VISIBILITY'</span>)</span><br></pre></td></tr></table></figure>\n<p>没使用 redux-actions 时，actions 写法如下，可看出着实麻烦了不少，</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> setVisibility = <span class=\"function\">(<span class=\"params\">filter</span>) =&gt;</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">\t\ttype: <span class=\"string\">\"SET_VISIBILITY\"</span>,</span><br><span class=\"line\">\t\tfilter</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>相应的代办事项的 reducers 文件片段:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> setVisibility = handleActions(&#123;</span><br><span class=\"line\">  <span class=\"string\">'SET_VISIBILITY'</span>(state, action) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123; ...state, ...action.payload&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;, <span class=\"string\">'SHOW_ALL'</span>)</span><br></pre></td></tr></table></figure>\n<p>使用 redux-actions 后，只要进行如下调用,reducers文件里的<code>SET_VISIBILITY</code>的 action 就能捕获到<code>SHOW_ALL</code>这个状态。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; setVisibility &#125; <span class=\"keyword\">from</span> <span class=\"string\">'actions/todoList'</span></span><br><span class=\"line\">@connect(</span><br><span class=\"line\">    (state) =&gt; (&#123;</span><br><span class=\"line\">        setVisibility: state.setVisibility, <span class=\"comment\">// 这个 setVisibility 是取自 reducers 的</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">dispatch(<span class=\"keyword\">this</span>.props.dispatch(setVisibility(<span class=\"string\">'SHOW_ALL'</span>)))</span><br></pre></td></tr></table></figure>\n<p>connect 来自 <a href=\"https://github.com/reactjs/react-redux\" target=\"_blank\" rel=\"noopener\">react-redux</a>，这里的 @ 是 ES7里的装饰器的用法，使用它之后又能减少不少的代码量，原来还要写 <code>mapStateToProps</code>、<code>mapDispatchToProps</code>。</p>\n<h2 id=\"项目的一些扩展计划\"><a href=\"#项目的一些扩展计划\" class=\"headerlink\" title=\"项目的一些扩展计划\"></a>项目的一些扩展计划</h2><p>计划在该项目把平时工作、学习中遇到的react案例抽离成demo展现出来，所以以后还会多出一些模块。另外过段时间会在该项目中引人 typescript，如果还有精力的话，可以在这个项目上折腾下网关层。喜欢这个项目的话，<a href=\"https://github.com/MuYunyun/reactSPA\" target=\"_blank\" rel=\"noopener\">点我 Star</a>。</p>\n","categories":["React"],"tags":["React","Redux"]},{"title":"函数式编程入门","url":"/posts/8b09c168/","content":"<p><img src=\"http://with.muyunyun.cn/aca1db3dd5aaabfbc4351181d1a39df6.jpg-muyy\" alt=\"\"></p>\n<p>该系列会有 3 篇文章，分别介绍什么是函数式编程、剖析函数式编程库、以及函数式编程在 React 中的应用，欢迎关注我的 <a href=\"https://github.com/MuYunyun/blog\" target=\"_blank\" rel=\"noopener\">blog</a></p>\n<a id=\"more\"></a>\n\n<h3 id=\"命令式编程和声明式编程\"><a href=\"#命令式编程和声明式编程\" class=\"headerlink\" title=\"命令式编程和声明式编程\"></a>命令式编程和声明式编程</h3><p>拿泡茶这个事例进行区分命令式编程和声明式编程</p>\n<ul>\n<li>命令式编程</li>\n</ul>\n<p>1.烧开水(为第一人称)<br>2.拿个茶杯<br>3.放茶叶<br>4.冲水</p>\n<ul>\n<li>声明式编程</li>\n</ul>\n<p>1.给我泡杯茶(为第二人称)</p>\n<p>举个 demo</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 命令式编程</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> convert = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> result = []</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class=\"line\">    result[i] = arr[i].toLowerCase()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 声明式编程</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> convert = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr.map(<span class=\"function\"><span class=\"params\">r</span> =&gt;</span> r.toLowerCase())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"什么是函数式编程\"><a href=\"#什么是函数式编程\" class=\"headerlink\" title=\"什么是函数式编程\"></a>什么是函数式编程</h3><p>函数式编程是声明式编程的范式。在函数式编程中数据在由纯函数组成的管道中传递。</p>\n<blockquote>\n<p>函数式编程可以用简单如<code>交换律、结合律、分配律</code>的数学之法来帮我们简化代码的实现。</p>\n</blockquote>\n<p>它具有如下一些特性:</p>\n<ul>\n<li>纯粹性: 纯函数不改变除当前作用域以外的值;</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 反面示例</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> add = <span class=\"function\">(<span class=\"params\">b</span>) =&gt;</span> a = a + b <span class=\"comment\">// 两次 add(1) 结果不一致</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 正确示例</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> add = <span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a + b</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>数据不可变性: Immutable</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 反面示例</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>]</span><br><span class=\"line\"><span class=\"keyword\">const</span> arrAdd = <span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  arr.push(value)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">arrAdd(<span class=\"number\">3</span>) <span class=\"comment\">// [1, 2, 3]</span></span><br><span class=\"line\">arrAdd(<span class=\"number\">3</span>) <span class=\"comment\">// [1, 2, 3, 3]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 正面示例</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>]</span><br><span class=\"line\"><span class=\"keyword\">const</span> arrAdd = <span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr.concat(value)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">arrAdd(<span class=\"number\">3</span>) <span class=\"comment\">// [1, 2, 3]</span></span><br><span class=\"line\">arrAdd(<span class=\"number\">3</span>) <span class=\"comment\">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>在后记 1 中对数组字符串方法是否对原值有影响作了整理</p>\n</blockquote>\n<ul>\n<li>函数柯里化: 将多个入参的函数转化为一个入参的函数;</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> add = <span class=\"function\"><span class=\"params\">a</span> =&gt;</span> <span class=\"function\"><span class=\"params\">b</span> =&gt;</span> <span class=\"function\"><span class=\"params\">c</span> =&gt;</span> a + b + c</span><br><span class=\"line\">add(<span class=\"number\">1</span>)(<span class=\"number\">2</span>)(<span class=\"number\">3</span>)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>偏函数: 将多个入参的函数转化成两部分;</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> add = <span class=\"function\"><span class=\"params\">a</span> =&gt;</span> <span class=\"function\">(<span class=\"params\">b, c</span>) =&gt;</span> a + b + c</span><br><span class=\"line\">add(<span class=\"number\">1</span>)(<span class=\"number\">2</span>, <span class=\"number\">3</span>)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>可组合: 函数之间能组合使用</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> add = <span class=\"function\">(<span class=\"params\">x</span>) =&gt;</span> x + x</span><br><span class=\"line\"><span class=\"keyword\">const</span> mult = <span class=\"function\">(<span class=\"params\">x</span>) =&gt;</span> x * x</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> addAndMult = <span class=\"function\">(<span class=\"params\">x</span>) =&gt;</span> add(mult(x))</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"柯里化-curry\"><a href=\"#柯里化-curry\" class=\"headerlink\" title=\"柯里化(curry)\"></a>柯里化(curry)</h3><p>如下是一个加法函数:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> add = <span class=\"function\">(<span class=\"params\">a, b, c</span>) =&gt;</span> a + b + c</span><br><span class=\"line\"></span><br><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>) <span class=\"comment\">// 6</span></span><br></pre></td></tr></table></figure>\n\n<p>假如有这样一个 <code>curry</code> 函数, 用其包装 <code>add</code> 函数后返回一个新的函数 <code>curryAdd</code>, 我们可以将参数 <code>a、b</code> 进行分开传递进行调用。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> curryAdd = curry(add)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 以下输出结果都相同</span></span><br><span class=\"line\">curryAdd(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>) <span class=\"comment\">// 6</span></span><br><span class=\"line\">curryAdd(<span class=\"number\">1</span>, <span class=\"number\">2</span>)(<span class=\"number\">3</span>) <span class=\"comment\">// 6</span></span><br><span class=\"line\">curryAdd(<span class=\"number\">1</span>)(<span class=\"number\">2</span>)(<span class=\"number\">3</span>) <span class=\"comment\">// 6</span></span><br><span class=\"line\">curryAdd(<span class=\"number\">1</span>)(<span class=\"number\">2</span>, <span class=\"number\">3</span>) <span class=\"comment\">// 6</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"动手实现一个-curry-函数\"><a href=\"#动手实现一个-curry-函数\" class=\"headerlink\" title=\"动手实现一个 curry 函数\"></a>动手实现一个 curry 函数</h4><p>核心思路: 若传进去的参数个数未达到 <code>curryAdd</code> 的个数，则将参数缓存在闭包变量 lists 中:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">curry</span>(<span class=\"params\">fn, ...args</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> length = fn.length</span><br><span class=\"line\">  <span class=\"keyword\">let</span> lists = args || []</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> listLen</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">..._args</span>) </span>&#123;</span><br><span class=\"line\">    lists = [...lists, ..._args]</span><br><span class=\"line\">    listLen = lists.length</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (listLen &lt; length) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> that = lists</span><br><span class=\"line\">      lists = []</span><br><span class=\"line\">      <span class=\"keyword\">return</span> curry(fn, ...that)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (listLen === length) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> that = lists</span><br><span class=\"line\">      lists = []</span><br><span class=\"line\">      <span class=\"keyword\">return</span> fn.apply(<span class=\"keyword\">this</span>, that)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"代码组合-compose\"><a href=\"#代码组合-compose\" class=\"headerlink\" title=\"代码组合(compose)\"></a>代码组合(compose)</h3><p>现在有 <code>toUpperCase</code>、<code>reverse</code>、<code>head</code> 三个函数, 分别如下:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> toUpperCase = <span class=\"function\">(<span class=\"params\">str</span>) =&gt;</span> str.toUpperCase()</span><br><span class=\"line\"><span class=\"keyword\">var</span> reverse = <span class=\"function\">(<span class=\"params\">arr</span>) =&gt;</span> arr.reverse()</span><br><span class=\"line\"><span class=\"keyword\">var</span> head = <span class=\"function\">(<span class=\"params\">arr</span>) =&gt;</span> arr[<span class=\"number\">0</span>]</span><br></pre></td></tr></table></figure>\n\n<p>接着使用它们实现将数组末位元素大写化输出, 可以这样做:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> reverseHeadUpperCase = <span class=\"function\">(<span class=\"params\">arr</span>) =&gt;</span> toUpperCase(head(reverse(arr)))</span><br><span class=\"line\"></span><br><span class=\"line\">reverseHeadUpperCase([<span class=\"string\">'apple'</span>, <span class=\"string\">'banana'</span>, <span class=\"string\">'peach'</span>]) <span class=\"comment\">// \"PEACH\"</span></span><br></pre></td></tr></table></figure>\n\n<p>此时在构建 <code>reverseHeadUpperCase</code> 函数的时候, 必须手动声明传入参数 arr, 是否能提供一个 <code>compose</code> 函数让使用者更加友好的使用呢? 类似如下形式:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> reverseHeadUpperCase = compose(toUpperCase, head, reverse)</span><br><span class=\"line\"></span><br><span class=\"line\">reverseHeadUpperCase([<span class=\"string\">'apple'</span>, <span class=\"string\">'banana'</span>, <span class=\"string\">'peach'</span>]) <span class=\"comment\">// \"PEACH\"</span></span><br></pre></td></tr></table></figure>\n\n<p>此外 <code>compose</code> 函数符合<code>结合律</code>, 我们可以这样子使用:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">compose(compose(toUpperCase, head), reverse)</span><br><span class=\"line\">compose(toUpperCase, compose(head, reverse))</span><br></pre></td></tr></table></figure>\n\n<p>以上两种写法与 <code>compose(toUpperCase, head, reverse)</code> 的效果完全相同, 都是依次从右到左执行传参中的函数。</p>\n<p>此外 <code>compose</code> 和 <code>map</code> 一起使用时也有相关的结合律, 以下两种写法效果相等</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">compose(map(f), map(g))</span><br><span class=\"line\">map(compose(f, g))</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"动手实现一个-compose-函数\"><a href=\"#动手实现一个-compose-函数\" class=\"headerlink\" title=\"动手实现一个 compose 函数\"></a>动手实现一个 compose 函数</h4><p>代码精华集中在一行之内, 其为众多开源库(比如 Redux) 所采用。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> compose = <span class=\"function\">(<span class=\"params\">...args</span>) =&gt;</span> <span class=\"function\">(<span class=\"params\">initValue</span>) =&gt;</span> args.reduceRight(<span class=\"function\">(<span class=\"params\">a, c</span>) =&gt;</span> c(a), initValue)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"范畴论\"><a href=\"#范畴论\" class=\"headerlink\" title=\"范畴论\"></a>范畴论</h3><p>范畴论是数学中的一个分支。可以将范畴理解为一个容器, 把原来对值的操作，现转为对容器的操作。如下图:</p>\n<p><img src=\"http://with.muyunyun.cn/c65fa1b63dbe9fa0a0771e7e561dc85b.jpg-200\" alt=\"\"></p>\n<blockquote>\n<p>学习函数式编程就是学习各种函子的过程。</p>\n</blockquote>\n<p>函数式编程中, <code>函子(Functor)</code> 是实现了 <code>map</code> 函数的容器, 下文中将函子视为范畴，模型可表示如下:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Functor</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(value) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.value = value</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  map(fn) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Functor(fn(<span class=\"keyword\">this</span>.value))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是在函数式编程中, 要避免使用 <code>new</code> 这种面向对象的编程方式, 取而代之对外暴露了一个 <code>of</code> 的接口, 也称为 <code>pointed functor</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">Functor.of = <span class=\"function\"><span class=\"params\">value</span> =&gt;</span> <span class=\"keyword\">new</span> Functor(value)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Maybe-函子\"><a href=\"#Maybe-函子\" class=\"headerlink\" title=\"Maybe 函子\"></a>Maybe 函子</h4><p><code>Maybe 函子</code>是为了解决 <code>this.value</code> 为 null 的情形, 用法如下:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">Maybe.of(<span class=\"literal\">null</span>).map(<span class=\"function\"><span class=\"params\">r</span> =&gt;</span> r.toUpperCase()) <span class=\"comment\">// null</span></span><br><span class=\"line\">Maybe.of(<span class=\"string\">'m'</span>).map(<span class=\"function\"><span class=\"params\">r</span> =&gt;</span> r.toUpperCase())  <span class=\"comment\">// Maybe &#123;value: \"M\"&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>实现代码如下:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Maybe</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(value) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.value = value</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  map(fn) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.value ? <span class=\"keyword\">new</span> Maybe(fn(<span class=\"keyword\">this</span>.value)) : <span class=\"literal\">null</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Maybe.of = <span class=\"function\"><span class=\"params\">value</span> =&gt;</span> <span class=\"keyword\">new</span> Maybe(value)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Either-函子\"><a href=\"#Either-函子\" class=\"headerlink\" title=\"Either 函子\"></a>Either 函子</h4><p><code>Either 函子</code> 是为了对应 <code>if...else...</code> 的语法, 即<code>非左即右</code>。因此可以将之拆分为 <code>Left</code> 和 <code>Right</code> 两个函子, 它们的用法如下:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">Left.of(<span class=\"number\">1</span>).map(<span class=\"function\"><span class=\"params\">r</span> =&gt;</span> r + <span class=\"number\">1</span>)  <span class=\"comment\">// Left &#123;value: 1&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">Right.of(<span class=\"number\">1</span>).map(<span class=\"function\"><span class=\"params\">r</span> =&gt;</span> r + <span class=\"number\">1</span>) <span class=\"comment\">// Right &#123;value: 2&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p><code>Left 函子</code>实现代码如下:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Left</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(value) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.value = value</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  map(fn) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Left.of = <span class=\"function\"><span class=\"params\">value</span> =&gt;</span> <span class=\"keyword\">new</span> Left(value)</span><br></pre></td></tr></table></figure>\n\n<p><code>Right 函子</code>实现代码如下(其实就是上面的 <code>Functor</code>):</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Right</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(value) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.value = value</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  map(fn) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Right(fn(<span class=\"keyword\">this</span>.value))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Right.of = <span class=\"function\"><span class=\"params\">value</span> =&gt;</span> <span class=\"keyword\">new</span> Right(value)</span><br></pre></td></tr></table></figure>\n\n<p>具体 <code>Either</code> 函数只是对调用 <code>Left 函子</code> 或 <code>Right 函子</code> 作一层筛选, 其接收 <code>f</code>、<code>g</code> 两个函数以及一个函子(<code>Left or Right</code>)</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Either = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f, g, functor</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span>(functor.constructor) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'Left'</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> f(functor.value)</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'Right'</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> g(functor.value)</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> f(functor.value)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用 demo:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">Either(<span class=\"function\">(<span class=\"params\">v</span>) =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">'left'</span>, v), (v) =&gt; <span class=\"built_in\">console</span>.log(<span class=\"string\">'def'</span>, v), left)   <span class=\"comment\">// left 1</span></span><br><span class=\"line\">Either(<span class=\"function\">(<span class=\"params\">v</span>) =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">'rigth'</span>, v), (v) =&gt; <span class=\"built_in\">console</span>.log(<span class=\"string\">'def'</span>, v), rigth) <span class=\"comment\">// rigth 2</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Monad-函子\"><a href=\"#Monad-函子\" class=\"headerlink\" title=\"Monad 函子\"></a>Monad 函子</h4><p>函子会发生嵌套, 比如下面这样:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">Functor.of(Functor.of(<span class=\"number\">1</span>)) <span class=\"comment\">// Functor &#123; value: Functor &#123; value: 1 &#125; &#125;</span></span><br></pre></td></tr></table></figure>\n\n<p><code>Monad 函子</code> 对外暴露了 <code>join</code> 和 <code>flatmap</code> 接口, 调用者从而可以扁平化嵌套的函子。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Monad</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(value) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.value = value</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  map(fn) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Monad(fn(<span class=\"keyword\">this</span>.value))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  join() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.value</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  flatmap(fn) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.map(fn).join()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Monad.of = <span class=\"function\"><span class=\"params\">value</span> =&gt;</span> <span class=\"keyword\">new</span> Monad(value)</span><br></pre></td></tr></table></figure>\n\n<p>使用方法:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// join</span></span><br><span class=\"line\">Monad.of(Monad.of(<span class=\"number\">1</span>).join()) <span class=\"comment\">// Monad &#123; value: 1 &#125;</span></span><br><span class=\"line\">Monad.of(Monad.of(<span class=\"number\">1</span>)).join() <span class=\"comment\">// Monad &#123; value: 1 &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// flatmap</span></span><br><span class=\"line\">Monad.of(<span class=\"number\">1</span>).flatmap(<span class=\"function\"><span class=\"params\">r</span> =&gt;</span> r + <span class=\"number\">1</span>)  <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>Monad 函子可以运用在 I/O 这种不纯的操作上将之变为纯函数的操作，目前比较懵懂，日后补充。</p>\n</blockquote>\n<h3 id=\"后记-1-数组字符串方法小结-是否对原值有影响\"><a href=\"#后记-1-数组字符串方法小结-是否对原值有影响\" class=\"headerlink\" title=\"后记 1: 数组字符串方法小结(是否对原值有影响)\"></a>后记 1: 数组字符串方法小结(是否对原值有影响)</h3><h4 id=\"不会对原数组有影响的方法\"><a href=\"#不会对原数组有影响的方法\" class=\"headerlink\" title=\"不会对原数组有影响的方法\"></a>不会对原数组有影响的方法</h4><h5 id=\"slice\"><a href=\"#slice\" class=\"headerlink\" title=\"slice\"></a>slice</h5><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> test = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"keyword\">var</span> result = test.slice(<span class=\"number\">0</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(test)   <span class=\"comment\">// [1, 2, 3]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result) <span class=\"comment\">// [1]</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"concat\"><a href=\"#concat\" class=\"headerlink\" title=\"concat\"></a>concat</h5><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> test = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"keyword\">var</span> result = test.concat(<span class=\"number\">4</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(test)   <span class=\"comment\">// [1, 2, 3]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result) <span class=\"comment\">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"对原数组有影响的方法\"><a href=\"#对原数组有影响的方法\" class=\"headerlink\" title=\"对原数组有影响的方法\"></a>对原数组有影响的方法</h4><h5 id=\"splice-这个需要特别记一下\"><a href=\"#splice-这个需要特别记一下\" class=\"headerlink\" title=\"splice(这个需要特别记一下)\"></a>splice(这个需要特别记一下)</h5><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> test = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"keyword\">var</span> result = test.splice(<span class=\"number\">0</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(test)   <span class=\"comment\">// [2, 3]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result) <span class=\"comment\">// [1]</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"sort\"><a href=\"#sort\" class=\"headerlink\" title=\"sort\"></a>sort</h5><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">2</span>, <span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]</span><br><span class=\"line\">arr.sort(<span class=\"function\">(<span class=\"params\">r1, r2</span>) =&gt;</span> (r1 - r2))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr) <span class=\"comment\">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"reverse\"><a href=\"#reverse\" class=\"headerlink\" title=\"reverse\"></a>reverse</h5><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> test = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"keyword\">var</span> result = test.reverse()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(test)   <span class=\"comment\">// [3, 2, 1]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result) <span class=\"comment\">// [3, 2, 1]</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"push-pop-unshift-shift\"><a href=\"#push-pop-unshift-shift\" class=\"headerlink\" title=\"push/pop/unshift/shift\"></a>push/pop/unshift/shift</h5><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> test = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"keyword\">var</span> result = test.push(<span class=\"number\">4</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(test)   <span class=\"comment\">// [1, 2, 3, 4]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result) <span class=\"comment\">// 4</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"不会对原字符串造成影响的方法\"><a href=\"#不会对原字符串造成影响的方法\" class=\"headerlink\" title=\"不会对原字符串造成影响的方法\"></a>不会对原字符串造成影响的方法</h4><h5 id=\"substr-substring-slice\"><a href=\"#substr-substring-slice\" class=\"headerlink\" title=\"substr/substring/slice\"></a>substr/substring/slice</h5><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// substr</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> test = <span class=\"string\">'abc'</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> result = test.substr(<span class=\"number\">0</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(test)   <span class=\"comment\">// 'abc'</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result) <span class=\"comment\">// a</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// substring</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> test = <span class=\"string\">'abc'</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> result = test.substring(<span class=\"number\">0</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(test)   <span class=\"comment\">// 'abc'</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result) <span class=\"comment\">// a</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// slice</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> test = <span class=\"string\">'abc'</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> result = test.slice(<span class=\"number\">0</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(test)   <span class=\"comment\">// 'abc'</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result) <span class=\"comment\">// a</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ul>\n<li><a href=\"https://mostly-adequate.gitbooks.io/mostly-adequate-guide\" target=\"_blank\" rel=\"noopener\">mostly-adequate-guide</a></li>\n<li><a href=\"https://llh911001.gitbooks.io/mostly-adequate-guide-chinese\" target=\"_blank\" rel=\"noopener\">JavaScript 函数式编程指南</a></li>\n<li><a href=\"https://github.com/mqyqingfeng/Blog/issues/42\" target=\"_blank\" rel=\"noopener\">JavaScript 专题之函数柯里化</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2017/02/fp-tutorial.html\" target=\"_blank\" rel=\"noopener\">函数式编程入门教程</a></li>\n</ul>\n","categories":["fp"],"tags":["fp"]},{"title":"探寻 webpack 插件机制","url":"/posts/8a8c13a7/","content":"<p><img src=\"http://with.muyunyun.cn/1b98cd5742c64a67d9bd49b4ea1ed206.jpg-muyy\" alt=\"\"></p>\n<p>webpack 可谓是让人欣喜又让人忧，功能强大但需要一定的学习成本。在探寻 webpack 插件机制前，首先需要了解一件有意思的事情，webpack 插件机制是整个 webpack 工具的骨架，而 webpack 本身也是利用这套插件机制构建出来的。因此在深入认识 webpack 插件机制后，再来进行项目的相关优化，想必会大有裨益。</p>\n<a id=\"more\"></a>\n\n<h3 id=\"webpack-插件\"><a href=\"#webpack-插件\" class=\"headerlink\" title=\"webpack 插件\"></a>webpack 插件</h3><p>先来瞅瞅 webpack 插件在项目中的运用</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> MyPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'myplugin'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">webpack(&#123;</span><br><span class=\"line\">  ...,</span><br><span class=\"line\">  plugins: [<span class=\"keyword\">new</span> MyPlugin()]</span><br><span class=\"line\">  ...,</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>那么符合什么样的条件能作为 webpack 插件呢？一般来说，webpack 插件有以下特点：</p>\n<ol>\n<li><p>独立的 JS 模块，暴露相应的函数</p>\n</li>\n<li><p>函数原型上的 apply 方法会注入 compiler 对象</p>\n</li>\n<li><p>compiler 对象上挂载了相应的 webpack 事件钩子</p>\n</li>\n<li><p>事件钩子的回调函数里能拿到编译后的 compilation 对象，如果是异步钩子还能拿到相应的 callback</p>\n</li>\n</ol>\n<p>下面结合代码来看看：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">MyPlugin</span>(<span class=\"params\">options</span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"comment\">// 2.函数原型上的 apply 方法会注入 compiler 对象</span></span><br><span class=\"line\">MyPlugin.prototype.apply = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">compiler</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 3.compiler 对象上挂载了相应的 webpack 事件钩子 4.事件钩子的回调函数里能拿到编译后的 compilation 对象</span></span><br><span class=\"line\">  compiler.plugin(<span class=\"string\">'emit'</span>, (compilation, callback) =&gt; &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 1.独立的 JS 模块，暴露相应的函数</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = MyPlugin</span><br></pre></td></tr></table></figure>\n\n<p>这样子，webpack 插件的基本轮廓就勾勒出来了，此时疑问点有几点，</p>\n<ol>\n<li>疑问 1：函数的原型上为什么要定义 apply 方法？阅读<a href=\"https://github.com/webpack/webpack/blob/10282ea20648b465caec6448849f24fc34e1ba3e/lib/webpack.js#L35\" target=\"_blank\" rel=\"noopener\">源码</a>后发现源码中是通过 <code>plugin.apply()</code> 调用插件的。</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> webpack = <span class=\"function\">(<span class=\"params\">options, callback</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> plugin <span class=\"keyword\">of</span> options.plugins) &#123;</span><br><span class=\"line\">    plugin.apply(compiler);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><p>疑问 2：compiler 对象是什么呢？</p>\n</li>\n<li><p>疑问 3：compiler 对象上的事件钩子是怎样的？</p>\n</li>\n<li><p>疑问 4：事件钩子的回调函数里能拿到的 compilation 对象又是什么呢？</p>\n</li>\n</ol>\n<p>这些疑问也是本文的线索，让我们一个个探索。</p>\n<h3 id=\"compiler-对象\"><a href=\"#compiler-对象\" class=\"headerlink\" title=\"compiler 对象\"></a>compiler 对象</h3><p>compiler 即 webpack 的编辑器对象，在调用 webpack 时，会自动初始化 compiler 对象，<a href=\"https://github.com/webpack/webpack/blob/10282ea20648b465caec6448849f24fc34e1ba3e/lib/webpack.js#L30\" target=\"_blank\" rel=\"noopener\">源码</a>如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// webpack/lib/webpack.js</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> Compiler = <span class=\"built_in\">require</span>(<span class=\"string\">\"./Compiler\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> webpack = <span class=\"function\">(<span class=\"params\">options, callback</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  options = <span class=\"keyword\">new</span> WebpackOptionsDefaulter().process(options) <span class=\"comment\">// 初始化 webpack 各配置参数</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> compiler = <span class=\"keyword\">new</span> Compiler(options.context)             <span class=\"comment\">// 初始化 compiler 对象，这里 options.context 为 process.cwd()</span></span><br><span class=\"line\">  compiler.options = options                               <span class=\"comment\">// 往 compiler 添加初始化参数</span></span><br><span class=\"line\">  <span class=\"keyword\">new</span> NodeEnvironmentPlugin().apply(compiler)              <span class=\"comment\">// 往 compiler 添加 Node 环境相关方法</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> plugin <span class=\"keyword\">of</span> options.plugins) &#123;</span><br><span class=\"line\">    plugin.apply(compiler);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>终上，compiler 对象中包含了所有 webpack 可配置的内容，开发插件时，我们可以从 compiler 对象中拿到所有和 webpack 主环境相关的内容。</p>\n<h3 id=\"compilation-对象\"><a href=\"#compilation-对象\" class=\"headerlink\" title=\"compilation 对象\"></a>compilation 对象</h3><p>compilation 对象代表了一次单一的版本构建和生成资源。当运行 webpack 时，每当检测到一个文件变化，一次新的编译将被创建，从而生成一组新的编译资源。一个编译对象表现了当前的模块资源、编译生成资源、变化的文件、以及被跟踪依赖的状态信息。</p>\n<p>结合源码来理解下上面这段话，首先 webpack 在每次执行时会调用 <code>compiler.run()</code> <a href=\"https://github.com/webpack/webpack/blob/e7c8fa414b718ac98d94a96e2553faceabfbc92f/lib/webpack.js#L58\" target=\"_blank\" rel=\"noopener\">(源码位置)</a>，接着追踪 <a href=\"https://github.com/webpack/webpack/blob/3a5fda909f2ecf911c73429cb4770948dbd31d24/lib/Compiler.js#L163\" target=\"_blank\" rel=\"noopener\">onCompiled 函数</a>传入的 compilation 参数，可以发现 compilation 来自构造函数 Compilation。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// webpack/lib/Compiler.js</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> Compilation = <span class=\"built_in\">require</span>(<span class=\"string\">\"./Compilation\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">newCompilation(params) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> compilation = <span class=\"keyword\">new</span> Compilation(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"keyword\">return</span> compilation;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"不得不提的-tapable-库\"><a href=\"#不得不提的-tapable-库\" class=\"headerlink\" title=\"不得不提的 tapable 库\"></a>不得不提的 tapable 库</h3><p>再介绍完 compiler 对象和 compilation 对象后，不得不提的是 <a href=\"https://github.com/webpack/tapable\" target=\"_blank\" rel=\"noopener\">tapable</a> 这个库，这个库暴露了所有和事件相关的 pub/sub 的方法。而且函数 <a href=\"https://github.com/webpack/webpack/blob/e7c8fa414b718ac98d94a96e2553faceabfbc92f/lib/Compiler.js#L29\" target=\"_blank\" rel=\"noopener\">Compiler</a> 以及函数 <a href=\"https://github.com/webpack/webpack/blob/e7c8fa414b718ac98d94a96e2553faceabfbc92f/lib/Compilation.js#L98\" target=\"_blank\" rel=\"noopener\">Compilation</a> 都继承自 Tapable。</p>\n<h3 id=\"事件钩子\"><a href=\"#事件钩子\" class=\"headerlink\" title=\"事件钩子\"></a>事件钩子</h3><p>事件钩子其实就是类似 MVVM 框架的生命周期函数，在特定阶段能做特殊的逻辑处理。了解一些常见的事件钩子是写 webpack 插件的前置条件，下面列举些常见的事件钩子以及作用：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">钩子</th>\n<th align=\"center\">作用</th>\n<th align=\"center\">参数</th>\n<th align=\"center\">类型</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">after-plugins</td>\n<td align=\"center\">设置完一组初始化插件之后</td>\n<td align=\"center\">compiler</td>\n<td align=\"center\">sync</td>\n</tr>\n<tr>\n<td align=\"center\">after-resolvers</td>\n<td align=\"center\">设置完 resolvers 之后</td>\n<td align=\"center\">compiler</td>\n<td align=\"center\">sync</td>\n</tr>\n<tr>\n<td align=\"center\">run</td>\n<td align=\"center\">在读取记录之前</td>\n<td align=\"center\">compiler</td>\n<td align=\"center\">async</td>\n</tr>\n<tr>\n<td align=\"center\">compile</td>\n<td align=\"center\">在创建新 compilation 之前</td>\n<td align=\"center\">compilationParams</td>\n<td align=\"center\">sync</td>\n</tr>\n<tr>\n<td align=\"center\">compilation</td>\n<td align=\"center\">compilation 创建完成</td>\n<td align=\"center\">compilation</td>\n<td align=\"center\">sync</td>\n</tr>\n<tr>\n<td align=\"center\">emit</td>\n<td align=\"center\">在生成资源并输出到目录之前</td>\n<td align=\"center\">compilation</td>\n<td align=\"center\">async</td>\n</tr>\n<tr>\n<td align=\"center\">after-emit</td>\n<td align=\"center\">在生成资源并输出到目录之后</td>\n<td align=\"center\">compilation</td>\n<td align=\"center\">async</td>\n</tr>\n<tr>\n<td align=\"center\">done</td>\n<td align=\"center\">完成编译</td>\n<td align=\"center\">stats</td>\n<td align=\"center\">sync</td>\n</tr>\n</tbody></table>\n<p>完整地请参阅<a href=\"https://doc.webpack-china.org/api/compiler/#%E4%BA%8B%E4%BB%B6%E9%92%A9%E5%AD%90\" target=\"_blank\" rel=\"noopener\">官方文档手册</a>，同时浏览<a href=\"https://github.com/webpack/webpack/blob/eca7bad8de54c39b9cb8b138793362b8a17ac11b/lib/Compiler.js#L32\" target=\"_blank\" rel=\"noopener\">相关源码</a> 也能比较清晰地看到各个事件钩子的定义。</p>\n<h3 id=\"插件流程浅析\"><a href=\"#插件流程浅析\" class=\"headerlink\" title=\"插件流程浅析\"></a>插件流程浅析</h3><p>拿 emit 钩子为例，下面分析下插件调用源码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">compiler.plugin(<span class=\"string\">'emit'</span>, (compilation, callback) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 在生成资源并输出到目录之前完成某些逻辑</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>此处调用的 plugin 函数源自上文提到的 tapable 库，其最终调用栈指向了 hook.tapAsync()，其作用类似于 EventEmitter 的 on，<a href=\"https://github.com/webpack/tapable/blob/42b520760e138c23e7808881cb4322557e878307/lib/Tapable.js#L35\" target=\"_blank\" rel=\"noopener\">源码</a>如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Tapable.js</span></span><br><span class=\"line\">options =&gt; &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(hook !== <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> tapOpt = &#123;</span><br><span class=\"line\">      name: options.fn.name || <span class=\"string\">\"unnamed compat plugin\"</span>,</span><br><span class=\"line\">      stage: options.stage || <span class=\"number\">0</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(options.async)</span><br><span class=\"line\">      hook.tapAsync(tapOpt, options.fn); <span class=\"comment\">// 将插件中异步钩子的回调函数注入</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">      hook.tap(tapOpt, options.fn);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>有注入必有触发的地方，源码中通过 callAsync 方法触发之前注入的异步事件，callAsync 类似 EventEmitter 的 emit，<a href=\"https://github.com/webpack/webpack/blob/e7c8fa414b718ac98d94a96e2553faceabfbc92f/lib/Compiler.js#L307\" target=\"_blank\" rel=\"noopener\">相关源码</a>如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.hooks.emit.callAsync(compilation, err =&gt; &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (err) <span class=\"keyword\">return</span> callback(err);</span><br><span class=\"line\">\toutputPath = compilation.getPath(<span class=\"keyword\">this</span>.outputPath);</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.outputFileSystem.mkdirp(outputPath, emitFiles);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>一些深入细节这里就不展开了，说下关于阅读比较大型项目的源码的两点体会，</p>\n<ul>\n<li><p>要抓住一条主线索去读，忽视细节。否则会浪费很多时间而且会有挫败感；</p>\n</li>\n<li><p>结合调试工具来分析，很多点不用调试工具的话很容易顾此失彼；</p>\n</li>\n</ul>\n<h3 id=\"动手实现个-webpack-插件\"><a href=\"#动手实现个-webpack-插件\" class=\"headerlink\" title=\"动手实现个 webpack 插件\"></a>动手实现个 webpack 插件</h3><p>结合上述知识点的分析，不难写出自己的 webpack 插件，关键在于想法。为了统计项目中 webpack 各包的有效使用情况，在 fork <a href=\"https://github.com/chrisbateman/webpack-visualizer\" target=\"_blank\" rel=\"noopener\">webpack-visualizer</a> 的基础上对代码升级了一番，<a href=\"https://github.com/MuYunyun/analyze-webpack-plugin\" target=\"_blank\" rel=\"noopener\">项目地址</a>。效果如下：</p>\n<p><img src=\"http://with.muyunyun.cn/329ec042a73aecd0a1947bdcc1f0dcb4.jpg-400\" alt=\"\"></p>\n<p>插件核心代码正是基于上文提到的 emit 钩子，以及 compiler 和 compilation 对象。代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AnalyzeWebpackPlugin</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(opts = &#123; filename: <span class=\"string\">'analyze.html'</span> &#125;) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.opts = opts</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  apply(compiler) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> self = <span class=\"keyword\">this</span></span><br><span class=\"line\">    compiler.plugin(<span class=\"string\">\"emit\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">compilation, callback</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> stats = compilation.getStats().toJson(&#123; <span class=\"attr\">chunkModules</span>: <span class=\"literal\">true</span> &#125;) <span class=\"comment\">// 获取各个模块的状态</span></span><br><span class=\"line\">      <span class=\"keyword\">let</span> stringifiedStats = <span class=\"built_in\">JSON</span>.stringify(stats)</span><br><span class=\"line\">      <span class=\"comment\">// 服务端渲染</span></span><br><span class=\"line\">      <span class=\"keyword\">let</span> html = <span class=\"string\">`&lt;!doctype html&gt;</span></span><br><span class=\"line\"><span class=\"string\">          &lt;meta charset=\"UTF-8\"&gt;</span></span><br><span class=\"line\"><span class=\"string\">          &lt;title&gt;AnalyzeWebpackPlugin&lt;/title&gt;</span></span><br><span class=\"line\"><span class=\"string\">          &lt;style&gt;<span class=\"subst\">$&#123;cssString&#125;</span>&lt;/style&gt;</span></span><br><span class=\"line\"><span class=\"string\">          &lt;div id=\"App\"&gt;&lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">          &lt;script&gt;window.stats = <span class=\"subst\">$&#123;stringifiedStats&#125;</span>;&lt;/script&gt;</span></span><br><span class=\"line\"><span class=\"string\">          &lt;script&gt;<span class=\"subst\">$&#123;jsString&#125;</span>&lt;/script&gt;</span></span><br><span class=\"line\"><span class=\"string\">      `</span></span><br><span class=\"line\">      compilation.assets[<span class=\"string\">`<span class=\"subst\">$&#123;self.opts.filename&#125;</span>`</span>] = &#123; <span class=\"comment\">// 生成文件路径</span></span><br><span class=\"line\">        source: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> html,</span><br><span class=\"line\">        size: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> html.length</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      callback()</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><p><a href=\"https://zoumiaojiang.com/article/what-is-real-webpack-plugin/#compiler\" target=\"_blank\" rel=\"noopener\">看清楚真正的 Webpack 插件\n</a></p>\n<p><a href=\"https://doc.webpack-china.org/\" target=\"_blank\" rel=\"noopener\">webpack 官网</a></p>\n","categories":["webpack"],"tags":["webpack"]},{"title":"跨域二三事","url":"/posts/e29f2c47/","content":"<p><img src=\"http://with.muyunyun.cn/62b89b89373dc86916a60efc28bdd15e.jpg-muyy\" alt=\"\"></p>\n<p>跨域是日常开发中经常开发中经常会接触到的一个重难点知识，何不总结实践一番，从此心中对之了无牵挂。</p>\n<a id=\"more\"></a>\n\n<h3 id=\"同源策略\"><a href=\"#同源策略\" class=\"headerlink\" title=\"同源策略\"></a>同源策略</h3><p>之所以会出现跨域解决方案，是因为同源策略的限制。同源策略规定了如果两个 url 的协议、域名、端口中有任何一个不等，就认定它们跨源了。比如下列表格列出和 <code>http://127.0.0.1:3000</code> 比较的同源检测的结果，</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">url</th>\n<th align=\"center\">结果</th>\n<th align=\"center\">原因</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><a href=\"http://127.0.0.1:3000/index\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1:3000/index</a></td>\n<td align=\"center\">同源</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\"><a href=\"https://127.0.0.1:3000\" target=\"_blank\" rel=\"noopener\">https://127.0.0.1:3000</a></td>\n<td align=\"center\">跨源</td>\n<td align=\"center\">协议不同</td>\n</tr>\n<tr>\n<td align=\"center\"><a href=\"https://localhost:3000\" target=\"_blank\" rel=\"noopener\">https://localhost:3000</a></td>\n<td align=\"center\">跨源</td>\n<td align=\"center\">域名不同</td>\n</tr>\n<tr>\n<td align=\"center\"><a href=\"http://127.0.0.1:3001\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1:3001</a></td>\n<td align=\"center\">跨源</td>\n<td align=\"center\">端口不同</td>\n</tr>\n</tbody></table>\n<p>那跨源有什么后果呢？归纳有三：不能获取 Cookie、LocalStorage、IndexedDB；不能获取 dom 节点；不能进行一般的 Ajax 通信；跨域解决方案的出现就是为了解决以上痛处。</p>\n<h3 id=\"JSONP-跨域\"><a href=\"#JSONP-跨域\" class=\"headerlink\" title=\"JSONP 跨域\"></a>JSONP 跨域</h3><p>提到 JSONP 跨域，不得不先提到 <code>script</code> 标签，和 <code>img</code>、<code>iframe</code> 标签类似，这些标签是不受同源策略限制的，JSONP 的核心就是通过动态加载 script 标签来完成对目标 url 的请求。</p>\n<p>先来看一段 JSONP 调用的 <code>Headers</code> 部分，字段如下：</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\">Request URL:http://127.0.0.1:3000/?callback=handleResponse</span><br><span class=\"line\">Request Method:GET</span><br><span class=\"line\">Status Code:200 OK</span><br><span class=\"line\">Remote Address:127.0.0.1:3000</span><br></pre></td></tr></table></figure>\n\n<p>可以很鲜明地发现在 <code>Request URL</code> 中有一句 <code>?callback=handleResponse</code>，这个 callback 后面跟着的 handleResponse 即回调函数名（可以任意取），服务端会接收到这个参数然后拼接成形如 <code>handleResponse(JSON)</code> 的形式返还给前端(这也是 JSONP == JSON with padding 的原因吧)，如下图，这时候浏览器就会自动调用我们事先定义好的 handleResponse 函数。</p>\n<p><img src=\"http://with.muyunyun.cn/3a484a1ca0fbb4be46fed582828c5847.jpg-200\" alt=\"\"></p>\n<p>前端代码示例：(源为 <a href=\"http://127.0.0.1:3001\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1:3001</a>)</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handleResponse</span>(<span class=\"params\">res</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(res) <span class=\"comment\">// &#123;text: \"jsonp\"&#125;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> script = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'script'</span>)</span><br><span class=\"line\">script.src = <span class=\"string\">'http://127.0.0.1:3000?callback=handleResponse'</span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.head.appendChild(script)</span><br></pre></td></tr></table></figure>\n\n<p>服务端代码示例：(源为 <a href=\"http://127.0.0.1:3000\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1:3000</a>)</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> server = http.createServer(<span class=\"function\">(<span class=\"params\">req, res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (~req.url.indexOf(<span class=\"string\">'?callback'</span>)) &#123; <span class=\"comment\">// 简单处理 JSONP 跨域的时候</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">      <span class=\"string\">\"text\"</span>: <span class=\"string\">'jsonp'</span>,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> callback = req.url.split(<span class=\"string\">'callback='</span>)[<span class=\"number\">1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">const</span> json = <span class=\"built_in\">JSON</span>.stringify(obj)</span><br><span class=\"line\">    <span class=\"keyword\">const</span> build = callback + <span class=\"string\">`(<span class=\"subst\">$&#123;json&#125;</span>)`</span></span><br><span class=\"line\">    res.end(build) <span class=\"comment\">// 这里返还给前端的是拼接好的 JSON 对象</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>可以看出 JSONP 具有直接访问响应文本的优点，但是要想确认 JSONP 是否请求失败并不容易，因为 script 标签的 onerror 事件还未得到浏览器广泛的支持，此外它仅能支持 GET 方式调用。</p>\n<h3 id=\"CORS-跨域\"><a href=\"#CORS-跨域\" class=\"headerlink\" title=\"CORS 跨域\"></a>CORS 跨域</h3><p>CORS(Cross-Origin Resource Sharing) 可以理解为加强版的 Ajax，也是目前主流的跨域解决方案。它的核心思想即<code>前端与后端进行 Ajax 通信时，通过自定义 HTTP 头部设置从而决定请求或响应是否生效</code>。</p>\n<p>比如前端代码(url 为 <a href=\"http://127.0.0.1:3001)写了段\">http://127.0.0.1:3001)写了段</a> Ajax，代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> xhr = <span class=\"keyword\">new</span> XMLHttpRequest()</span><br><span class=\"line\">xhr.onreadystatechange = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (xhr.readyState === <span class=\"number\">4</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (xhr.status &gt;= <span class=\"number\">200</span> &amp;&amp; xhr.status &lt; <span class=\"number\">300</span> || xhr.status === <span class=\"number\">304</span>) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'responseTesx:'</span> + xhr.responseText)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">xhr.open(<span class=\"string\">'get'</span>, <span class=\"string\">'http://127.0.0.1:3000'</span>, <span class=\"literal\">true</span>)</span><br><span class=\"line\">xhr.send()</span><br></pre></td></tr></table></figure>\n\n<p>因为端口不一致的关系这时候导致不同源了，这时候会在 Request Headers 中发现多了这么一行字段，</p>\n<figure class=\"highlight http\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">Origin</span>: http://127.0.0.1:3001</span><br></pre></td></tr></table></figure>\n\n<p>而且控制台中会报出如下错误:</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\">Failed to load http://127.0.0.1:3000/: Response to preflight request doesn't pass access control check: No 'Access-Control-Allow-Origin' header is present on the requested resource. Origin 'http://127.0.0.1:3001' is therefore not allowed access.</span><br></pre></td></tr></table></figure>\n\n<p>这时候就需要在服务端设置字段 <code>Access-Control-Allow-Origin</code>，它的作用就是设置允许来自什么源的请求，如果值设置为 <code>*</code>，表明允许来自任意源的请求。服务端代码示例如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">http.createServer(<span class=\"function\">(<span class=\"params\">req, res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  res.setHeader(<span class=\"string\">'Access-Control-Allow-Origin'</span>, <span class=\"string\">'http://127.0.0.1:3001'</span>) <span class=\"comment\">// 设置允许来自 http://127.0.0.1:3001 源的请求</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>CORS 分为简单请求以及非简单请求。可以这么区分，如果请求方法为 <code>POST</code>、<code>GET</code>、<code>HEAD</code> 时为简单请求，其它方法如 <code>PUT</code>、<code>DELETE</code> 等为非简单请求，如果是非简单请求的话，可以在 chrome 的 Network 中看到多了一次 <code>Request Method</code> 为 <code>OPTIONS</code> 的请求。如下图:</p>\n<p><img src=\"http://with.muyunyun.cn/f397ac2c565828f38516c8be2ebc1b4b.jpg-400\" alt=\"\"></p>\n<p>可以把这个请求称为预请求，用白话文翻译下，浏览器询问服务器，’服务器大哥，我这次要进行 PUT 请求，你给我发张通行证呗’，服务器大哥见浏览器小弟这么殷勤，于是给了它发了张通行证，叫作 <code>Access-Control-Allow-Methods:PUT</code>，接着浏览器就能愉快地进行 PUT 请求了。服务端代码示例如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">http.createServer(<span class=\"function\">(<span class=\"params\">req, res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  res.setHeader(<span class=\"string\">'Access-Control-Allow-Origin'</span>, <span class=\"string\">'http://127.0.0.1:3001'</span>)</span><br><span class=\"line\">  res.setHeader(<span class=\"string\">'Access-Control-Allow-Methods'</span>, <span class=\"string\">'PUT'</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>聊完简单请求和非简单请求的区别后，再来看看如何利用 CORS 实现 Cookie 的跨域传送，首先在服务器随意设置个 Cookie 值下发到浏览器，如果非跨域的情况下，浏览器再次请求服务器时就会带上服务器给的 Cookie，但是跨域的时候怎么办呢？不卖关子了，需在服务端设置 <code>Access-Control-Allow-Credentials</code> 字段以及在客户端设置 <code>withCredentials</code> 字段，两者缺一不可，代码如下：</p>\n<p>前端代码示例：(源为 <a href=\"http://127.0.0.1:3001\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1:3001</a>)</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> xhr = <span class=\"keyword\">new</span> XMLHttpRequest()</span><br><span class=\"line\">...</span><br><span class=\"line\">xhr.withCredentials = <span class=\"literal\">true</span> <span class=\"comment\">// 传 cookie 的时候前端要做的</span></span><br><span class=\"line\">xhr.open(<span class=\"string\">'get'</span>, <span class=\"string\">'http://127.0.0.1:3000'</span>, <span class=\"literal\">true</span>)</span><br><span class=\"line\">xhr.send()</span><br></pre></td></tr></table></figure>\n\n<p>服务端代码示例: (源为 <a href=\"http://127.0.0.1:3000\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1:3000</a>)</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> server = http.createServer(<span class=\"function\">(<span class=\"params\">req, res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  res.setHeader(<span class=\"string\">'Access-Control-Allow-Origin'</span>, <span class=\"string\">'http://127.0.0.1:3001'</span>) <span class=\"comment\">// 必填：接受域的请求</span></span><br><span class=\"line\">  res.setHeader(<span class=\"string\">'Set-Cookie'</span>, [<span class=\"string\">'type=muyy'</span>]) <span class=\"comment\">// 下发 cookie</span></span><br><span class=\"line\">  res.setHeader(<span class=\"string\">'Access-Control-Allow-Credentials'</span>, <span class=\"literal\">true</span>) <span class=\"comment\">// ② 选填：是否允许浏览器传 cookie 到服务端，只能设置为 true</span></span><br><span class=\"line\">  res.end(<span class=\"string\">'date from cors'</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>至此介绍了几个比较关键 HTTP 头在 CORS 中的实践运用，更为详细的资料可以参阅 <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS\" target=\"_blank\" rel=\"noopener\">Cross-Origin Resource Sharing</a>，最后概括下 CORS 的优缺点，优点是支持所有类型的 HTTP 方法，缺点是有些老的浏览器不支持 CORS。</p>\n<h3 id=\"hash-iframe\"><a href=\"#hash-iframe\" class=\"headerlink\" title=\"hash + iframe\"></a>hash + iframe</h3><p>在文章最开始提到过 iframe 标签也是不受同源策略限制的标签之一，hash + iframe 的跨域核心思想就是，在 A 源中通过动态改变 iframe 标签的 src 的哈希值，在 B 源中通过 <code>window.onhashchange</code> 来捕获到相应的哈希值。思路不难直接上代码：</p>\n<p>A 页面代码示例(源为 <a href=\"http://127.0.0.1:3000\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1:3000</a>)</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">iframe</span> <span class=\"attr\">src</span>=<span class=\"string\">\"http://127.0.0.1:3001\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">iframe</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">const</span> iframe = <span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">'iframe'</span>)[<span class=\"number\">0</span>]</span></span><br><span class=\"line\"><span class=\"actionscript\">    iframe.setAttribute(<span class=\"string\">'style'</span>, <span class=\"string\">'display: none'</span>)</span></span><br><span class=\"line\"><span class=\"actionscript\">    <span class=\"keyword\">const</span> obj = &#123;</span></span><br><span class=\"line\"><span class=\"actionscript\">      data: <span class=\"string\">'hash'</span></span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"javascript\">    iframe.src = iframe.src + <span class=\"string\">'#'</span> + <span class=\"built_in\">JSON</span>.stringify(obj) <span class=\"comment\">// ① 关键语句</span></span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>B 页面代码示例(源为 <a href=\"http://127.0.0.1:3001\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1:3001</a>)</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.onhashchange = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// ① 关键语句</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'来自 page2 的代码 '</span> + <span class=\"built_in\">window</span>.location.hash) <span class=\"comment\">// 来自 page2 的代码 #&#123;\"data\":\"hash\"&#125;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>刷新 A 页面，可以发现在控制台打印了如下字段，至此实现了跨域。</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\">来自 page2 的代码 #&#123;\"data\":\"hash\"&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这种方式进行跨域优点是支持页面和页面间的通信，缺点也是只支持 GET 方法和单向的跨域通信。</p>\n<h3 id=\"postMessage\"><a href=\"#postMessage\" class=\"headerlink\" title=\"postMessage\"></a>postMessage</h3><p>为了实现跨文档传送(cross-document messaging)，简称 XDM。HTML5 给出了一个 api —— postMessage，postMessage() 方法接收两个参数：<code>发送消息</code>以及<code>消息接收方所在域的字符串</code>。代码示例如下:</p>\n<p>A 页面代码示例(源为 <a href=\"http://127.0.0.1:3000\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1:3000</a>)</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">iframe</span> <span class=\"attr\">src</span>=<span class=\"string\">\"http://127.0.0.1:3001\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">iframe</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">const</span> iframe = <span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">'iframe'</span>)[<span class=\"number\">0</span>]</span></span><br><span class=\"line\"><span class=\"actionscript\">    iframe.setAttribute(<span class=\"string\">'style'</span>, <span class=\"string\">'display: none'</span>)</span></span><br><span class=\"line\"><span class=\"actionscript\">    iframe.onload = <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span> </span>&#123; <span class=\"comment\">// 此处要等 iframe 加载完毕，后续代码才会生效</span></span></span><br><span class=\"line\"><span class=\"actionscript\">      iframe.contentWindow.postMessage(<span class=\"string\">'a secret'</span>, <span class=\"string\">'http://127.0.0.1:3001'</span>)</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>B 页面代码示例(源为 <a href=\"http://127.0.0.1:3001\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1:3001</a>)</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'message'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'From page1 '</span> + event.data)</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'From page1 '</span> + event.origin)</span><br><span class=\"line\">&#125;, <span class=\"literal\">false</span>)</span><br></pre></td></tr></table></figure>\n\n<p>刷新 A 页面，可以发现在控制台打印了如下字段，至此实现了跨域。</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">From</span> page1 a secret</span><br><span class=\"line\"><span class=\"keyword\">From</span> page1 http:<span class=\"comment\">//127.0.0.1:3000</span></span><br></pre></td></tr></table></figure>\n\n<p>这种跨域方式优点是是支持页面和页面间的双向通信，缺点也是只能支持 GET 方法调用。</p>\n<h3 id=\"WebSockets\"><a href=\"#WebSockets\" class=\"headerlink\" title=\"WebSockets\"></a>WebSockets</h3><p>WebSockets 属于 HTML5 的协议，它的目的是在一个持久连接上建立全双工通信。由于 WebSockets 采用了自定义协议，所以优点是客户端和服务端发送数据量少，缺点是要额外的服务器。基础的使用方法如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> ws = <span class=\"keyword\">new</span> WebSocket(<span class=\"string\">'ws://127.0.0.1:3000'</span>)</span><br><span class=\"line\">ws.onopen = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 连接成功建立</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">ws.onmessage = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 处理数据</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">ws.onerror = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 发生错误时触发，连接中断</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">ws.onclose = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 连接关闭时触发</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当然一般我们会使用封装好 WebSockets 的第三方库 <a href=\"https://github.com/socketio/socket.io\" target=\"_blank\" rel=\"noopener\">socket.io</a>，这里具体就不展开了。</p>\n<h3 id=\"项目地址\"><a href=\"#项目地址\" class=\"headerlink\" title=\"项目地址\"></a>项目地址</h3><p>前文所述五种跨域实践的 demo 已上传至 <a href=\"https://github.com/MuYunyun/cross-domain\" target=\"_blank\" rel=\"noopener\">cross-domain</a>，前端环境基于 create-react-app 搭建，后端环境用 node 搭建。</p>\n<p>当然跨域方式还有一些其他方式的实现，后续酌情慢慢填坑~</p>\n","categories":["跨域"],"tags":["跨域","http"]},{"title":"走近 Python (类比 JS)","url":"/posts/a9d08041/","content":"<p><img src=\"http://with.muyunyun.cn/c5438d5b79ea49066234e0328fde04e1.jpg-muyy\" alt=\"\"></p>\n<blockquote>\n<p>本文首发在 <a href=\"http://muyunyun.cn/posts/a9d08041/\">个人博客</a></p>\n</blockquote>\n<p>Python 是一门运用很广泛的语言，自动化脚本、爬虫，甚至在深度学习领域也都有 Python 的身影。作为一名前端开发者，也了解 ES6 中的很多特性借鉴自 Python (比如默认参数、解构赋值、Decorator等)，同时本文会对 Python 的一些用法与 JS 进行类比。不管是提升自己的知识广度，还是更好地迎接 AI 时代，Python 都是一门值得学习的语言。</p>\n<a id=\"more\"></a>\n\n<h3 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h3><p>在 Python 中，最常用的能够直接处理的数据类型有以下几种：</p>\n<ul>\n<li>数字[整数(int)、浮点型(float)、长整型(long)、复数(complex)]</li>\n<li>字符串(str)</li>\n<li>布尔值(bool)</li>\n<li>空值(None)</li>\n</ul>\n<p>除此之外，Python 还提供了列表[list]、字典[dict] 等多种数据类型，这在下文中会介绍。</p>\n<h4 id=\"类型转换与类型判断\"><a href=\"#类型转换与类型判断\" class=\"headerlink\" title=\"类型转换与类型判断\"></a>类型转换与类型判断</h4><p>与 JS 十分类似，python 也能实现不同数据类型间的强制与隐式转换，例子如下：</p>\n<p>强制类型转换:</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\">int(<span class=\"string\">'3'</span>) <span class=\"comment\"># 3</span></span><br><span class=\"line\">str(<span class=\"number\">3.14</span>) <span class=\"comment\"># '3.14'</span></span><br><span class=\"line\">float(<span class=\"string\">'3.14'</span>) <span class=\"comment\"># 3.14</span></span><br><span class=\"line\"><span class=\"comment\"># 区别于 JS 只有 Number 一种类型，Python 中数字中的不同类型也能相互强制转换</span></span><br><span class=\"line\">float(<span class=\"number\">3</span>) <span class=\"comment\"># 3.0</span></span><br><span class=\"line\">bool(<span class=\"number\">3</span>) <span class=\"comment\"># True</span></span><br><span class=\"line\">bool(<span class=\"number\">0</span>) <span class=\"comment\"># False</span></span><br></pre></td></tr></table></figure>\n\n<p>隐式类型转换:</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span> + <span class=\"number\">1.0</span> <span class=\"comment\"># 2.0</span></span><br><span class=\"line\"><span class=\"number\">1</span> + <span class=\"literal\">False</span> <span class=\"comment\"># 1</span></span><br><span class=\"line\"><span class=\"number\">1.0</span> + <span class=\"literal\">True</span> <span class=\"comment\"># 2.0</span></span><br><span class=\"line\"><span class=\"comment\"># 区别于 JS 的 String + Number = String, py 中 str + int 会报错</span></span><br><span class=\"line\"><span class=\"number\">1</span> + <span class=\"string\">'1'</span> <span class=\"comment\"># TypeError: cannot concatenate 'str' and 'int' objects</span></span><br></pre></td></tr></table></figure>\n\n<p>此外写代码的时候经常会需要判断值的类型，可以 使用 python 提供的 type() 函数获取变量的类型，或者使用 isinstance(x, type) 来判断 x 是否属于相应的 type 类型。</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\">type(<span class=\"number\">1.3</span>) == float <span class=\"comment\"># True</span></span><br><span class=\"line\">isinstance(<span class=\"string\">'a'</span>, str) <span class=\"comment\"># True</span></span><br><span class=\"line\">isinstance(<span class=\"number\">1.3</span>, int) <span class=\"comment\"># False</span></span><br><span class=\"line\">isinstance(<span class=\"literal\">True</span>, bool) <span class=\"comment\"># True</span></span><br><span class=\"line\">isinstance([], list) <span class=\"comment\"># True</span></span><br><span class=\"line\">isinstance(&#123;&#125;, dict) <span class=\"comment\"># True</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"有序集合类型\"><a href=\"#有序集合类型\" class=\"headerlink\" title=\"有序集合类型\"></a>有序集合类型</h3><p>集合是指包含一组元素的数据结构，有序集合即集合里面的元素是是按照顺序排列的，Python 中的有序集合大概有以下几类：list, tuple, str, unicode。</p>\n<h4 id=\"list-类型\"><a href=\"#list-类型\" class=\"headerlink\" title=\"list 类型\"></a>list 类型</h4><p>Python 中 List 类型类似于 JS 中的 Array,</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\">L = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"keyword\">print</span> L[<span class=\"number\">-1</span>] <span class=\"comment\"># '3'</span></span><br><span class=\"line\"></span><br><span class=\"line\">L.append(<span class=\"number\">4</span>) <span class=\"comment\"># 末尾添加元素</span></span><br><span class=\"line\"><span class=\"keyword\">print</span> L <span class=\"comment\"># [1, 2, 3, 4]</span></span><br><span class=\"line\"></span><br><span class=\"line\">L.insert(<span class=\"number\">0</span>, <span class=\"string\">'hi'</span>) <span class=\"comment\"># 指定索引位置添加元素</span></span><br><span class=\"line\"><span class=\"keyword\">print</span> L <span class=\"comment\"># ['hi', 1, 2, 3, 4]</span></span><br><span class=\"line\"></span><br><span class=\"line\">L.pop() <span class=\"comment\"># 末尾移除元素 L.pop(2) ?????? 2 ???</span></span><br><span class=\"line\"><span class=\"keyword\">print</span> L <span class=\"comment\"># ['hi', 1, 2, 3]</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"tuple-类型\"><a href=\"#tuple-类型\" class=\"headerlink\" title=\"tuple 类型\"></a>tuple 类型</h4><p>tuple 类型是另一种有序的列表，中文翻译为“ 元组 ”。tuple 和 list 非常类似，但是，tuple 一旦创建完毕，就不能修改了。</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\">t = (<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"keyword\">print</span> t[<span class=\"number\">0</span>] <span class=\"comment\"># 1</span></span><br><span class=\"line\">t[<span class=\"number\">0</span>] = <span class=\"number\">11</span> <span class=\"comment\"># TypeError: 'tuple' object does not support item assignment</span></span><br><span class=\"line\"></span><br><span class=\"line\">t = (<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"keyword\">print</span> t <span class=\"comment\"># 1  t 的结果是整数 1</span></span><br><span class=\"line\"></span><br><span class=\"line\">t = (<span class=\"number\">1</span>,) <span class=\"comment\"># 为了避免出现如上有歧义的单元素 tuple，所以 Python 规定，单元素 tuple 要多加一个逗号“,”</span></span><br><span class=\"line\"><span class=\"keyword\">print</span> t <span class=\"comment\"># (1,)</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"无序集合类型\"><a href=\"#无序集合类型\" class=\"headerlink\" title=\"无序集合类型\"></a>无序集合类型</h3><h4 id=\"dict-类型\"><a href=\"#dict-类型\" class=\"headerlink\" title=\"dict 类型\"></a>dict 类型</h4><p>Python 中的 dict 类型类似于 JS 中的 {} (最大的不同是它是没有顺序的), 它有如下特点:</p>\n<ul>\n<li>查找速度快 (无论 dict 有 10 个元素还是 10 万个元素，查找速度都一样)</li>\n<li>占用内存大 (与 list 类型相反)</li>\n<li>dict 中的 key 不能重复</li>\n<li>dict 中存储的 key-value 序对是没有顺序的</li>\n</ul>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\">d = &#123;</span><br><span class=\"line\">    <span class=\"string\">'a'</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"string\">'b'</span>: <span class=\"number\">2</span>,</span><br><span class=\"line\">    <span class=\"string\">'c'</span>: <span class=\"number\">3</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">print</span> d <span class=\"comment\"># &#123;'a': 1, 'c': 3, 'b': 2&#125;  可以看出打印出的序对没有按正常的顺序打出</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 遍历 dict</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> key,value <span class=\"keyword\">in</span> d.items():</span><br><span class=\"line\">    print(<span class=\"string\">'%s: %s'</span> % (key,value))</span><br><span class=\"line\"><span class=\"comment\"># a: 1</span></span><br><span class=\"line\"><span class=\"comment\"># c: 3</span></span><br><span class=\"line\"><span class=\"comment\"># b: 2</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"set-类型\"><a href=\"#set-类型\" class=\"headerlink\" title=\"set 类型\"></a>set 类型</h4><p>有的时候，我们只想要 dict 的 key，不关心 key 对应的 value，而且要保证这个集合的元素不会重复，这时，set 类型就派上用场了。set 类型有如下特点：</p>\n<ul>\n<li>set 存储的元素和 dict 的 key 类似，必须是不变对象</li>\n<li>set 存储的元素也是没有顺序的</li>\n</ul>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\">s = set([<span class=\"string\">'A'</span>, <span class=\"string\">'B'</span>, <span class=\"string\">'C'</span>, <span class=\"string\">'C'</span>])</span><br><span class=\"line\"><span class=\"keyword\">print</span> s <span class=\"comment\"># set(['A', 'C', 'B'])</span></span><br><span class=\"line\"></span><br><span class=\"line\">s.add(<span class=\"string\">'D'</span>)</span><br><span class=\"line\"><span class=\"keyword\">print</span> s <span class=\"comment\"># set(['A', 'C', 'B', 'D'])</span></span><br><span class=\"line\"></span><br><span class=\"line\">s.remove(<span class=\"string\">'D'</span>)</span><br><span class=\"line\"><span class=\"keyword\">print</span> s <span class=\"comment\"># set(['A', 'C', 'B'])</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Python-中的迭代\"><a href=\"#Python-中的迭代\" class=\"headerlink\" title=\"Python 中的迭代\"></a>Python 中的迭代</h3><p>在介绍完 Python 中的有序集合和无序集合类型后，必然存在遍历集合的 for 循环。但是和其它语言的标准 for 循环不同，Python 中的所有迭代是通过 for … in 来完成的。以下给出一些常用的迭代 demos:</p>\n<p>索引迭代：</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\">L = [<span class=\"string\">'apple'</span>, <span class=\"string\">'banana'</span>, <span class=\"string\">'orange'</span>]</span><br><span class=\"line\"><span class=\"keyword\">for</span> index, name <span class=\"keyword\">in</span> enumerate(L):  <span class=\"comment\"># enumerate() 函数把 ['apple', 'banana', 'orange'] 变成了类似 [(0, 'apple), (1, 'banana'), (2, 'orange')] 的形式</span></span><br><span class=\"line\">    <span class=\"keyword\">print</span> index, <span class=\"string\">'-'</span>, name</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 0 - apple</span></span><br><span class=\"line\"><span class=\"comment\"># 1 - banana</span></span><br><span class=\"line\"><span class=\"comment\"># 2 - orange</span></span><br></pre></td></tr></table></figure>\n\n<p>迭代 dict 的 value:</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\">d = &#123; <span class=\"string\">'apple'</span>: <span class=\"number\">6</span>, <span class=\"string\">'banana'</span>: <span class=\"number\">8</span>, <span class=\"string\">'orange'</span>: <span class=\"number\">5</span> &#125;</span><br><span class=\"line\"><span class=\"keyword\">print</span> d.values() <span class=\"comment\"># [6, 8, 5]</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> v <span class=\"keyword\">in</span> d.values()</span><br><span class=\"line\">    <span class=\"keyword\">print</span> v</span><br><span class=\"line\"><span class=\"comment\"># 6</span></span><br><span class=\"line\"><span class=\"comment\"># 8</span></span><br><span class=\"line\"><span class=\"comment\"># 5</span></span><br></pre></td></tr></table></figure>\n\n<p>迭代 dict 的 key 和 value:</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\">d = &#123; <span class=\"string\">'apple'</span>: <span class=\"number\">6</span>, <span class=\"string\">'banana'</span>: <span class=\"number\">8</span>, <span class=\"string\">'orange'</span>: <span class=\"number\">5</span> &#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span> key, value <span class=\"keyword\">in</span> d.items()</span><br><span class=\"line\">    <span class=\"keyword\">print</span> key, <span class=\"string\">':'</span>, value</span><br><span class=\"line\"><span class=\"comment\"># apple : 6</span></span><br><span class=\"line\"><span class=\"comment\"># banana: 8</span></span><br><span class=\"line\"><span class=\"comment\"># orange: 5</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"切片操作符\"><a href=\"#切片操作符\" class=\"headerlink\" title=\"切片操作符\"></a>切片操作符</h3><p>Python 提供的切片操作符类似于 JS 提供的原生函数 slice()。有了切片操作符，大大简化了一些原来得用循环的操作。</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\">L = [<span class=\"string\">'apple'</span>, <span class=\"string\">'banana'</span>, <span class=\"string\">'orange'</span>, <span class=\"string\">'pear'</span>]</span><br><span class=\"line\">L[<span class=\"number\">0</span>:<span class=\"number\">2</span>] <span class=\"comment\"># ['apple', 'banana'] 取前 2 个元素</span></span><br><span class=\"line\">L[:<span class=\"number\">2</span>] <span class=\"comment\"># ['apple', 'banana'] 如果第一个索引是 0，可以省略</span></span><br><span class=\"line\">L[:] <span class=\"comment\"># ['apple', 'banana', 'orange', 'pear'] 只用一个 : ，表示从头到尾</span></span><br><span class=\"line\">L[::<span class=\"number\">2</span>] <span class=\"comment\"># ['apple', 'orange'] 第三个参数表示每 N 个取一个，这里表示从头开始，每 2 个元素取出一个来</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"列表生成器\"><a href=\"#列表生成器\" class=\"headerlink\" title=\"列表生成器\"></a>列表生成器</h3><p>如果要生成 [1x1, 2x2, 3x3, …, 10x10] 怎么做？方法一是循环：</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\">L = []</span><br><span class=\"line\"><span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, <span class=\"number\">11</span>):</span><br><span class=\"line\">    L.append(x * x)</span><br></pre></td></tr></table></figure>\n\n<p>但是循环太繁琐，而列表生成式则可以用一行语句代替循环生成上面的 list：</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 把要生成的元素 x * x 放到前面，后面跟 for 循环，就可以把 list 创建出来</span></span><br><span class=\"line\">[x * x <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, <span class=\"number\">11</span>)]</span><br><span class=\"line\"><span class=\"comment\"># [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</span></span><br></pre></td></tr></table></figure>\n\n<p>列表生成式的 for 循环后面还可以加上 if 判断(类似于 JS 中的 filter() 函数)，示例如下：</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\">[x * x <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, <span class=\"number\">11</span>) <span class=\"keyword\">if</span> x % <span class=\"number\">2</span> == <span class=\"number\">0</span>]</span><br><span class=\"line\"><span class=\"comment\"># [4, 16, 36, 64, 100]</span></span><br></pre></td></tr></table></figure>\n\n<p>for 循环可以嵌套，因此，在列表生成式中，也可以用多层 for 循环来生成列表。</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\">[m + n <span class=\"keyword\">for</span> m <span class=\"keyword\">in</span> <span class=\"string\">'ABC'</span> <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> <span class=\"string\">'123'</span>]</span><br><span class=\"line\"><span class=\"comment\"># ['A1', 'A2', 'A3', 'B1', 'B2', 'B3', 'C1', 'C2', 'C3']</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Python-函数\"><a href=\"#Python-函数\" class=\"headerlink\" title=\"Python 函数\"></a>Python 函数</h3><h4 id=\"默认参数\"><a href=\"#默认参数\" class=\"headerlink\" title=\"默认参数\"></a>默认参数</h4><p>JS 中 ES6 的 默认参数正是借鉴于 Python，用法如下：</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">greet</span><span class=\"params\">(name=<span class=\"string\">'World'</span>)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">'Hello, '</span> + name + <span class=\"string\">'.'</span></span><br><span class=\"line\"></span><br><span class=\"line\">greet() <span class=\"comment\"># Hello, World.</span></span><br><span class=\"line\">greet(<span class=\"string\">'Python'</span>) <span class=\"comment\"># Hello, Python.</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"可变参数\"><a href=\"#可变参数\" class=\"headerlink\" title=\"可变参数\"></a>可变参数</h4><p>类似于 JS 函数中自动识别传入参数的个数，Python 也提供了定义可变参数，即在可变参数的名字前面带上个 <code>*</code> 号。</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fn</span><span class=\"params\">(*args)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">print</span> args</span><br><span class=\"line\"></span><br><span class=\"line\">fn()  <span class=\"comment\"># ()</span></span><br><span class=\"line\">fn(<span class=\"string\">'a'</span>) <span class=\"comment\"># ('a',)</span></span><br><span class=\"line\">fn(<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>) <span class=\"comment\"># ('a', 'b')</span></span><br></pre></td></tr></table></figure>\n\n<p>Python 解释器会把传入的一组参数组装成一个 tuple 传递给可变参数，因此，在函数内部，直接把变量 args 看成一个 tuple 就好了。</p>\n<h4 id=\"常用高阶函数\"><a href=\"#常用高阶函数\" class=\"headerlink\" title=\"常用高阶函数\"></a>常用高阶函数</h4><p>Python 中常用的函数 (map、reduce、filter) 的作用和 JS 中一致，只是用法稍微不同。</p>\n<ul>\n<li>map 函数: 接收一个函数 f 和一个 list，并通过把函数 f 依次作用在 list 的每个元素上，得到一个新的 list 并返回。</li>\n</ul>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f</span><span class=\"params\">(x)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> x * x</span><br><span class=\"line\"><span class=\"keyword\">print</span> map(f, [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>]) <span class=\"comment\"># [1, 4, 9, 16, 25, 36, 49, 64, 81]</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>reduce 函数: 接收一个函数 f 和一个 list(可以接受第三个值作为初始值)，reduce() 对 list 的每个元素反复调用函数 f，并返回最终结果值。</li>\n</ul>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f</span><span class=\"params\">(x, y)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> x * y</span><br><span class=\"line\"></span><br><span class=\"line\">reduce(f, [<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>]) <span class=\"comment\"># 15</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>filter 函数: 接收一个函数 f 和一个list，这个函数 f 的作用是对每个元素进行判断，返回 True或 False，filter() 根据判断结果自动过滤掉不符合条件的元素，返回由符合条件元素组成的新 list。</li>\n</ul>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">is_odd</span><span class=\"params\">(x)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> x % <span class=\"number\">2</span> == <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">filter(is_odd, [<span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>, <span class=\"number\">12</span>, <span class=\"number\">17</span>]) <span class=\"comment\"># [1, 7, 9, 17]</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"匿名函数\"><a href=\"#匿名函数\" class=\"headerlink\" title=\"匿名函数\"></a>匿名函数</h4><p>和 JS 的匿名函数不同的地方是，Python 的匿名函数中只能有一个表达式，且不能写 return。拿 map() 函数为例：</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\">map(<span class=\"keyword\">lambda</span> x: x * x, [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>]) <span class=\"comment\"># [1, 4, 9, 16, 25, 36, 49, 64, 81]</span></span><br></pre></td></tr></table></figure>\n\n<p>关键词 lambda 表示匿名函数，冒号前面的 x 表示函数参数，可以看出匿名函数 <code>lambda x: x* x</code> 实际上就是:</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f</span><span class=\"params\">(x)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> x * x</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h4><p>之前写过一些关于 JS 闭包的文章，比如 <a href=\"http://www.cnblogs.com/MuYunyun/p/5930703.html\" target=\"_blank\" rel=\"noopener\">深入浅出JavaScript之闭包（Closure）</a>、以及 <a href=\"http://muyunyun.cn/posts/4a895cbd/\">读书笔记-你不知道的 JavaScript (上)</a>，Python 中闭包的定义和 JS 中的是一致的即：内层函数引用了外层函数的变量，然后返回内层函数。下面来看下 Py 中闭包之 for 循环经典问题：</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 希望一次返回3个函数，分别计算1x1,2x2,3x3:</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">count</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    fs = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, <span class=\"number\">4</span>):</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> i * i</span><br><span class=\"line\">        fs.append(f)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fs</span><br><span class=\"line\"></span><br><span class=\"line\">f1, f2, f3 = count() <span class=\"comment\"># 这种写法相当于 ES6 中的解构赋值</span></span><br><span class=\"line\"><span class=\"keyword\">print</span> f1(), f2(), f3() <span class=\"comment\"># 9 9 9</span></span><br></pre></td></tr></table></figure>\n\n<p>老问题了，f1(), f2(), f3() 结果不应该是 1, 4, 9 吗，实际结果为什么都是 9 呢？</p>\n<p>原因就是当 count() 函数返回了 3 个函数时，这 3 个函数所引用的变量 i 的值已经变成了 3。由于 f1、f2、f3 并没有被调用，所以，此时他们并未计算 i*i，当 f1 被调用时，i 已经变为 3 了。</p>\n<p>要正确使用闭包，就要确保引用的局部变量在函数返回后不能变。代码修改如下:</p>\n<p>方法一: 可以理解为创建了一个封闭的作用域，i 的 值传给 j 之后，就和 i 没任何关系了。每次循环形成的闭包都存进了内存中。</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">count</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    fs = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, <span class=\"number\">4</span>):</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f</span><span class=\"params\">(j)</span>:</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">g</span><span class=\"params\">()</span>:</span> <span class=\"comment\"># 方法一</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> j * j</span><br><span class=\"line\">            <span class=\"keyword\">return</span> g</span><br><span class=\"line\">        r = f(i)</span><br><span class=\"line\">        fs.append(r)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fs</span><br><span class=\"line\"></span><br><span class=\"line\">f1, f2, f3 = count()</span><br><span class=\"line\"><span class=\"keyword\">print</span> f1(), f2(), f3() <span class=\"comment\"># 1 4 9</span></span><br></pre></td></tr></table></figure>\n\n<p>方法二：思路比较巧妙，用到了默认参数 j 在函数定义时可以获取到 i 的值，虽然没有用到闭包，但是和方法一有异曲同工之处。</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">count</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    fs = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, <span class=\"number\">4</span>):</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f</span><span class=\"params\">(j = i)</span>:</span> <span class=\"comment\"># 方法二</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> j * j</span><br><span class=\"line\">        fs.append(f)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fs</span><br><span class=\"line\"></span><br><span class=\"line\">f1, f2, f3 = count()</span><br><span class=\"line\"><span class=\"keyword\">print</span> f1(), f2(), f3() <span class=\"comment\"># 1 4 9</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"decorator-装饰器\"><a href=\"#decorator-装饰器\" class=\"headerlink\" title=\"decorator 装饰器\"></a>decorator 装饰器</h4><p>ES6 的语法中的 decorator 正是借鉴了 \bPython 的 decorator。decorator 本质上就是<code>一个高阶函数，它接收一个函数作为参数，然后返回一个新函数</code>。</p>\n<p>那装饰器的作用在哪呢？先上一段日常项目中用 ts 写的网关代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">@Post(<span class=\"string\">'/rider/detail'</span>)  <span class=\"comment\">// URL 路由</span></span><br><span class=\"line\">@log()                   <span class=\"comment\">// 打印日志</span></span><br><span class=\"line\">  @ResponseBody</span><br><span class=\"line\">  public <span class=\"keyword\">async</span> getRiderBasicInfo(</span><br><span class=\"line\">    @RequestBody(<span class=\"string\">'riderId'</span>) riderId: number,</span><br><span class=\"line\">    @RequestBody(<span class=\"string\">'cityId'</span>) cityId: number,</span><br><span class=\"line\">  ) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> result = <span class=\"keyword\">await</span> <span class=\"keyword\">this</span>.riderManager.findDetail(cityId, riderId)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看出使用装饰器可以极大地简化代码，避免每个函数(比如日志、路由、性能检测)编写重复性代码。</p>\n<p>回到 Python 上，Python 提供的 @ 语法来使用 decorator，<code>@ 等价于 f = decorate(f)</code>。下面来看看 @log() 在 Python 中的实现:</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 我们想把调用的函数名字给打印出来</span></span><br><span class=\"line\"><span class=\"meta\">@log()</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">factorial</span><span class=\"params\">(n)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> reduce(<span class=\"keyword\">lambda</span> x,y: x*y, range(<span class=\"number\">1</span>, n+<span class=\"number\">1</span>))</span><br><span class=\"line\"><span class=\"keyword\">print</span> factorial(<span class=\"number\">10</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 来看看 @log() 的定义</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">log</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">log_decorator</span><span class=\"params\">(f)</span>:</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fn</span><span class=\"params\">(x)</span>:</span></span><br><span class=\"line\">            <span class=\"keyword\">print</span> <span class=\"string\">'调用了函数'</span> + f.__name__ + <span class=\"string\">'()'</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> f(x)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fn</span><br><span class=\"line\">    <span class=\"keyword\">return</span> log_decorator</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 结果</span></span><br><span class=\"line\"><span class=\"comment\"># 调用了函数 factorial()</span></span><br><span class=\"line\"><span class=\"comment\"># 3628800</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"class\"><a href=\"#class\" class=\"headerlink\" title=\"class\"></a>class</h3><h4 id=\"面向对象编程\"><a href=\"#面向对象编程\" class=\"headerlink\" title=\"面向对象编程\"></a>面向对象编程</h4><p>面向对象编程是一种程序设计范式，基本思想是：用类定义抽象类型，然后根据类的定义创建出实例。在掌握其它语言的基础上，还是比较容易理解这块知识点的，比如从下面两种写法可以看出不同语言的语言特性间竟然有如此多的共性。</p>\n<p>es6: (附：本文的主题是 python，所以只是初略展示下 js 中类的定义以及实例的创建，为了说明写法的相似性)</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(name, age) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.age = age</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> child1 = <span class=\"keyword\">new</span> Person(<span class=\"string\">'Xiao Ming'</span>, <span class=\"number\">10</span>)</span><br></pre></td></tr></table></figure>\n\n<p>Python: (核心要点写在注释中)</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 定义一个 Person 类：根据 Person 类就可以造成很多 child 实例</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    address = <span class=\"string\">'Earth'</span> <span class=\"comment\"># 类属性 (实例公有)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, name, age)</span>:</span> <span class=\"comment\"># 创建实例时，__init__()方法被自动调用</span></span><br><span class=\"line\">        self.name = name</span><br><span class=\"line\">        self.age = age</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_age</span><span class=\"params\">(self)</span>:</span> <span class=\"comment\"># 定义实例方法，它的第一个参数永远是 self，指向调用该方法的实例本身，其他参数和普通函数是一样的</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.age</span><br><span class=\"line\"></span><br><span class=\"line\">child1 = Person(<span class=\"string\">'Xiao Ming'</span>, <span class=\"number\">10</span>)</span><br><span class=\"line\">child2 = Person(<span class=\"string\">'Xiao Hong'</span>, <span class=\"number\">9</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">print</span> child1.name <span class=\"comment\"># 'Xiao Ming'</span></span><br><span class=\"line\"><span class=\"keyword\">print</span> child2.get_age() <span class=\"comment\"># 9</span></span><br><span class=\"line\"><span class=\"keyword\">print</span> child1.address <span class=\"comment\"># 'Earth'</span></span><br><span class=\"line\"><span class=\"keyword\">print</span> child2.address <span class=\"comment\"># 'Earth'</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h4><p>child 属于 Student 类，Student 类属于 People 类，这就引出了继承: 即获得了父类的方法属性后又能添加自己的方法属性。</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, name, age)</span>:</span></span><br><span class=\"line\">        self.name = name</span><br><span class=\"line\">        self.age = age</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span><span class=\"params\">(Person)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, name, age, grade)</span>:</span></span><br><span class=\"line\">        super(Student, self).__init__(name, age) <span class=\"comment\"># 这里也能写成 Person.__init__(self, name, age)</span></span><br><span class=\"line\">        self.grade = grade</span><br><span class=\"line\"></span><br><span class=\"line\">s = Student(<span class=\"string\">'Xiao Ming'</span>, <span class=\"number\">10</span>, <span class=\"number\">90</span>)</span><br><span class=\"line\"><span class=\"keyword\">print</span> s.name <span class=\"comment\"># 'Xiao Ming'</span></span><br><span class=\"line\"><span class=\"keyword\">print</span> s.grade <span class=\"comment\"># 90</span></span><br></pre></td></tr></table></figure>\n\n<p>可以看到子类在父类的基础上又增加了 grade 属性。我们可以再来看看 s 的类型。</p>\n<figure class=\"highlight py\"><table><tr><td class=\"code\"><pre><span class=\"line\">isinstance(s, Person)</span><br><span class=\"line\">isinstance(s, Student)</span><br></pre></td></tr></table></figure>\n\n<p>可以看出，Python 中在一条继承链上，一个实例可以看成它本身的类型，也可以看成它父类的类型。</p>\n","categories":["Python"],"tags":["Python"]},{"title":"尝试造了个工具类库，名为 Diana","url":"/posts/4490810f/","content":"<p><img src=\"http://with.muyunyun.cn/5aa428c1014d75db4d2d331fb2b41334.jpg-muyy\" alt=\"\"></p>\n<blockquote>\n<p>项目地址: <a href=\"https://github.com/MuYunyun/diana\" target=\"_blank\" rel=\"noopener\">diana</a></p>\n</blockquote>\n<blockquote>\n<p>文档地址: <a href=\"http://muyunyun.cn/diana/\">http://muyunyun.cn/diana/</a></p>\n</blockquote>\n<a id=\"more\"></a>\n<h3 id=\"造轮子的意义\"><a href=\"#造轮子的意义\" class=\"headerlink\" title=\"造轮子的意义\"></a>造轮子的意义</h3><p>为啥已经有如此多的前端工具类库还要自己造轮子呢？个人认为有以下几个观点吧：</p>\n<ul>\n<li>定制性强，能根据自己的需求为主导延伸开发。万一一不小心还能帮到别人（比如 React 库）；</li>\n<li>纸上得来终觉浅，很多流行的库，只是照着它们的 API 进行使用，其实这些库里蕴含着大量的知识、技巧，最好的办法就是仿照它们来写些小 demo，从而体会这些库的精髓；</li>\n<li>造轮子的过程中能让自己体会到与平常业务开发不一样的乐趣；比如和日常业务开发中很大的一个区别是会对测试用例具有比较严格的要求；而且写文档能力提升了。</li>\n<li>就先瞎编到这里了。。。</li>\n</ul>\n<p>抛开内部方法(写相应的专题效果可能会更好，所以这里先略过)，下面分享一些开发 <a href=\"https://github.com/MuYunyun/diana\" target=\"_blank\" rel=\"noopener\">diana 库</a> 时的一些心得：</p>\n<h3 id=\"项目目录结构\"><a href=\"#项目目录结构\" class=\"headerlink\" title=\"项目目录结构\"></a>项目目录结构</h3><figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\">├── <span class=\"selector-tag\">LICENSE</span>                  开源协议</span><br><span class=\"line\">├── <span class=\"selector-tag\">README-zh_en</span><span class=\"selector-class\">.md</span>          英文说明文档</span><br><span class=\"line\">├── <span class=\"selector-tag\">README</span><span class=\"selector-class\">.md</span>                中文说明文档</span><br><span class=\"line\">├── <span class=\"selector-tag\">coverage</span>                 代码覆盖率文件</span><br><span class=\"line\">├── <span class=\"selector-tag\">docs</span>                     文档目录</span><br><span class=\"line\">│   └── <span class=\"selector-tag\">static-parts</span></span><br><span class=\"line\">│       ├── <span class=\"selector-tag\">index-end</span><span class=\"selector-class\">.html</span>   静态文档目录结尾文件</span><br><span class=\"line\">│       └── <span class=\"selector-tag\">index-start</span><span class=\"selector-class\">.html</span> 静态文档目录开头文件</span><br><span class=\"line\">├── <span class=\"selector-tag\">karma</span><span class=\"selector-class\">.conf</span><span class=\"selector-class\">.js</span>            <span class=\"selector-tag\">karma</span> 配置文件</span><br><span class=\"line\">├── <span class=\"selector-tag\">lib</span></span><br><span class=\"line\">│   ├── <span class=\"selector-tag\">diana</span><span class=\"selector-class\">.back</span><span class=\"selector-class\">.js</span>        服务端引用入口</span><br><span class=\"line\">│   └── <span class=\"selector-tag\">diana</span><span class=\"selector-class\">.js</span>             浏览器引用入口</span><br><span class=\"line\">├── <span class=\"selector-tag\">package</span><span class=\"selector-class\">.json</span></span><br><span class=\"line\">├── <span class=\"selector-tag\">script</span></span><br><span class=\"line\">│   ├── <span class=\"selector-tag\">build</span><span class=\"selector-class\">.js</span>             构建文件</span><br><span class=\"line\">│   ├── <span class=\"selector-tag\">check</span><span class=\"selector-class\">.js</span>             结合 <span class=\"selector-tag\">pre-commit</span> 进行 <span class=\"selector-tag\">eslint</span> 校验</span><br><span class=\"line\">│   ├── <span class=\"selector-tag\">tag-script</span><span class=\"selector-class\">.js</span>        自动生成文档的标签</span><br><span class=\"line\">│   ├── <span class=\"selector-tag\">web-script</span><span class=\"selector-class\">.js</span>        自动生成文档</span><br><span class=\"line\">│   ├── <span class=\"selector-tag\">webpack</span><span class=\"selector-class\">.browser</span><span class=\"selector-class\">.js</span>   浏览器端 <span class=\"selector-tag\">webpack</span> 配置文件</span><br><span class=\"line\">│   └── <span class=\"selector-tag\">webpack</span><span class=\"selector-class\">.node</span><span class=\"selector-class\">.js</span>      服务器端 <span class=\"selector-tag\">webpack</span> 配置文件</span><br><span class=\"line\">├── <span class=\"selector-tag\">snippets</span></span><br><span class=\"line\">├── <span class=\"selector-tag\">src</span></span><br><span class=\"line\">│   ├── <span class=\"selector-tag\">browser</span>              浏览器端方法</span><br><span class=\"line\">│   ├── <span class=\"selector-tag\">common</span>               共用方法</span><br><span class=\"line\">│   ├── <span class=\"selector-tag\">node</span>                 <span class=\"selector-tag\">node</span> 端方法</span><br><span class=\"line\">│   └── <span class=\"selector-tag\">util</span><span class=\"selector-class\">.js</span>              库内通用方法</span><br><span class=\"line\">├── <span class=\"selector-tag\">tag_database</span>             文档标签</span><br><span class=\"line\">└── <span class=\"selector-tag\">test</span>                     测试文件</span><br><span class=\"line\">    ├── <span class=\"selector-tag\">browserTest</span></span><br><span class=\"line\">    ├── <span class=\"selector-tag\">commonTest</span></span><br><span class=\"line\">    ├── <span class=\"selector-tag\">index</span><span class=\"selector-class\">.js</span></span><br><span class=\"line\">    └── <span class=\"selector-tag\">nodeTest</span></span><br></pre></td></tr></table></figure>\n<p>目录结构也随着方法的增多在不停迭代当中，建议直接到<a href=\"https://github.com/MuYunyun/diana\" target=\"_blank\" rel=\"noopener\">库中</a>查看最新的目录结构。</p>\n<p>相应地，具体的方法会随着时间迭代，所以首先推荐查看<a href=\"http://muyunyun.cn/diana/\">文档</a>，点击如下图的 Ⓢ 就能查看源码。</p>\n<p><img src=\"http://with.muyunyun.cn/54db4bd9519dd7938b0cc38e0b9a50ea.jpg-300\" alt=\"\"></p>\n<h3 id=\"让模块同时在-Node-js-与浏览器中运行\"><a href=\"#让模块同时在-Node-js-与浏览器中运行\" class=\"headerlink\" title=\"让模块同时在 Node.js 与浏览器中运行\"></a>让模块同时在 Node.js 与浏览器中运行</h3><p>我们可以通过如下方法来判断模块当前是运行在 Node.js 还是浏览器中，然后使用不同的方式实现我们的功能。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Only Node.JS has a process variable that is of [[Class]] process</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> isNode = <span class=\"built_in\">Object</span>.prototype.toString.call(<span class=\"keyword\">typeof</span> process !== <span class=\"string\">'undefined'</span> ? process : <span class=\"number\">0</span>) === <span class=\"string\">'[object process]'</span></span><br></pre></td></tr></table></figure>\n\n<p>但如果用户使用了模块打包工具，这样做会导致 Node.js 与浏览器的实现方式都会被包含在最终的输出文件中。针对这个问题，开源社区提出了在 package.json 中添加 browser 字段的<a href=\"https://github.com/defunctzombie/package-browser-field-spec\" target=\"_blank\" rel=\"noopener\">提议</a>，目前 webpack 和 rollup 都已经支持这个字段了。</p>\n<p>给 browser 字段提供一个文件路径作为在浏览器端使用时的模块入口，但需要注意的是，打包工具会优先使用 browser 字段指定的文件路径作为模块入口，所以你的 main 字段 和 module 字段会被忽略，但是这会导致打包工具不会优化你的代码。详细信息请参考<a href=\"http://link.zhihu.com/?target=https%3A//github.com/webpack/webpack/issues/4674\">这个问题</a>。</p>\n<p>在 <a href=\"https://github.com/MuYunyun/diana\" target=\"_blank\" rel=\"noopener\">diana 库</a> 为了在不同环境中使用适当的文件，在 package.json 中进行了如下声明：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"browser\"</span>: <span class=\"string\">\"lib/diana.js\"</span>,</span><br><span class=\"line\"><span class=\"string\">\"main\"</span>: <span class=\"string\">\"lib/diana.back.js\"</span>, <span class=\"comment\">// 或者 \"module\": \"lib/diana.back.js\",</span></span><br></pre></td></tr></table></figure>\n\n<p>这样一来，在 node 环境中，引用的是 <code>lib/diana.back.js</code> 文件，在浏览器环境中，引用的是 <code>lib/diana.js</code> 文件。然后就能愉快地在浏览器端和 node 端愉快地使用自己特有的 api 了。</p>\n<h3 id=\"常见模块规范比较\"><a href=\"#常见模块规范比较\" class=\"headerlink\" title=\"常见模块规范比较\"></a>常见模块规范比较</h3><p>另外为了使 <a href=\"https://github.com/MuYunyun/diana\" target=\"_blank\" rel=\"noopener\">diana 库</a> 的打包文件兼容 node 端、以及浏览器端的引用，选择了 UMD 规范进行打包，那么为什么要选择 UMD 规范呢？让我们看下以下几种规范之间的异同：</p>\n<h4 id=\"CommonJS\"><a href=\"#CommonJS\" class=\"headerlink\" title=\"CommonJS\"></a>CommonJS</h4><ul>\n<li><p>CommonJs 是服务器端模块的规范，<code>Node.js 采用了这个规范</code>。这些规范涵盖了模块、二进制、Buffer、字符集编码、I/O流、进程环境、文件系统、套接字、单元测试、服务器网关接口、包管理等。</p>\n</li>\n<li><p>根据 CommonJS 规范，一个单独的文件就是一个模块。加载模块使用 <code>require</code> 方法，该方法读取一个文件并执行，最后返回文件内部的 <code>exports</code> 对象。</p>\n</li>\n<li><p>CommonJS 加载模块是同步的。像 Node.js 主要用于服务器的编程，加载的模块文件一般都已经存在本地硬盘，所以加载起来比较快，不用考虑异步加载的方式，所以 CommonJS 规范比较适用。但如果是浏览器环境，要从服务器加载模块，这是就必须采用异步模式。所以就有了 AMD、CMD 解决方案。</p>\n</li>\n</ul>\n<h4 id=\"AMD、CMD\"><a href=\"#AMD、CMD\" class=\"headerlink\" title=\"AMD、CMD\"></a>AMD、CMD</h4><ul>\n<li><p>AMD 是 RequireJS 在推广过程中对模块定义的规范化产物。AMD 推崇提前执行。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">// AMD 默认推荐的是</span></span><br><span class=\"line\">define([<span class=\"string\">'./a'</span>, <span class=\"string\">'./b'</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">  a.doSomething()</span><br><span class=\"line\">  b.doSomething()</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>CMD 是 SeaJS 在推广过程中对模块定义的规范化产物。CMD 推崇依赖就近。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// CMD</span></span><br><span class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require, exports, module</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = <span class=\"built_in\">require</span>(<span class=\"string\">'./a'</span>)</span><br><span class=\"line\">  a.doSomething()</span><br><span class=\"line\">  <span class=\"keyword\">var</span> b = <span class=\"built_in\">require</span>(<span class=\"string\">'./b'</span>)</span><br><span class=\"line\">  b.doSomething()</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h4 id=\"UMD\"><a href=\"#UMD\" class=\"headerlink\" title=\"UMD\"></a>UMD</h4><p>UMD 是 AMD 和 CommonJS 的结合。因为 AMD 是以浏览器为出发点的异步加载模块，CommonJS 是以服务器为出发点的同步加载模块，所以人们想出了另一个更通用的模式 UMD，来解决跨平台的问题。</p>\n<p><a href=\"https://github.com/MuYunyun/diana/blob/master/lib/diana.js#L1\" target=\"_blank\" rel=\"noopener\">diana 库</a> 选择了以 umd 方式进行输出，来看下 UMD 做了啥：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">root, factory</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> exports === <span class=\"string\">'object'</span> &amp;&amp; <span class=\"keyword\">typeof</span> <span class=\"built_in\">module</span> === <span class=\"string\">'object'</span>) &#123; <span class=\"comment\">// UMD 先判断是否支持 Node.js 的模块（exports）是否存在，存在则使用 CommonJS 模式</span></span><br><span class=\"line\">    <span class=\"built_in\">module</span>.exports = factory()</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> define === <span class=\"string\">'function'</span> &amp;&amp; define.amd) &#123; <span class=\"comment\">// 接着判断是否支持 AMD（define是否存在），存在则使用 AMD 方式加载模块。</span></span><br><span class=\"line\">    define([], factory)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> exports === <span class=\"string\">'object'</span>) &#123; <span class=\"comment\">// CommonJS 的另一种形式</span></span><br><span class=\"line\">    exports[<span class=\"string\">'diana'</span>] = factory()</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span></span><br><span class=\"line\">    root[<span class=\"string\">'diana'</span>] = factory() <span class=\"comment\">// Window</span></span><br><span class=\"line\">&#125;)(<span class=\"keyword\">this</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">module</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"测试踩坑之路\"><a href=\"#测试踩坑之路\" class=\"headerlink\" title=\"测试踩坑之路\"></a>测试踩坑之路</h3><h4 id=\"代码覆盖率\"><a href=\"#代码覆盖率\" class=\"headerlink\" title=\"代码覆盖率\"></a>代码覆盖率</h4><p>单元测试的代码覆盖率统计，是衡量测试用例好坏的一个的方法。但凡是线上用的库，基本上都少不了高质量的代码覆盖率的检测。如下图为 diana 库的测试覆盖率展示。</p>\n<p><img src=\"http://with.muyunyun.cn/7efbacda331e914df3eedb3670b747a8.jpg-400\" alt=\"\"></p>\n<p>可以看到覆盖率分为以下 4 种类型，</p>\n<ul>\n<li>行覆盖率（line coverage）：是否每一行都执行了？</li>\n<li>函数覆盖率（function coverage）：是否每个函数都调用了？</li>\n<li>分支覆盖率（branch coverage）：是否每个if代码块都执行了？</li>\n<li>语句覆盖率（statement coverage）：是否每个语句都执行了？</li>\n</ul>\n<p>番外：github 上显示的覆盖率是根据行覆盖率来展示的。<br><a href=\"https://codecov.io/gh/MuYunyun/diana\" target=\"_blank\" rel=\"noopener\"><img src=\"https://codecov.io/gh/MuYunyun/diana/branch/master/graph/badge.svg\" alt=\"codecov\"></a></p>\n<h4 id=\"mocha-istanbul\"><a href=\"#mocha-istanbul\" class=\"headerlink\" title=\"mocha + istanbul\"></a>mocha + istanbul</h4><p><a href=\"https://github.com/MuYunyun/diana/blob/d81991f588046b428e2ac959fb6b87e6edb4938e/package.json#L23\" target=\"_blank\" rel=\"noopener\">最初的版本</a>, 仅仅用到 mocha 进行测试 *.test.js 文件，然后在 <a href=\"https://codecov.io/gh/MuYunyun/diana\" target=\"_blank\" rel=\"noopener\">codecov</a> 得到测试覆盖率。</p>\n<h4 id=\"引人-karma\"><a href=\"#引人-karma\" class=\"headerlink\" title=\"引人 karma\"></a>引人 karma</h4><p>如果仅仅测试 es5、es6 的语法，其实用 mocha 就已经够用了，但是涉及到测试 Dom 操作的语法等就必须建立一个浏览器，在上面进行测试。karma 的作用其实就是自动帮我们建立一个测试用的浏览器环境。</p>\n<p>为了让浏览器支持 Common.js 规范，中间用了 karma + browserify，尽管测试用例都跑通了，但是最后的代码覆盖率的文件里只有各个方法的引用路径。最后只能又回到 karma + webpack 来，这里又踩到一个坑，<a href=\"https://segmentfault.com/a/1190000004283830\" target=\"_blank\" rel=\"noopener\">打包编译JS代码覆盖率问题</a>，踩了一些坑后，终于实现了可以查看编译前代码的覆盖率。图如下：</p>\n<p><img src=\"http://with.muyunyun.cn/e0ba39166c6999a3c3ce76bc63f511aa.jpg-400\" alt=\"\"></p>\n<p>通过这幅图我们能清晰地看到源代码中测试用例跑过各行代码的次数(左侧的数字)，以及测试用例没有覆盖到的代码(图中红色所示)。然后我们就能改善相应的测试用例从而提高测试覆盖率。</p>\n<p><a href=\"https://github.com/MuYunyun/diana/blob/master/karma.conf.js\" target=\"_blank\" rel=\"noopener\">配置文件</a>，核心部分如下:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">config</span>) </span>&#123;</span><br><span class=\"line\">  config.set(&#123;</span><br><span class=\"line\">    files: [<span class=\"string\">'test/index.js'</span>], <span class=\"comment\">// 需载入浏览器的文件</span></span><br><span class=\"line\">    preprocessors: &#123; <span class=\"comment\">// 预处理</span></span><br><span class=\"line\">      <span class=\"string\">'test/index.js'</span>: [<span class=\"string\">'webpack'</span>, <span class=\"string\">'coverage'</span>]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    webpack: &#123;</span><br><span class=\"line\">      <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">        rules: [&#123;</span><br><span class=\"line\">          test: <span class=\"regexp\">/\\.js$/</span>,</span><br><span class=\"line\">          use: &#123; <span class=\"attr\">loader</span>: <span class=\"string\">'sourcemap-istanbul-instrumenter-loader'</span> &#125;, <span class=\"comment\">// 这里用 istanbul-instrumenter-loader 插件的 0.0.2 版本，其它版本有坑~</span></span><br><span class=\"line\">          exclude: [<span class=\"regexp\">/node_modules/</span>, /\\.spec.js$/],</span><br><span class=\"line\">        &#125;],</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    coverageReporter: &#123;</span><br><span class=\"line\">      type: <span class=\"string\">'lcov'</span>, <span class=\"comment\">// 貌似只能支持这种类型的读取</span></span><br><span class=\"line\">      dir: <span class=\"string\">'coverage/'</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    remapIstanbulReporter: &#123; <span class=\"comment\">// 生成 coverage 文件</span></span><br><span class=\"line\">      reports: &#123;</span><br><span class=\"line\">        <span class=\"string\">'text-summary'</span>: <span class=\"literal\">null</span>,</span><br><span class=\"line\">        json: <span class=\"string\">'coverage/coverage.json'</span>,</span><br><span class=\"line\">        lcovonly: <span class=\"string\">'coverage/lcov.info'</span>,</span><br><span class=\"line\">        html: <span class=\"string\">'coverage/html/'</span>,</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    reporters: [<span class=\"string\">'progress'</span>, <span class=\"string\">'karma-remap-istanbul'</span>], <span class=\"comment\">// remap-isbanbul 也报了一个未找到 sourcemap 的 error，直接注释了 remap-istanbul 包的 CoverageTransformer.js 文件的 169 行，以后有机会再捣鼓吧。（心累）</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>本文围绕 <a href=\"https://github.com/MuYunyun/diana\" target=\"_blank\" rel=\"noopener\">diana 库</a> 对造轮子的意义，模块兼容性，测试用例进行了思考总结。后续会对该库流程自动化以及性能上做些分享。<br>该库参考学习了很多优秀的库，感谢 <a href=\"https://github.com/jashkenas/underscore\" target=\"_blank\" rel=\"noopener\">underscore</a>、<a href=\"https://github.com/proYang/outils\" target=\"_blank\" rel=\"noopener\">outils</a>、<a href=\"https://github.com/chenhuiYj/ec-do\" target=\"_blank\" rel=\"noopener\">ec-do</a>、<a href=\"https://github.com/Chalarangelo/30-seconds-of-code\" target=\"_blank\" rel=\"noopener\">30-seconds-of-code</a> 等库对我的帮助。</p>\n<p>最后欢迎各位大佬在 <a href=\"https://github.com/MuYunyun/diana/issues\" target=\"_blank\" rel=\"noopener\">issues</a> 尽情吐槽。</p>\n","categories":["轮子"],"tags":["JavaScript","轮子"]},{"title":"读书笔记-你不知道的 JavaScript (上)","url":"/posts/4a895cbd/","content":"<p><img src=\"http://with.muyunyun.cn/a56029ee73c05e0f2897e6a1b574dc52.jpg-muyy\" alt=\"\"></p>\n<p>《你不知道的JavaScript》系列丛书给出了很多颠覆以往对JavaScript认知的点, 读完上卷，受益匪浅，于是对其精华的知识点进行了梳理。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"什么是作用域\"><a href=\"#什么是作用域\" class=\"headerlink\" title=\"什么是作用域\"></a>什么是作用域</h2><p>作用域是一套规则，用于确定在何处以及如何查找变量。</p>\n<h3 id=\"编译原理\"><a href=\"#编译原理\" class=\"headerlink\" title=\"编译原理\"></a>编译原理</h3><p>JavaScript是一门编译语言。在传统编译语言的流程中，程序中一段源代码在执行之前会经历三个步骤，统称为“编译”。</p>\n<ul>\n<li>分词/词法分析<br>将字符串分解成有意义的代码块，代码块又称词法单元。比如程序<code>var a = 2;</code>会被分解为<code>var、a、=、2、;</code></li>\n<li>解析/语法分析<br>将词法单元流转换成一个由元素逐级嵌套所组成的代表了程序语法接口的书，又称“抽象语法树”。</li>\n<li>代码生成<br>将抽象语法树转换为机器能够识别的指令。</li>\n</ul>\n<h3 id=\"理解作用域\"><a href=\"#理解作用域\" class=\"headerlink\" title=\"理解作用域\"></a>理解作用域</h3><p>作用域 分别与编译器、引擎进行配合完成代码的解析</p>\n<ul>\n<li>引擎执行时会与作用域进行交流，确定RHS与LHS查找具体变量，如果查找不到会抛出异常。</li>\n<li>编译器负责语法分析以及生成代码。</li>\n<li>作用域负责收集并维护所有变量组成的一系列查询，并确定当前执行的代码对这些变量的访问权限。</li>\n</ul>\n<p>对于 <code>var a = 2</code> 这条语句，首先编译器会将其分为两部分，一部分是 <code>var a</code>，一部分是 <code>a = 2</code>。编译器会在编译期间执行 var a，然后到作用域中去查找 a 变量，如果 a 变量在作用域中还没有声明，那么就在作用域中声明 a 变量，如果 a 变量已经存在，那就忽略 var a 语句。然后编译器会为 a = 2 这条语句生成执行代码，以供引擎执行该赋值操作。所以我们平时所提到的变量提升，无非就是利用这个先声明后赋值的原理而已！</p>\n<h3 id=\"异常\"><a href=\"#异常\" class=\"headerlink\" title=\"异常\"></a>异常</h3><p>对于 <code>var a = 10</code> 这条赋值语句，实际上是为了查找变量 a， 并且将 10 这个数值赋予它，这就是 <code>LHS</code> 查询。 对于 <code>console.log(a)</code> 这条语句，实际上是为了查找 a 的值并将其打印出来，这是 <code>RHS</code> 查询。</p>\n<p>为什么区分 <code>LHS</code> 和 <code>RHS</code> 是一件重要的事情？<br>在非严格模式下，LHS 调用查找不到变量时会创建一个全局变量，RHS 查找不到变量时会抛出 ReferenceError。 在严格模式下，LHS 和 RHS 查找不到变量时都会抛出 ReferenceError。</p>\n<h2 id=\"作用域的工作模式\"><a href=\"#作用域的工作模式\" class=\"headerlink\" title=\"作用域的工作模式\"></a>作用域的工作模式</h2><p>作用域共有两种主要的工作模型。第一种是最为普遍的，被大多数编程语言所采用的词法作用域( JavaScript 中的作用域就是词法作用域)。另外一种是动态作用域，仍有一些编程语言在使用(比如Bash脚本、Perl中的一些模式等)。</p>\n<h3 id=\"词法作用域\"><a href=\"#词法作用域\" class=\"headerlink\" title=\"词法作用域\"></a>词法作用域</h3><p>词法作用域是一套关于引擎如何寻找变量以及会在何处找到变量的规则。词法作用域最重要的特征是它的定义过程发生在代码的书写阶段(假设没有使用 eval() 或 with )。来看示例代码:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(a);  <span class=\"comment\">// 2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = <span class=\"number\">3</span>;</span><br><span class=\"line\">  foo();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">bar()</span><br></pre></td></tr></table></figure>\n<p>词法作用域让foo()中的a通过RHS引用到了全局作用域中的a，因此会输出2。</p>\n<h3 id=\"动态作用域\"><a href=\"#动态作用域\" class=\"headerlink\" title=\"动态作用域\"></a>动态作用域</h3><p>而动态作用域只关心它们从何处调用。换句话说，作用域链是基于调用栈的，而不是代码中的作用域嵌套。因此，如果 JavaScript 具有动态作用域，理论上，下面代码中的 foo() 在执行时将会输出3。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(a);  <span class=\"comment\">// 3</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = <span class=\"number\">3</span>;</span><br><span class=\"line\">  foo();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">bar()</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"函数作用域\"><a href=\"#函数作用域\" class=\"headerlink\" title=\"函数作用域\"></a>函数作用域</h2><h3 id=\"匿名与具名\"><a href=\"#匿名与具名\" class=\"headerlink\" title=\"匿名与具名\"></a>匿名与具名</h3><p>对于函数表达式一个最熟悉的场景可能就是回调函数了，比如</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">setTimeout( <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"I waited 1 second!\"</span>)</span><br><span class=\"line\">&#125;, <span class=\"number\">1000</span> )</span><br></pre></td></tr></table></figure>\n<p>这叫作<code>匿名函数表达式</code>。函数表达式可以匿名，而函数声明则不可以省略函数名。匿名函数表达式书写起来简单快捷,很多库和工具也倾向鼓励使用这种风格的代码。但它也有几个缺点需要考虑。</p>\n<ul>\n<li>匿名函数在栈追踪中不会显示出有意义的函数名,使得调试很困难。</li>\n<li>如果没有函数名,当函数需要引用自身时只能使用已经过期的 arguments.callee 引用,比如在递归中。另一个函数需要引用自身的例子,是在事件触发后事件监听器需要解绑自身。</li>\n<li>匿名函数省略了对于代码可读性 / 可理解性很重要的函数名。一个描述性的名称可以让代码不言自明。</li>\n</ul>\n<p>始终给函数表达式命名是一个最佳实践:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">setTimeout( <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timeoutHandler</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// 我有名字了</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"I waited 1 second!\"</span>)</span><br><span class=\"line\">&#125;, <span class=\"number\">1000</span> )</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"提升\"><a href=\"#提升\" class=\"headerlink\" title=\"提升\"></a>提升</h2><h3 id=\"先有声明还是先有赋值\"><a href=\"#先有声明还是先有赋值\" class=\"headerlink\" title=\"先有声明还是先有赋值\"></a>先有声明还是先有赋值</h3><p>考虑以下代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">a = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n<p>考虑另外一段代码</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure>\n<p>我们习惯将 var a = 2; 看作一个声明，而实际上 JavaScript 引擎并不这么认为。它将 var a 和 a = 2 当作两个单独的声明，第一个是编译阶段的任务，而第二个是执行阶段的任务。<br>这意味着无论作用域中的声明出现在什么地方，都将在代码本身被执行前首先进行处理。可以将这个过程形象地想象成所有的声明（变量和函数）都会被“移动”到各自作用域的最顶端，这个过程称为提升。</p>\n<p>可以看出，先有声明后有赋值。</p>\n<p>再来看以下代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">foo();  <span class=\"comment\">// TypeError</span></span><br><span class=\"line\">bar();  <span class=\"comment\">// ReferenceError</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>这个代码片段经过提升后，实际上会被理解为以下形式:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo;</span><br><span class=\"line\"></span><br><span class=\"line\">foo();  <span class=\"comment\">// TypeError</span></span><br><span class=\"line\">bar();  <span class=\"comment\">// ReferenceError</span></span><br><span class=\"line\"></span><br><span class=\"line\">foo = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> bar = ...self...</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>这段程序中的变量标识符 foo() 被提升并分配给全局作用域，因此 foo() 不会导致 ReferenceError。但是 foo 此时并没有赋值(如果它是一个<code>函数声明而不是函数表达式就会赋值</code>)。foo()由于对 undefined 值进行函数调用而导致非法操作，因此抛出 TypeError 异常。另外即时是具名的函数表达式，名称标识符(这里是 bar )在赋值之前也无法在所在作用域中使用。</p>\n<h2 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h2><p>之前写过关于闭包的一篇文章<a href=\"http://www.cnblogs.com/MuYunyun/p/5930703.html\" target=\"_blank\" rel=\"noopener\">深入浅出JavaScript之闭包(Closure)</a></p>\n<h3 id=\"循环和闭包\"><a href=\"#循环和闭包\" class=\"headerlink\" title=\"循环和闭包\"></a>循环和闭包</h3><p>要说明闭包，for 循环是最常见的例子。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">1</span>; i &lt;= <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">  setTimeout( <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timer</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(i);</span><br><span class=\"line\">  &#125;, i*<span class=\"number\">1000</span> )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>正常情况下，我们对这段代码行为的预期是分别输出数字 1~5，每秒一次，每次一个。但实际上，这段代码在运行时会以每秒一次的频率输出五次6。</p>\n<p>它的缺陷在于：根据作用域的工作原理，尽管循环中的五个函数是在各个迭代中分别定义的，但是它们都被封闭在一个共享的全局作用域中，因此实际上只有一个i。因此我们需要更多的闭包作用域。我们知道IIFE会通过声明并立即执行一个函数来创建作用域，我们来进行改进：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">1</span>; i &lt;= <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">  (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> j = i;</span><br><span class=\"line\">    setTimeout( <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timer</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(j);</span><br><span class=\"line\">    &#125;, j*<span class=\"number\">1000</span> )</span><br><span class=\"line\">  &#125;)();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>还可以对这段代码进行一些改进：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">1</span>; i &lt;= <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">  (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">j</span>) </span>&#123;</span><br><span class=\"line\">    setTimeout( <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timer</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(j);</span><br><span class=\"line\">    &#125;, j*<span class=\"number\">1000</span> )</span><br><span class=\"line\">  &#125;)(i);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在迭代内使用 IIFE 会为每个迭代都生成一个新的作用域，使得延迟函数的回调可以将新的作用域封闭在每个迭代内部，每个迭代中都会含有一个具有正确值的变量供我们访问。</p>\n<h4 id=\"重返块作用域\"><a href=\"#重返块作用域\" class=\"headerlink\" title=\"重返块作用域\"></a>重返块作用域</h4><p>我们使用 IIFE 在每次迭代时都创建一个新的作用域。换句话说，每次迭代我们都需要一个块作用域。我们知道 let 声明可以用来劫持块作用域，那我们可以进行这样改：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">1</span>; i &lt;= <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> j = i;</span><br><span class=\"line\">  setTimeout( <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timer</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(j);</span><br><span class=\"line\">  &#125;, j*<span class=\"number\">1000</span> )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>本质上这是将一个块转换成一个可以被关闭的作用域。</p>\n<p>此外，for循环头部的 let 声明还会有一个特殊行为。这个行为指出每个迭代都会使用上一个迭代结束时的值来初始化这个变量。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt;= <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">  setTimeout( <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timer</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(i);</span><br><span class=\"line\">  &#125;, i*<span class=\"number\">1000</span> )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"this全面解析\"><a href=\"#this全面解析\" class=\"headerlink\" title=\"this全面解析\"></a>this全面解析</h2><p>之前写过一篇<a href=\"http://www.cnblogs.com/MuYunyun/p/5932024.html\" target=\"_blank\" rel=\"noopener\">深入浅出JavaScript之this</a>。我们知道this是在运行时进行绑定的，并不是在编写时绑定，它的上下文取决于函数调用时的各种条件。this的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。</p>\n<h3 id=\"this词法\"><a href=\"#this词法\" class=\"headerlink\" title=\"this词法\"></a>this词法</h3><p>来看下面这段代码的问题：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  id: <span class=\"string\">\"awesome\"</span>,</span><br><span class=\"line\">  cool: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">coolFn</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.id);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> id = <span class=\"string\">\"not awesome\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">obj.cool();  <span class=\"comment\">// awesome</span></span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout( obj.cool, <span class=\"number\">100</span>); <span class=\"comment\">// not awesome</span></span><br></pre></td></tr></table></figure>\n<p>obj.cool() 与 setTimeout( obj.cool, 100 ) 输出结果不一样的原因在于 cool() 函数丢失了同 this 之间的绑定。解决方法最常用的是 var self = this;</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  count: <span class=\"number\">0</span>,</span><br><span class=\"line\">  cool: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">coolFn</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> self = <span class=\"keyword\">this</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (self.count &lt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">      setTimeout( <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timer</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        self.count++;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">\"awesome?\"</span>);</span><br><span class=\"line\">      &#125;, <span class=\"number\">100</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">obj.cool(); <span class=\"comment\">// awesome?</span></span><br></pre></td></tr></table></figure>\n<p>这里用到的知识点是我们非常熟悉的词法作用域。self 只是一个可以通过词法作用域和闭包进行引用的标识符，不关心 this 绑定的过程中发生了什么。</p>\n<p>ES6 中的箭头函数引人了一个叫作 this 词法的行为：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  count: <span class=\"number\">0</span>,</span><br><span class=\"line\">  cool: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">coolFn</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.count &lt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">      setTimeout( <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.count++;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">\"awesome?\"</span>);</span><br><span class=\"line\">      &#125;, <span class=\"number\">100</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">obj.cool(); <span class=\"comment\">// awesome?</span></span><br></pre></td></tr></table></figure>\n<p>箭头函数弃用了所有普通 this 绑定规则，取而代之的是用当前的词法作用域覆盖了 this 本来的值。因此，这个代码片段中的箭头函数只是”继承”了 cool() 函数的 this 绑定。</p>\n<p>但是箭头函数的缺点就是因为其是匿名的，上文已介绍过具名函数比匿名函数更可取的原因。而且箭头函数将程序员们经常犯的一个错误给标准化了：混淆了 this 绑定规则和词法作用域规则。</p>\n<p>箭头函数不仅仅意味着可以少写代码。本书的作者认为使用 bind() 是更靠得住的方式。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  count: <span class=\"number\">0</span>,</span><br><span class=\"line\">  cool: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">coolFn</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.count &lt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">      setTimeout( <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.count++;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">\"more awesome\"</span>);</span><br><span class=\"line\">      &#125;.bind( <span class=\"keyword\">this</span> ), <span class=\"number\">100</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">obj.cool(); <span class=\"comment\">// more awesome</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"绑定规则\"><a href=\"#绑定规则\" class=\"headerlink\" title=\"绑定规则\"></a>绑定规则</h3><p>函数在执行的过程中，可以根据下面这4条绑定规则来判断 this 绑定到哪。</p>\n<ul>\n<li>默认绑定<ul>\n<li>独立函数调用</li>\n</ul>\n</li>\n<li>隐式绑定<ul>\n<li>当函数引用有上下文对象时，隐式绑定规则会把函数调用中的 this 绑定到这个上下文对象</li>\n</ul>\n</li>\n<li>显示绑定<ul>\n<li>call/apply</li>\n<li>bind（本质是对call/apply函数的封装 <code>fn.apply( obj, arguments )</code>）</li>\n<li>第三方库的许多函数都提供了一个可选的参数(上下文)，其作用和 bind() 一样，确保回调函数使用指定的 this</li>\n</ul>\n</li>\n<li>new 绑定<ul>\n<li>JavaScript 中的 new 机制实际上和面向类的语言完全不同</li>\n<li>实际上并不存在所谓的“构造函数”，只有对于函数的“构造调用”</li>\n</ul>\n</li>\n</ul>\n<p>书中对4条绑定规则的优先级进行了验证，得出以下的顺序优先级:</p>\n<ul>\n<li>函数是否在 new 中调用（new 绑定）？如果是的话 this 绑定的是新创建的对象。</li>\n<li>函数是否通过 call、apply（显式绑定）或者硬绑定（bind）调用？如果是的话，this 绑定的是指定对象。</li>\n<li>函数是否在某个上下文对象中调用（隐式绑定）？如果是的话，this 绑定的是那个上下文对象。</li>\n<li>如果都不是的话，使用默认绑定。在严格模式下，绑定到 undefined，否则绑定到全局对象。</li>\n</ul>\n<h3 id=\"被忽略的-this\"><a href=\"#被忽略的-this\" class=\"headerlink\" title=\"被忽略的 this\"></a>被忽略的 this</h3><p>如果你把 null 或者 undefined 作为 this 的绑定对象传入 call、apply 或者 bind，这些值在调用时会被忽略，实际应用的是默认规则。</p>\n<p>什么时候会传入 null/undefined 呢？一种非常常见的做法是用 apply(..) 来“展开”一个数组，并当作参数传入一个函数。类似地，bind(..) 可以对参数进行柯里化(预先设置一些参数),如下代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log( <span class=\"string\">\"a:\"</span> + a + <span class=\"string\">\", b:\"</span> + b );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 把数组\"展开\"成参数</span></span><br><span class=\"line\">foo.apply(<span class=\"literal\">null</span>, [<span class=\"number\">2</span>, <span class=\"number\">3</span>]); <span class=\"comment\">// a:2, b:3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用 bind(..) 进行柯里化</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = foo.bind( <span class=\"literal\">null</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">bar(<span class=\"number\">3</span>); <span class=\"comment\">// a:2, b:3</span></span><br></pre></td></tr></table></figure>\n<p>其中 ES6 中，可以用 … 操作符代替 apply(..) 来“展开”数组，但是 ES6 中没有柯里化的相关语法，因此还是需要使用 bind(..)。</p>\n<p>使用 null 来忽略 this 绑定可能产生一些副作用。如果某个函数(比如第三库中的某个函数)确实使用了 this ，默认绑定规则会把 this 绑定到全局对象，这将导致不可预计的后果。更安全的做法是传入一个特殊的对象，一个 “DMZ” 对象，一个空的非委托对象，即 Object.create(null)。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log( <span class=\"string\">\"a:\"</span> + a + <span class=\"string\">\", b:\"</span> + b );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> ø = <span class=\"built_in\">Object</span>.create(<span class=\"literal\">null</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 把数组\"展开\"成参数</span></span><br><span class=\"line\">foo.apply( ø, [<span class=\"number\">2</span>, <span class=\"number\">3</span>]); <span class=\"comment\">// a:2, b:3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用 bind(..) 进行柯里化</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = foo.bind( ø, <span class=\"number\">2</span>);</span><br><span class=\"line\">bar(<span class=\"number\">3</span>); <span class=\"comment\">// a:2, b:3</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h2><p>JavaScript中的对象有字面形式（比如<code>var a = { .. }</code>)和构造形式（比如<code>var a = new Array(..)</code>）。字面形式更常用，不过有时候构造形式可以提供更多选择。</p>\n<p>作者认为“JavaScript中万物都是对象”的观点是不对的。因为对象只是 6 个基础类型( string、number、boolean、null、undefined、object )之一。对象有包括 function 在内的子对象，不同子类型具有不同的行为，比如内部标签 [object Array] 表示这是对象的子类型数组。</p>\n<h3 id=\"复制对象\"><a href=\"#复制对象\" class=\"headerlink\" title=\"复制对象\"></a>复制对象</h3><p>首先看下这个对象：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'XiaoMing'</span>,</span><br><span class=\"line\">  habits:  [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从这个对象，先抛出下面几个概念：</p>\n<ul>\n<li>普通的 = 赋值：b = a，如果修改了 b.name，那么 a.name 也会改变</li>\n<li>浅复制：如果修改了 b.name, a.name 不会改变，但是修改 b.habits 数组中的值，a.habits 的值也会改变</li>\n<li>深复制：b 的值改变，不会对 a 产生任何影响</li>\n</ul>\n<p>对于 JSON 安全的对象(就是能用 JSON.stringify 序列号的字符串)来说，有一种巧妙的深复制方法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> newObj = <span class=\"built_in\">JSON</span>.parse( <span class=\"built_in\">JSON</span>.stringify(someObj) )</span><br></pre></td></tr></table></figure>\n\n<p>但是这个方法存在以下坑：</p>\n<ol>\n<li><p>如果对象里面有循环引用，会抛错</p>\n</li>\n<li><p>不能复制对象里面的 Date、Function、RegExp</p>\n</li>\n<li><p>所有的构造函数会指向 Object</p>\n</li>\n</ol>\n<p>看下面这个对象：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">anotherFunction</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">/*..*/</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> anotherObject = &#123;</span><br><span class=\"line\">  c: <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> anotherArray = [];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> myObject = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">2</span>,</span><br><span class=\"line\">  b: anotherObject, <span class=\"comment\">// 引用，不是复本！</span></span><br><span class=\"line\">  c: anotherArray, <span class=\"comment\">// 另一个引用！</span></span><br><span class=\"line\">  d: anotherFunction</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">anotherArray.push( myObject )</span><br></pre></td></tr></table></figure>\n<p>如何准确地表示 myObject 的复制呢？</p>\n<p>这个例子中除了复制 myObject 以外还会复制 anotherArray。这时问题就来了，anotherArray 引用了 myObject, 所以又需要复制 myObject，这样就会由于循环引用导致死循环。该如何解决呢？</p>\n<p>可以查看在 <a href=\"https://github.com/MuYunyun/diana/blob/master/src/common/lang/cloneDeep.js\" target=\"_blank\" rel=\"noopener\">diana 库中的实践</a>。</p>\n<p>相比于深复制，浅复制非常易懂并且问题要少得多，ES6 定义了 Object.assign(..) 方法来实现浅复制。 Object.assign(..) 方法的第一个参数是目标对象，之后还可以跟一个或多个源对象。它会遍历一个或多个源对象的所有可枚举的自由键并把它们复制到目标对象，最后返回目标对象，就像这样：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> newObj = <span class=\"built_in\">Object</span>.assign( &#123;&#125;, myObject );</span><br><span class=\"line\"></span><br><span class=\"line\">newObj.a; <span class=\"comment\">// 2</span></span><br><span class=\"line\">newObj.b === anotherObject; <span class=\"comment\">// true</span></span><br><span class=\"line\">newObj.c === anotherArray; <span class=\"comment\">// true</span></span><br><span class=\"line\">newObj.d === anotherFunction; <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"类\"><a href=\"#类\" class=\"headerlink\" title=\"类\"></a>类</h2><p>JavaScript 有一些近似类的语法元素（比如 new 和 instanceof）, 后来的 ES6 中新增了一些如 class 的关键字。但是 JavaScript 实际上并没有类。类是一种设计模式，JavaScript 的机制其实和类完全不同。</p>\n<ul>\n<li>类的继承(委托)其实就是复制，但和其他语言中类的表现不同(其他语言类表现出来的都是复制行为)，JavaScript 中的多态（在继承链中不同层次名称相同，但是功能不同的函数）并不表示子类和父类有关联，子类得到的只是父类的一份复本。</li>\n<li>JavaScript 通过显示混入和隐式混入 call() 来模拟其他语言类的表现。此外，显示混入实际上无法完全模拟类的复制行为，因为对象(和函数！别忘了函数也是对象)只能复制引用，无法复制被引用的对象或者函数本身。</li>\n</ul>\n<h3 id=\"检查“类”关系\"><a href=\"#检查“类”关系\" class=\"headerlink\" title=\"检查“类”关系\"></a>检查“类”关系</h3><p>思考下面的代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Foo.prototype.blah = ...;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"keyword\">new</span> Foo();</span><br></pre></td></tr></table></figure>\n<p>我们如何找出 a 的 “祖先”（委托关系）呢？</p>\n<ul>\n<li>方法一：<code>a instanceof Foo; // true</code> (对象 instanceof 函数)</li>\n<li>方法二: <code>Foo.prototype.isPrototypeOf(a); // true</code> (对象 isPrototypeOf 对象)</li>\n<li>方法三: <code>Object.getPrototypeOf(a) === Foo.prototype; // true</code> (Object.getPrototypeOf() 可以获取一个对象的 [[Prototype]]) 链;</li>\n<li>方法四: <code>a.__proto__ == Foo.prototype; // true</code></li>\n</ul>\n<h3 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h3><ul>\n<li>函数不是构造函数，而是当且仅当使用 new 时，函数调用会变成“构造函数调用”。</li>\n<li>使用 new 会在 prototype 生成一个 constructor 属性，指向构造调用的函数。</li>\n<li>constructor 并不表示被构造，而且 constructor 属性并不是一个不可变属性，它是不可枚举的，但它是可以被修改的。</li>\n</ul>\n<h3 id=\"对象关联\"><a href=\"#对象关联\" class=\"headerlink\" title=\"对象关联\"></a>对象关联</h3><p>来看下面的代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo = &#123;</span><br><span class=\"line\">  something: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Tell me something good...\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = <span class=\"built_in\">Object</span>.create(foo);</span><br><span class=\"line\"></span><br><span class=\"line\">bar.something(); <span class=\"comment\">// Tell me something good...</span></span><br></pre></td></tr></table></figure>\n<p>Object.create(..)会创建一个新对象 (bar) 并把它关联到我们指定的对象 (foo)，这样我们就可以充分发挥 [[Prototype]] 机制的为例（委托）并且避免不必要的麻烦 (比如使用 new 的构造函数调用会生成 .prototype 和 .constructor 引用)。</p>\n<p>Object.create(null) 会创建一个拥有空链接的对象，这个对象无法进行委托。由于这个对象没有原型链，所以 instanceof 操作符无法进行判断，因此总是会返回 false 。这些特殊的空对象通常被称作“字典”，它们完全不会受到原型链的干扰，因此非常适合用来存储数据。</p>\n<p>我们并不需要类来创建两个对象之间的关系，只需要通过委托来关联对象就足够了。而Object.create(..)不包含任何“类的诡计”，所以它可以完美地创建我们想要的关联关系。</p>\n<p>此书的第二章第6部分就把<code>面对类和继承</code>和<code>行为委托</code>两种设计模式进行了对比，我们可以看到行为委托是一种更加简洁的设计模式，在这种设计模式中能感受到<code>Object.create()</code>的强大。</p>\n<h3 id=\"ES6中的Class\"><a href=\"#ES6中的Class\" class=\"headerlink\" title=\"ES6中的Class\"></a>ES6中的Class</h3><p>来看一段 ES6中Class 的例子</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Widget</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(width, height) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.width = width || <span class=\"number\">50</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.height = height || <span class=\"number\">50</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.$elem = <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  render($where)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.$elem) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.$elem.css(&#123;</span><br><span class=\"line\">        width: <span class=\"keyword\">this</span>.width + <span class=\"string\">\"px\"</span>，</span><br><span class=\"line\">        height: <span class=\"keyword\">this</span>.height + <span class=\"string\">\"px\"</span></span><br><span class=\"line\">      &#125;).appendTo($where);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Button</span> <span class=\"keyword\">extends</span> <span class=\"title\">Widget</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(width, height, label) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(width, height);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.label = label || <span class=\"string\">\"Default\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.$elem = $(<span class=\"string\">\"&lt;button&gt;\"</span>).text(<span class=\"keyword\">this</span>.label)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  render($where) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>($where);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.$elem.click(<span class=\"keyword\">this</span>.onClick.bind(<span class=\"keyword\">this</span>));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  onClick(evt) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Button '\"</span> + <span class=\"keyword\">this</span>.label + <span class=\"string\">\"' clicked!\"</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>除了语法更好看之外，ES6还有以下优点</p>\n<ul>\n<li>基本上不再引用杂乱的 .prototype 了。</li>\n<li>Button 声明时直接 “继承” 了 Widget。</li>\n<li>可以通过 super(..)来实现相对多态，这样任何方法都可以引用原型链上层的同名方法。</li>\n<li>class 字面语法不能声明属性（只能声明方法）。这是一种限制，但是它会排除掉许多不好的情况。</li>\n<li>可以通过 extends 很自然地扩展对象(子)类型。</li>\n</ul>\n<p>但是 class 就是完美的吗？在传统面向类的语言中，类定义之后就不会进行修改，所以类的设计模式就不支持修改。但JavaScript 最强大的特性之一就是它的动态性，在使用 class 的有些时候还是会用到 .prototype 以及碰到 super (期望动态绑定然而静态绑定) 的问题，class 基本上都没有提供解决方案。</p>\n<p>这也是本书作者希望我们思考的问题。</p>\n","categories":["JavaScript"],"tags":["JavaScript","读书笔记"]},{"title":"Node.js 异步异闻录","url":"/posts/7b9fdc87/","content":"<p><img src=\"http://with.muyunyun.cn/d2867e4c299fe6b1f84d9610a6af1eb5.jpg-muyy\" alt=\"\"></p>\n<p>提到 Node.js, 我们脑海就会浮现异步、非阻塞、单线程等关键词，进一步我们还会想到 buffer、模块机制、事件循环、进程、V8、libuv 等知识点。本文起初旨在理顺 Node.js 以上易混淆概念，然而一入异步深似海，本文尝试基于 Node.js 的异步展开讨论，其他的主题只能日后慢慢补上了。(附：亦可以把本文当作是朴灵老师所著的《深入浅出 Node.js》一书的小结)。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"异步-I-O\"><a href=\"#异步-I-O\" class=\"headerlink\" title=\"异步 I/O\"></a>异步 I/O</h2><p>Node.js 正是依靠构建了一套完善的高性能异步 I/O 框架，从而打破了 JavaScript 在服务器端止步不前的局面。</p>\n<h3 id=\"异步-I-O-VS-非阻塞-I-O\"><a href=\"#异步-I-O-VS-非阻塞-I-O\" class=\"headerlink\" title=\"异步 I/O VS 非阻塞 I/O\"></a>异步 I/O VS 非阻塞 I/O</h3><p>听起来异步和非阻塞，同步和阻塞是相互对应的，从实际效果而言，异步和非阻塞都达到了我们并行 I/O 的目的，但是从计算机内核 I/O 而言，异步/同步和阻塞/非阻塞实际上是两回事。</p>\n<p>注意，操作系统内核对于 I/O 只有两种方式：阻塞与非阻塞。</p>\n<p>调用阻塞 I/O 的过程：</p>\n<p><img src=\"http://with.muyunyun.cn/886fcdd67d943f63951b0e3bb6dd6e43.jpg-200\" alt=\"\"></p>\n<p>调用非阻塞 I/O 的过程：</p>\n<p><img src=\"http://with.muyunyun.cn/38f95c2e0b80e6edb511cf32b8973b90.jpg-200\" alt=\"\"></p>\n<p>在此先引人一个叫作<code>轮询</code>的技术。轮询不同于回调，举个生活例子，你有事去隔壁寝室找同学，发现人不在，你怎么办呢？方法1，每隔几分钟再去趟隔壁寝室，看人在不；方法2，拜托与他同寝室的人，看到他回来时叫一下你；那么前者是轮询，后者是回调。</p>\n<p>再回到主题，阻塞 I/O 造成 CPU 等待浪费，非阻塞 I/O 带来的麻烦却是需要轮询去确认是否完全完成数据获取。<code>从操作系统的这个层面上看，对于应用程序而言，不管是阻塞 I/O 亦或是 非阻塞 I/O，它们都只能是一种同步</code>，因为尽管使用了轮询技术，应用程序仍然需要等待 I/O 完全返回。</p>\n<h3 id=\"Node-的异步-I-O\"><a href=\"#Node-的异步-I-O\" class=\"headerlink\" title=\"Node 的异步 I/O\"></a>Node 的异步 I/O</h3><p>完成整个异步 I/O 环节的有事件循环、观察者、请求对象以及 I/O 线程池。</p>\n<p><img src=\"http://with.muyunyun.cn/34ce4a4c1e2f298811565f15cd2318be.jpg-300\" alt=\"\"></p>\n<h4 id=\"事件循环\"><a href=\"#事件循环\" class=\"headerlink\" title=\"事件循环\"></a>事件循环</h4><p>在进程启动的时候，Node 会创建一个类似于 whlie(true) 的循环，每一次执行循环体的过程我们称为 Tick。</p>\n<p>每个 Tick 的过程就是查看是否有事件待处理，如果有，就取出事件及其相关的回调函数。如果存在相关的回调函数，就执行他们。然后进入下一个循环，如果不再有事件处理，就退出进程。</p>\n<p>伪代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(ture) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> event = eventQueue.pop()</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (event &amp;&amp; event.handler) &#123;</span><br><span class=\"line\">    event.handler.execute()  <span class=\"comment\">// execute the callback in Javascript thread</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    sleep() <span class=\"comment\">// sleep some time to release the CPU do other stuff</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"观察者\"><a href=\"#观察者\" class=\"headerlink\" title=\"观察者\"></a>观察者</h4><p>每个 Tick 的过程中，如何判断是否有事件需要处理，这里就需要引入观察者这个概念。</p>\n<p>每个事件循环中有一个或多个观察者，而判断是否有事件需要处理的过程就是向这些观察者询问是否有要处理的事件。</p>\n<p>在 Node 中，事件主要来源于网络请求、文件 I/O 等，这些事件都有对应的观察者。</p>\n<h4 id=\"请求对象\"><a href=\"#请求对象\" class=\"headerlink\" title=\"请求对象\"></a>请求对象</h4><p>对于 Node 中的异步 I/O 而言，回调函数不由开发者来调用，在 JavaScript 发起调用到内核执行完 id 操作的过渡过程中，存在一种中间产物，它叫作请求对象。</p>\n<blockquote>\n<p>请求对象是异步 I/O 过程中的重要中间产物，所有状态都保存在这个对象中，包括送入线程池等待执行以及 I/O 操作完后的回调处理</p>\n</blockquote>\n<p>以 <code>fs.open()</code> 为例：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">fs.open = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">path, flags, mode, callback</span>) </span>&#123;</span><br><span class=\"line\">  bingding.open(</span><br><span class=\"line\">    pathModule._makeLong(path),</span><br><span class=\"line\">    stringToFlags(flags),</span><br><span class=\"line\">    mode,</span><br><span class=\"line\">    callback</span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>fs.open</code> 的作用就是根据指定路径和参数去打开一个文件，从而得到一个文件描述符。</p>\n<p>从前面的代码中可以看到，JavaScript 层面的代码通过调用 C++ 核心模块进行下层的操作。</p>\n<p>从 JavaScript 调用 Node 的核心模块，核心模块调用 C++ 内建模块，内建模块通过 libuv 进行系统调用，这是 Node 里经典的调用方式。</p>\n<p>libuv 作为封装层，有两个平台的实现，实质上是调用了 uv_fs_open 方法，在 uv_fs_open 的调用过程中，会创建一个 FSReqWrap 请求对象，从 JavaScript 层传入的参数和当前方法都被封装在这个请求对象中。回调函数则被设置在这个对象的 oncomplete_sym 属性上。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">req_wrap -&gt; object_ -&gt; Set(oncomplete_sym, callback)</span><br></pre></td></tr></table></figure>\n\n<p>对象包装完毕后，在 Windows 下，则调用 QueueUserWorkItem() 方法将这个 FSReqWrap 对象推人线程池中等待执行。</p>\n<p>至此，JavaScript 调用立即返回，由 JavaScript 层面发起的异步调用的第一阶段就此结束(即上图所注释的异步 I/O 第一部分)。JavaScript 线程可以继续执行当前任务的后续操作，当前的 I/O 操作在线程池中等待执行，不管它是否阻塞 I/O，都不会影响到 JavaScript 线程的后续操作，如此达到了异步的目的。</p>\n<h4 id=\"执行回调\"><a href=\"#执行回调\" class=\"headerlink\" title=\"执行回调\"></a>执行回调</h4><p>组装好请求对象、送入 I/O 线程池等待执行，实际上是完成了异步 I/O 的第一部分，回调通知是第二部分。</p>\n<p>线程池中的 I/O 操作调用完毕之后，会将获取的结果储存在 <code>req -&gt; result</code> 属性上，然后调用 <code>PostQueuedCompletionStatus()</code> 通知 <code>IOCP</code>，告知当前对象操作已经完成，并将线程归还线程池。</p>\n<p>在这个过程中，我们动用了事件循环的 I/O 观察者，在每次 <code>Tick</code> 的执行过程中，它会调用 <code>IOCP</code> 相关的 <code>GetQueuedCompletionStatus</code> 方法检查线程池中是否有执行完的请求，如果存在，会将请求对象加入到 I/O 观察者的队列中，然后将其当做事件处理。</p>\n<p>I/O 观察者回调函数的行为就是取出请求对象的 <code>result</code> 属性作为参数，取出 <code>oncomplete_sym</code> 属性作为方法，然后调用执行，以此达到调用 JavaScript 中传入的回调函数的目的。</p>\n<h4 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h4><p>通过介绍完整个异步 I/O 后，有个需要重视的观点是 JavaScript 是单线程的，<code>Node 本身其实是多线程的</code>，只是 I/O 线程使用的 CPU 比较少；还有个重要的观点是，除了用户的代码无法并行执行外，所有的 I/O (磁盘 I/O 和网络 I/O) 则是可以并行起来的。</p>\n<h2 id=\"异步编程\"><a href=\"#异步编程\" class=\"headerlink\" title=\"异步编程\"></a>异步编程</h2><p>Node 是首个将异步大规模带到应用层面的平台。通过上文所述我们了解了 Node 如何通过事件循环实现异步 I/O，有异步 I/O 必然存在异步编程。异步编程的路经历了太多坎坷，从回调函数、发布订阅模式、Promise 对象，到 generator、asycn/await。趁着异步编程这个主题刚好把它们串起来理理。</p>\n<h3 id=\"异步-VS-回调\"><a href=\"#异步-VS-回调\" class=\"headerlink\" title=\"异步 VS 回调\"></a>异步 VS 回调</h3><p>对于刚接触异步的新人，很大几率会混淆回调 (callback) 和异步 (asynchronous) 的概念。先来看看维基的 <a href=\"https://en.wikipedia.org/wiki/Callback_(computer_programming)\" target=\"_blank\" rel=\"noopener\">Callback</a> 条目:</p>\n<blockquote>\n<p>In computer programming, a callback is any executable code that is passed as an argument to other code</p>\n</blockquote>\n<p>因此，回调本质上是一种设计模式，并且 jQuery (包括其他框架)的设计原则遵循了这个模式。</p>\n<p>在 JavaScript 中，回调函数具体的定义为：函数 A 作为参数(函数引用)传递到另一个函数 B 中，并且这个函数 B 执行函数 A。我们就说函数 A 叫做回调函数。如果没有名称(函数表达式)，就叫做匿名回调函数。</p>\n<p>因此 callback 不一定用于异步，一般同步(阻塞)的场景下也经常用到回调，比如要求执行某些操作后执行回调函数。讲了这么多让我们来看下同步回调和异步回调的例子：</p>\n<p>同步回调：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f2</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'f2 finished'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\">cb</span>) </span>&#123;</span><br><span class=\"line\">  cb()</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'f1 finished'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f1(f2)  <span class=\"comment\">// 得到的结果是 f2 finished, f1 finished</span></span><br></pre></td></tr></table></figure>\n\n<p>异步回调：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f2</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'f2 finished'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\">cb</span>) </span>&#123;</span><br><span class=\"line\">  setTimeout(cb, <span class=\"number\">1000</span>) <span class=\"comment\">// 通过 setTimeout() 来模拟耗时操作</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'f1 finished'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f1(f2)  <span class=\"comment\">// 得到的结果是 f1 finished, f2 finished</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"http://with.muyunyun.cn/43197a40f5c53e8a248f5c8de68e1e81.jpg-200\" alt=\"\"></p>\n<p>小结：回调可以进行同步也可以异步调用，但是 Node.js 提供的 API 大多都是异步回调的，比如 buffer、http、cluster 等模块。</p>\n<h3 id=\"发布-订阅模式\"><a href=\"#发布-订阅模式\" class=\"headerlink\" title=\"发布/订阅模式\"></a>发布/订阅模式</h3><p>事件发布/订阅模式 (PubSub) 自身并无同步和异步调用的问题，但在 Node 的 events 模块的调用中多半伴随事件循环而异步触发的，所以我们说事件发布/订阅广泛应用于异步编程。它的应用非常广泛，可以在异步编程中帮助我们完成更松的解耦，甚至在 MVC、MVVC 的架构中以及设计模式中也少不了发布-订阅模式的参与。</p>\n<p>以 jQuery 事件监听为例</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">$(<span class=\"string\">'#btn'</span>).on(<span class=\"string\">'myEvent'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;  <span class=\"comment\">// 触发事件</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'I am an Event'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">$(<span class=\"string\">'#btn'</span>).trigger(<span class=\"string\">'myEvent'</span>)           <span class=\"comment\">// 订阅事件</span></span><br></pre></td></tr></table></figure>\n\n<p>可以看到，订阅事件就是一个高阶函数的应用。事件发布/订阅模式可以实现一个事件与多个回调函数的关联，这些回调函数又称为事件侦听器。下面我们来看看发布/订阅模式的简易实现。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> PubSub = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.handlers = &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">PubSub.prototype.subscribe = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">eventType, handler</span>) </span>&#123; <span class=\"comment\">// 注册函数逻辑</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!(eventType <span class=\"keyword\">in</span> <span class=\"keyword\">this</span>.handlers)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.handlers[eventType] = []</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.handlers[eventType].push(handler)  <span class=\"comment\">// 添加事件监听器</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span> <span class=\"comment\">// 返回上下文环境以实现链式调用</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">PubSub.prototype.publish = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">eventType</span>) </span>&#123;  <span class=\"comment\">// 发布函数逻辑</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> _args = <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>, _handlers = <span class=\"keyword\">this</span>.handlers[eventType]; i &lt; _handlers.length; i++) &#123;  <span class=\"comment\">// 遍历事件监听器</span></span><br><span class=\"line\">    _handlers[i].apply(<span class=\"keyword\">this</span>, _args) <span class=\"comment\">// 调用事件监听器</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> event = <span class=\"keyword\">new</span> PubSub <span class=\"comment\">// 构造 PubSub 实例</span></span><br><span class=\"line\"></span><br><span class=\"line\">event.subscribe(<span class=\"string\">'name'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">msg</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'my name is '</span> + msg)  <span class=\"comment\">// my name is muyy</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">event.publish(<span class=\"string\">'name'</span>, <span class=\"string\">'muyy'</span>)</span><br></pre></td></tr></table></figure>\n\n<p>至此，一个简易的订阅发布模式就实现了。然而发布/订阅模式也存在一些缺点，创建订阅本身会消耗一定的时间与内存，也许当你订阅一个消息之后，之后可能就不会发生。发布-订阅模式虽然它弱化了对象与对象之间的关系，但是如果过度使用，对象与对象的必要联系就会被深埋，会导致程序难以跟踪与维护。</p>\n<h3 id=\"Promise-Deferred-模式\"><a href=\"#Promise-Deferred-模式\" class=\"headerlink\" title=\"Promise/Deferred 模式\"></a>Promise/Deferred 模式</h3><p>想象一下，如果某个操作需要经过多个非阻塞的 IO 操作，每一个结果都是通过回调，程序有可能会看上去像这个样子。这样的代码很难维护。这样的情况更多的会发生在 server side 的情况下。代码片段如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">operation1(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, result1</span>) </span>&#123;</span><br><span class=\"line\">  operation2(result1, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, result2</span>) </span>&#123;</span><br><span class=\"line\">    operation3(result2, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, result3</span>) </span>&#123;</span><br><span class=\"line\">      operation4(result3, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, result4</span>) </span>&#123;</span><br><span class=\"line\">        callback(result4) <span class=\"comment\">// do something useful</span></span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>这时候，Promise 出现了，其出现的目的就是为了解决所谓的回调地狱的问题。让我们看下使用 Promise 后的代码片段：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">promise()</span><br><span class=\"line\">  .then(operation1)</span><br><span class=\"line\">  .then(operation2)</span><br><span class=\"line\">  .then(operation3)</span><br><span class=\"line\">  .then(operation4)</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value4</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Do something with value4</span></span><br><span class=\"line\">  &#125;, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Handle any error from step1 through step4</span></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .done()</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，使用了第二种编程模式后能极大地提高我们的编程体验，接着就让我们自己动手实现一个支持序列执行的 Promise。(附：为了直观的在浏览器上也能感受到 Promise，为此也写了一段<a href=\"https://github.com/MuYunyun/demos-of-node.js/blob/master/promise/browser.js\" target=\"_blank\" rel=\"noopener\">浏览器上的 Promise 用法示例</a>)</p>\n<p>在此之前，我们先要了解 Promise/A 提议中对单个异步操作所作的抽象定义，定义具体如下所示：</p>\n<ul>\n<li>Promise 操作只会处在 3 种状态的一种：未完成态、完成态和失败态。</li>\n<li>Promise 的状态只会出现从未完成态向完成态或失败态转化，不能逆反。完成态和失败态不能相互转化。</li>\n<li>Promise 的状态一旦转化，将不能被更改。</li>\n</ul>\n<p>Promise 的状态转化示意图如下：</p>\n<p><img src=\"http://with.muyunyun.cn/e1a0c15c44f9b014aa78d7b7620db474.jpg-200\" alt=\"\"></p>\n<p>除此之外，Promise 对象的另一个关键就是需要具备 then() 方法，对于 then() 方法，有以下简单的要求:</p>\n<ul>\n<li>接受完成态、错误态的回调方法。在操作完成或出现错误时，将会调用对应方法。</li>\n<li>then() 方法只接受 function 对象，其余对象将被忽略。</li>\n<li>then() 方法继续返回 Promise 对象，已实现链式调用。</li>\n</ul>\n<p>then() 方法的定义如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">then(fulfilledHandler, errorHandler)</span><br></pre></td></tr></table></figure>\n\n<p>有了这些核心知识，接着进入 Promise/Deferred 核心代码环节：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"built_in\">Promise</span> = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"comment\">// 构建 Promise 对象</span></span><br><span class=\"line\">  <span class=\"comment\">// 队列用于存储执行的回调函数</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.queue = []</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.isPromise = <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.prototype.then = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">fulfilledHandler, errorHandler</span>) </span>&#123; <span class=\"comment\">// 构建 Progress 的 then 方法</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> handler = &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> fulfilledHandler === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">    handler.fulfilled = fulfilledHandler</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> errorHandler === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">    handler.error = errorHandler</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.queue.push(handler)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如上 Promise 的代码就完成了，但是别忘了 Promise/Deferred 中的后者 Deferred，为了完成 Promise 的整个流程，我们还需要触发执行上述回调函数的地方，实现这些功能的对象就叫作 Deferred，即延迟对象。</p>\n<p>Promise 和 Deferred 的整体关系如下图所示，从中可知，Deferred 主要用于内部来维护异步模型的状态；而 Promise 则作用于外部，通过 then() 方法暴露给外部以添加自定义逻辑。</p>\n<p><img src=\"http://with.muyunyun.cn/f461de8674e1268ec19470534a07320a.jpg-400\" alt=\"\"></p>\n<p>接着来看 Deferred 代码部分的实现：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Deferred = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 完成态</span></span><br><span class=\"line\">Deferred.prototype.resolve = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> promise = <span class=\"keyword\">this</span>.promise</span><br><span class=\"line\">  <span class=\"keyword\">var</span> handler</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(handler = promise.queue.shift()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (handler &amp;&amp; handler.fulfilled) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> ret = handler.fulfilled(obj)</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (ret &amp;&amp; ret.isPromise) &#123; <span class=\"comment\">// 这一行以及后面3行的意思是：一旦检测到返回了新的 Promise 对象，停止执行，然后将当前 Deferred 对象的 promise 引用改变为新的 Promise 对象，并将队列中余下的回调转交给它</span></span><br><span class=\"line\">        ret.queue = promise.queue</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.promise = ret</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 失败态</span></span><br><span class=\"line\">Deferred.prototype.reject = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> promise = <span class=\"keyword\">this</span>.promise</span><br><span class=\"line\">  <span class=\"keyword\">var</span> handler</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (handler = promise.queue.shift()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (handler &amp;&amp; handler.error) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> ret = handler.error(err)</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (ret &amp;&amp; ret.isPromise) &#123;</span><br><span class=\"line\">        ret.queue = promise.queue</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.promise = ret</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 生成回调函数</span></span><br><span class=\"line\">Deferred.prototype.callback = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> that = <span class=\"keyword\">this</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, file</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(err) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> that.reject(err)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    that.resolve(file)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接着我们以两次文件读取作为例子，来验证该设计的可行性。这里假设第二个文件读取依赖于第一个文件中的内容，相关代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> readFile1 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">file, encoding</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> deferred = <span class=\"keyword\">new</span> Deferred()</span><br><span class=\"line\">  fs.readFile(file, encoding, deferred.callback())</span><br><span class=\"line\">  <span class=\"keyword\">return</span> deferred.promise</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> readFile2 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">file, encoding</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> deferred = <span class=\"keyword\">new</span> Deferred()</span><br><span class=\"line\">  fs.readFile(file, encoding, deferred.callback())</span><br><span class=\"line\">  <span class=\"keyword\">return</span> deferred.promise</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">readFile1(<span class=\"string\">'./file1.txt'</span>, <span class=\"string\">'utf8'</span>).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">file1</span>) </span>&#123; <span class=\"comment\">// 这里通过 then 把两个回调存进队列中</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> readFile2(file1, <span class=\"string\">'utf8'</span>)</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">file2</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(file2)   <span class=\"comment\">// I am file2.</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>最后可以看到控制台输出 <code>I am file2</code>，验证成功~，这个案例的完整代码可以<a href=\"https://github.com/MuYunyun/demos-of-node.js/blob/master/promise/sequence.js\" target=\"_blank\" rel=\"noopener\">点这里查看</a>，并建议使用 <a href=\"https://github.com/node-inspector/node-inspector\" target=\"_blank\" rel=\"noopener\">node-inspector</a> 进行断点观察，(这段代码里面有些逻辑确实很绕，通过断点调试就能较容易理解了)。</p>\n<p>从 Promise 链式调用可以清晰地看到队列(先进先出)的知识，其有如下两个核心步骤：</p>\n<ul>\n<li>将所有的回调都存到队列中；</li>\n<li>Promise 完成时，逐个执行回调，一旦检测到返回了新的 Promise 对象，停止执行，然后将当前 Deferred 对象的 promise 引用改变为新的 Promise 对象，并将队列中余下的回调转交给它；</li>\n</ul>\n<p>至此，实现了 Promise/Deferred 的完整逻辑，Promise 的其他知识未来也会继续探究。</p>\n<h3 id=\"Generator\"><a href=\"#Generator\" class=\"headerlink\" title=\"Generator\"></a>Generator</h3><p>尽管 Promise 一定程度解决了回调地狱的问题，但是对于喜欢简洁的程序员来说，一大堆的模板代码 <code>.then(data =&gt; {...})</code> 显得不是很友好。所以爱折腾的开发者们在 ES6 中引人了 Generator 这种数据类型。仍然以读取文件为例，先上一段非常简洁的 Generator + co 的代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">co(<span class=\"function\"><span class=\"keyword\">function</span>* (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> file1 = <span class=\"keyword\">yield</span> readFile(<span class=\"string\">'./file1.txt'</span>)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> file2 = <span class=\"keyword\">yield</span> readFile(<span class=\"string\">'./file2.txt'</span>)</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(file1)</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(file2)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>可以看到比 Promise 的写法简洁了许多。后文会给出 co 库的实现原理。在此之前，先归纳下什么是 Generator。可以把 Generator 理解为一个可以遍历的状态机，调用 next 就可以切换到下一个状态，其最大特点就是可以交出函数的执行权（即暂停执行），让我们看如下代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">gen</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;<span class=\"keyword\">return</span> <span class=\"number\">1</span>&#125;)()</span><br><span class=\"line\">  <span class=\"keyword\">var</span> y = <span class=\"keyword\">yield</span> x + <span class=\"number\">2</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> y</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 调用方式一</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> g = gen(<span class=\"number\">1</span>)</span><br><span class=\"line\">g.next()  <span class=\"comment\">// &#123; value: 1, done: false &#125;</span></span><br><span class=\"line\">g.next()  <span class=\"comment\">// &#123; value: 3, done: false &#125;</span></span><br><span class=\"line\">g.next()  <span class=\"comment\">// &#123; value: undefined, done: true &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 调用方式二</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> g = gen(<span class=\"number\">1</span>)</span><br><span class=\"line\">g.next()  <span class=\"comment\">// &#123; value: 1, done: false &#125;</span></span><br><span class=\"line\">g.next()  <span class=\"comment\">// &#123; value: 3, done: false &#125;</span></span><br><span class=\"line\">g.next(<span class=\"number\">10</span>)  <span class=\"comment\">// &#123; value: 10, done: true &#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>由此我们归纳下 Generator 的基础知识：</p>\n<ol>\n<li>Generator 生成迭代器后，等待迭代器的 <code>next()</code> 指令启动。</li>\n<li>启动迭代器后，代码会运行到 <code>yield</code> 处停止。并返回一个 {value: AnyType, done: Boolean} 对象，value 是这次执行的结果，done 是迭代是否结束。并等待下一次的 next() 指令。</li>\n<li>next() 再次启动，若 done 的属性不为 true，则可以继续从上一次停止的地方继续迭代。</li>\n<li>一直重复 2，3 步骤，直到 done 为 true。</li>\n<li>通过调用方式二，我们可看到 next 方法可以带一个参数，该参数就会被当作<code>上一个 yield 语句的返回值</code>。</li>\n</ol>\n<p>另外我们注意到，上述代码中的第一种调用方式中的 y 值是 undefined，如果我们真想拿到 y 值，就需要通过 <code>g.next(); g.next().value</code> 这种方式取出。可以看出，Generator 函数将异步操作表示得很简洁，但是流程管理却不方便。这时候用于 Generator 函数的自动执行的 <a href=\"https://github.com/tj/co/blob/master/index.js\" target=\"_blank\" rel=\"noopener\">co 函数库</a> 登场了。为什么 co 可以自动执行 Generator 函数呢？我们知道，Generator 函数就是一个异步操作的容器。它的自动执行需要一种机制，当异步操作有了结果，能够自动交回执行权。</p>\n<p>两种方法可以做到这一点：</p>\n<ul>\n<li>Thunk 函数。将异步操作包装成 Thunk 函数，在回调函数里面交回执行权。</li>\n<li>Promise 对象。将异步操作包装成 Promise 对象，用 then 方法交回执行权。</li>\n</ul>\n<p>co 函数库其实就是将两种自动自动执行器(Thunk 函数和 Promise 对象)，包装成一个库。使用 co 的前提条件是，<code>Generator 函数的 yield 命令后面，只能是 Thunk 函数或者是 Promise 对象</code>。下面分别用以上两种方法对 co 进行一个简单的实现。</p>\n<h4 id=\"基于-Thunk-函数的自动执行\"><a href=\"#基于-Thunk-函数的自动执行\" class=\"headerlink\" title=\"基于 Thunk 函数的自动执行\"></a>基于 Thunk 函数的自动执行</h4><p>在 JavaScript 中，Thunk 函数就是指将多参数函数替换成单参数的形式，并且其只接受回调函数作为参数的函数。Thunk 函数的例子如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 正常版本的 readFile(多参数)</span></span><br><span class=\"line\">fs.readFile(filename, <span class=\"string\">'utf8'</span>, callback)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Thunk 版本的 readFile(单参数)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">readFile</span>(<span class=\"params\">filename</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">callback</span>) </span>&#123;</span><br><span class=\"line\">        fs.readFile(filename, <span class=\"string\">'utf8'</span>, callback);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在基于 Thunk 函数和 Generator 的知识上，接着我们来看看 co 基于 Thunk 函数的实现。(附：代码参考自<a href=\"https://cnodejs.org/topic/53474cd19e21582e740117df\" target=\"_blank\" rel=\"noopener\">co最简版实现</a>)</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">co</span>(<span class=\"params\">generator</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> gen = generator()</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">next</span>(<span class=\"params\">err, result</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(err) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fn(err)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> step = gen.next(result)</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!step.done) &#123;</span><br><span class=\"line\">        step.value(next) <span class=\"comment\">// 这里可以把它联想成递归；将异步操作包装成 Thunk 函数，在回调函数里面交回执行权。</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        fn(<span class=\"literal\">null</span>, step.value)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    next()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>用法如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">co(<span class=\"function\"><span class=\"keyword\">function</span>* (<span class=\"params\"></span>) </span>&#123;  <span class=\"comment\">// 把 function*() 作为参数 generator 传入 co 函数</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> file1 = <span class=\"keyword\">yield</span> readFile(<span class=\"string\">'./file1.txt'</span>)</span><br><span class=\"line\">  <span class=\"keyword\">var</span> file2 = <span class=\"keyword\">yield</span> readFile(<span class=\"string\">'./file2.txt'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(file1) <span class=\"comment\">// I'm file1</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(file2) <span class=\"comment\">// I'm file2</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">'done'</span></span><br><span class=\"line\">&#125;)(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, result</span>) </span>&#123;  <span class=\"comment\">// 这部分的 function 作为 co 函数内的 fn 的实参传入</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(result) <span class=\"comment\">// done</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>上述部分关键代码已进行注释，下面对 co 函数里的几个难点进行说明：</p>\n<ul>\n<li><code>var step = gen.next(result)</code>, 前文提到的一句话在这里就很有用处了：<code>next方法可以带一个参数，该参数就会被当作上一个yield语句的返回值</code>;在上述代码的运行中一共会经过这个地方 3 次，result 的值第一次是空值，第二次是 file1.txt 的内容 I’m file1，第三次是 file2.txt 的内容 I’m file2。根据上述关键语句的提醒，所以第二次的内容会作为 file1 的值(当作上一个yield语句的返回值)，同理第三次的内容会作为 file2 的值。</li>\n<li>另一处是 <code>step.value(next)</code>, step.value 就是前面提到的 thunk 函数返回的 function(callback) {}, next 就是传入 thunk 函数的 callback。这句代码是条递归语句，是这个简易版 co 函数能自动调用 Generator 的关键语句。</li>\n</ul>\n<p>建议亲自跑一遍代码，多打断点，从而更好地理解，代码已上传<a href=\"https://github.com/MuYunyun/demos-of-node.js/blob/master/generator/thunk.js\" target=\"_blank\" rel=\"noopener\">github</a>。</p>\n<h4 id=\"基于-Promise-对象的自动执行\"><a href=\"#基于-Promise-对象的自动执行\" class=\"headerlink\" title=\"基于 Promise 对象的自动执行\"></a>基于 Promise 对象的自动执行</h4><p>基于 Thunk 函数的自动执行中，yield 后面需跟上 Thunk 函数，在基于 Promise 对象的自动执行中，yield 后面自然要跟 Promise 对象了，让我们先构建一个 readFile 的<br> Promise 对象：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">readFile</span>(<span class=\"params\">fileName</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    fs.readFile(fileName, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error, data</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (error) reject(error)</span><br><span class=\"line\">      resolve(data)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在基于前文 Promise 对象和 Generator 的知识上，接着我们来看看 co 基于 Promise 函数的实现:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">co</span>(<span class=\"params\">generator</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> gen = generator()</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">next</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> result = gen.next(data) <span class=\"comment\">// 同上，经历了 3 次，第一次是 undefined，第二次是 I'm file1，第三次是 I'm file2</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (result.done) <span class=\"keyword\">return</span> result.value</span><br><span class=\"line\">    result.value.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123; <span class=\"comment\">// 将异步操作包装成 Promise 对象，用 then 方法交回执行权</span></span><br><span class=\"line\">      next(data)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  next()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>用法如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">co(<span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">generator</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> file1 = <span class=\"keyword\">yield</span> readFile(<span class=\"string\">'./file1.txt'</span>)</span><br><span class=\"line\">  <span class=\"keyword\">var</span> file2 = <span class=\"keyword\">yield</span> readFile(<span class=\"string\">'./file2.txt'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(file1.toString())  <span class=\"comment\">// I'm file1</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(file2.toString())  <span class=\"comment\">// I'm file2</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>这一部分的代码上传在<a href=\"https://github.com/MuYunyun/demos-of-node.js/blob/master/generator/promiseGen.js\" target=\"_blank\" rel=\"noopener\">这里</a>，通过观察可以发现基于 Thunk 函数和基于 Promise 对象的自动执行方案的 co 函数设计思路几乎一致，也因此呼应了它们共同的本质 —— 当异步操作有了结果，自动交回执行权。</p>\n<h3 id=\"async\"><a href=\"#async\" class=\"headerlink\" title=\"async\"></a>async</h3><p>看上去 Generator 已经足够好用了，但是使用 Generator 处理异步必须得依赖 tj/co，于是 asycn 出来了。本质上 async 函数就是 Generator 函数的语法糖，这样说是因为 async 函数的实现，就是将 Generator 函数和自动执行器，包装进一个函数中。伪代码如下，(注：其中 automatic 的实现可以参考 <a href=\"http://www.ruanyifeng.com/blog/2015/05/async.html\" target=\"_blank\" rel=\"noopener\">async 函数的含义和用法</a>中的实现)</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">args</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">args</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> automatic(<span class=\"function\"><span class=\"keyword\">function</span>*(<span class=\"params\"></span>) </span>&#123;  <span class=\"comment\">// automatic 函数就是自动执行器，其的实现可以仿照 co 库自动运行方案来实现，这里就不展开了</span></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接着仍然以上文的读取文件为例，来比较 Generator 和 async 函数的写法差异：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Generator</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> genReadFile = co(<span class=\"function\"><span class=\"keyword\">function</span>*(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> file1 = <span class=\"keyword\">yield</span> readFile(<span class=\"string\">'./file1.txt'</span>)</span><br><span class=\"line\">  <span class=\"keyword\">var</span> file2 = <span class=\"keyword\">yield</span> readFile(<span class=\"string\">'./file2.txt'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 改用 async 函数</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> asyncReadFile = <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> file1 = <span class=\"keyword\">await</span> readFile(<span class=\"string\">'./file1.txt'</span>)</span><br><span class=\"line\">  <span class=\"keyword\">var</span> file2 = <span class=\"keyword\">await</span> <span class=\"number\">1</span>  <span class=\"comment\">// 等同于同步操作（如果跟上原始类型的值）</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>总体来说 async/await 看上去和使用 co 库后的 generator 看上去很相似，不过相较于 Generator，可以看到 Async 函数更优秀的几点：</p>\n<ul>\n<li>内置执行器。Generator 函数的执行必须依靠执行器，而 Aysnc 函数自带执行器，调用方式跟普通函数的调用一样；</li>\n<li>更好的语义。async 和 await 相较于 * 和 yield 更加语义化；</li>\n<li>更广的适用性。前文提到的 co 模块约定，yield 命令后面只能是 Thunk 函数或 Promise 对象，而 async 函数的 await 命令后面则可以是 Promise 或者原始类型的值；</li>\n<li>返回值是 Promise。async 函数返回值是 Promise 对象，比 Generator 函数返回的 Iterator 对象方便，因此可以直接使用 then() 方法进行调用；</li>\n</ul>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://github.com/JacksonTian\" target=\"_blank\" rel=\"noopener\">深入浅出 Node.js</a></li>\n<li><a href=\"https://segmentfault.com/q/1010000000140970\" target=\"_blank\" rel=\"noopener\">理解回调函数</a></li>\n<li><a href=\"http://blog.codingplayboy.com/2016/01/20/js_async_intro/\" target=\"_blank\" rel=\"noopener\">JavaScript之异步编程简述</a></li>\n<li><a href=\"http://www.html-js.com/article/Nodejs-study-notes-to-understand-co-execution-logic\" target=\"_blank\" rel=\"noopener\">理解co执行逻辑</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2015/05/co.html\" target=\"_blank\" rel=\"noopener\">co 函数库的含义和用法</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2015/05/async.html\" target=\"_blank\" rel=\"noopener\">async 函数的含义和用法</a></li>\n</ul>\n","categories":["Node.js"],"tags":["Node.js"]}]