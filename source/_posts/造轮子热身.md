---
title: 造轮子热身
copyright: true
date: 2017-12-07 19:16:39
tags:
categories:
---

### 让模块同时在 Node.js 与浏览器中运行

```js
// Only Node.JS has a process variable that is of [[Class]] process
const isNode = Object.prototype.toString.call(typeof process !== 'undefined' ? process : 0) === '[object process]'
```

你可以通过检测是否有名为 window 的全局变量（例如 !!typeof window）来判断模块当前是运行在 Node.js 还是浏览器中，然后使用不同的方式实现你的功能。

这种方法比较常见，但如果用户使用了模块打包工具，这样做会导致 Node.js 与浏览器的实现方式都会被包含在最终的输出文件中。针对这个问题，开源社区提出了在 package.json 中添加 browser 字段的[提议](https://github.com/defunctzombie/package-browser-field-spec)，目前 webpack 和 rollup 都已经支持这个字段了。

browser 字段有两种使用方式：

给 browser 字段提供一个文件路径作为在浏览器端使用时的模块入口，但需要注意的是，打包工具会优先使用 browser 字段指定的文件路径作为模块入口，所以你的 module 字段会被忽略，这会导致打包工具不会优化你的代码。详细信息请参考[这个问题](http://link.zhihu.com/?target=https%3A//github.com/webpack/webpack/issues/4674)。
如果你只想替换其中一些文件，你可以声明一个对象。
举个例子，假设你的模块里有两个文件：http.js 和 xhr.js，第一个文件使用 Node.js 中的 http 模块发起请求，另一个使用浏览器中的 XMLHTTPRequest 实现了同样的功能。为了使用适当的文件，你的模块代码中应该始终 require(‘./path/to/http.js’)，并在 package.json 中声明：

```js
  "browser": "lib/diana.front.js",
  "module": "lib/diana.back.js",
```

这样一来，当你的模块在打包工具中使用时，打包工具只会将 xhr.js 的代码包含在最终的输出文件中。

### link

[开发更好用的 JavaScript 模块](http://web.jobbole.com/93179/)