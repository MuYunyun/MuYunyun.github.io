---
title: 造轮子热身
copyright: true
date: 2017-12-07 19:16:39
tags:
categories:
---


### 重复造轮子的意义
为啥已经有如此多的前端工具类库还要自己造轮子呢？个人有以下几个观点吧，
* 定制性强，能根据自己的需求为主导延伸开发。万一一不小心帮到别人；
* 纸上得来终觉浅，很多流行的库，只是照着它们的 API 进行使用，其实这些库里蕴含着大量的知识、技巧，最好的办法就是仿照它们来写些小 demo，从而体会这些库的精髓；
* 造轮子的过程中能让自己体会到与平常业务开发不一样的乐趣；
* 就先瞎编到这里了。。。

### 让模块同时在 Node.js 与浏览器中运行

```js
// Only Node.JS has a process variable that is of [[Class]] process
const isNode = Object.prototype.toString.call(typeof process !== 'undefined' ? process : 0) === '[object process]'
```

你可以通过检测是否有名为 window 的全局变量（例如 !!typeof window）来判断模块当前是运行在 Node.js 还是浏览器中，然后使用不同的方式实现你的功能。

这种方法比较常见，但如果用户使用了模块打包工具，这样做会导致 Node.js 与浏览器的实现方式都会被包含在最终的输出文件中。针对这个问题，开源社区提出了在 package.json 中添加 browser 字段的[提议](https://github.com/defunctzombie/package-browser-field-spec)，目前 webpack 和 rollup 都已经支持这个字段了。

给 browser 字段提供一个文件路径作为在浏览器端使用时的模块入口，但需要注意的是，打包工具会优先使用 browser 字段指定的文件路径作为模块入口，所以你的 main 字段 和 module 字段会被忽略，这会导致打包工具不会优化你的代码。详细信息请参考[这个问题](http://link.zhihu.com/?target=https%3A//github.com/webpack/webpack/issues/4674)。

比如在 [diana 库]() 为了在不同环境中使用适当的文件，在 package.json 中进行了如下声明：

```js
  "browser": "lib/diana.js",
  "main": "lib/diana.back.js", // 或者 "module": "lib/diana.back.js",
```

这样一来，在 node 环境中，引用的是 `lib/diana.back.js` 文件，在浏览器环境中，引用的是 `lib/diana.js` 文件。

### 常见模块规范比较

#### CommonJS

* CommonJs 是服务器端模块的规范，`Node.js 采用了这个规范`。这些规范涵盖了模块、二进制、Buffer、字符集编码、I/O流、进程环境、文件系统、套接字、单元测试、服务器网关接口、包管理等。

* 根据 CommonJS 规范，一个单独的文件就是一个模块。加载模块使用 `require` 方法，该方法读取一个文件并执行，最后返回文件内部的 `exports` 对象。

* CommonJS 加载模块是同步的。像Node.js主要用于服务器的编程，加载的模块文件一般都已经存在本地硬盘，所以加载起来比较快，不用考虑异步加载的方式，所以CommonJS规范比较适用。但如果是浏览器环境，要从服务器加载模块，这是就必须采用异步模式。所以就有了 AMD、CMD 解决方案。

#### AMD、CMD

* AMD 是 RequireJS 在推广过程中对模块定义的规范化产物。AMD 推崇提前执行。
```js
 // AMD 默认推荐的是
define(['./a', './b'], function(a, b) {
  a.doSomething()
  b.doSomething()
  ...
})
```

* CMD 是 SeaJS 在推广过程中对模块定义的规范化产物。CMD 推崇依赖就近。
```js
// CMD
define(function(require, exports, module) {
  var a = require('./a')
  a.doSomething()
  var b = require('./b')
  b.doSomething()
  ...
})
```

#### UMD

UMD 是 AMD 和 CommonJS 的结合。因为 AMD 是以浏览器为出发点的异步加载模块，CommonJS 是以服务器为出发点的同步加载模块，所以人们想出了另一个更通用的模式 UMD，来解决跨平台的问题。

[diana 库](https://github.com/MuYunyun/diana/blob/master/lib/diana.js#L1) 就是选择了以 umd 方式进行输出，来看下 UMD 做了啥。
```js
(function (root, factory) {
  if (typeof exports === 'object' && typeof module === 'object') { // UMD 先判断是否支持 Node.js 的模块（exports）是否存在，存在则使用 CommonJS 模式
    module.exports = factory()
  } else if (typeof define === 'function' && define.amd) { // 接着判断是否支持 AMD（define是否存在），存在则使用 AMD 方式加载模块。
    define([], factory)
  } else if (typeof exports === 'object') { // CommonJS 的另一种形式
    exports['diana'] = factory()
  } else
    root['diana'] = factory() // Window
})(this, function() {
  return module
})
```

### 测试踩坑之路

#### 代码覆盖率
单元测试的代码覆盖率统计，是衡量测试用例好坏的一个的方法。但凡是知名点的库，基本上都少不了 上图。。。。，这个覆盖率分为以下 4 种，

* 行覆盖率（line coverage）：是否每一行都执行了？
* 函数覆盖率（function coverage）：是否每个函数都调用了？
* 分支覆盖率（branch coverage）：是否每个if代码块都执行了？
* 语句覆盖率（statement coverage）：是否每个语句都执行了？

#### mocha + istanbul

[最初的版本](https://github.com/MuYunyun/diana/blob/d81991f588046b428e2ac959fb6b87e6edb4938e/package.json#L23), 仅仅用到 mocha 进行测试 *.test.js 文件，然后在 [codecov](https://codecov.io/gh/MuYunyun/diana) 得到测试覆盖率。

#### 引人 karma

如果仅仅测试 es5、es6 的语法，其实用 mocha 就已经够用了，但是涉及到测试 Dom 方面的语法就必须建立一个浏览器，在上面进行测试。karma 的作用其实就是自动帮我们建立一个测试用的浏览器。这里补充。。。。。

为了让浏览器支持 Common.js 规范，中间用了 karma + browserify，尽管测试用例都跑通了，但是最后的代码覆盖率的文件里只有各个方法的引用路径。最后只能又回到 karma + webpack 来，这里又踩到一个坑，[打包编译JS代码覆盖率问题](https://segmentfault.com/a/1190000004283830)，摸索了一整天以后，终于完成了自己期望的代码覆盖率展现。覆盖率图如下：

这里补充图。。。。。。。。。。

[配置文件](https://github.com/MuYunyun/diana/blob/master/karma.conf.js)，核心部分如下:
```js
module.exports = function(config) {
  config.set({
    files: ['test/index.js'], // 需载入浏览器的文件
    preprocessors: { // 预处理
      'test/index.js': ['webpack', 'coverage']
    },
    webpack: {
      module: {
        rules: [{
          test: /\.js$/,
          use: { loader: 'sourcemap-istanbul-instrumenter-loader' }, // 这里用 istanbul-instrumenter-loader 插件的 0.0.2 版本，其它版本有坑~
          exclude: [/node_modules/, /\.spec.js$/],
        }],
      }
    },
    coverageReporter: {
      type: 'lcov', // 貌似只能支持这种类型的读取
      dir: 'coverage/'
    },
    remapIstanbulReporter: { // 生成 coverage 文件
      reports: {
        'text-summary': null,
        json: 'coverage/coverage.json',
        lcovonly: 'coverage/lcov.info',
        html: 'coverage/html/',
      }
    },
    reporters: ['progress', 'karma-remap-istanbul'], // remap-isbanbul 也报了一个未找到 sourcemap 的 error，直接注释了 remap-istanbul 包的 CoverageTransformer.js 文件的 169 行，以后有机会再捣鼓吧。（心累）
    ...
  })
}

```



### link

[开发更好用的 JavaScript 模块](http://web.jobbole.com/93179/)
[Common JS、AMD、CMD和UMD的区别](http://www.cnblogs.com/sapho/p/4982483.html)